{
	"fastio": {
		"prefix": "fastio",
		"body": [
		  "/**",
		  " * FASTIO",
		  " * https://github.com/Pentagon03/Algorithms/blob/master/Etc/fastio.cpp",
		  " * Just use as if we use cin, cout. + u dont have to get rid of cin.tie(0)->sync_with_stdio(0);",
		  " * call cout.setprecision(prec) for double precision. default is 6",
		  " * __int128_t -> input or print is ok",
		  " * you can call numeric_limits min/max // most implementations can't input or output numeric_limits<int>::min();",
		  " * cin.geti() , cin.geti<ll>(), cin.getline() all works.",
		  " * Special function: vector, pair input/output => vector<int> v(3); cin>>v; // Works!",
		  " * ",
		  " * TEST",
		  "    static const __uint128_t UINT128_MAX =__uint128_t(__int128_t(-1L));",
		  "    static const __int128_t INT128_MAX = UINT128_MAX >> 1;",
		  "    static const __int128_t INT128_MIN = -INT128_MAX - 1;",
		  "    __int128_t x; ",
		  "    cin >> x; // works",
		  "    cout<< x << '\\n'; // works",
		  "    cout<< INT128_MIN << '\\n'; // works",
		  "**/",
		  "#define FASTIO 1",
		  "#if FASTIO",
		  "constexpr int SIZ = 1<<20;",
		  "class _IN{",
		  "    private:",
		  "        char buf[SIZ+1],*p=buf;",
		  "        int __END_FLAG__{}, __GETLINE_FLAG__{};",
		  "    public:",
		  "        explicit operator bool(){return !__END_FLAG__;}",
		  "        inline bool isEnd(char c){ return c == '\\0';}",
		  "        inline bool isBlank(char c){return c=='\\n'||c==' '||c=='\\t'||c=='\\r';}",
		  "        inline char read(){",
		  "            if(__END_FLAG__) return '\\0';",
		  "            if(isEnd(*p)) {",
		  "                buf[fread(buf,sizeof(char),SIZ,stdin)] = 0; ",
		  "                p = buf;",
		  "                if(isEnd(*p)){",
		  "                    return '\\0';",
		  "                }",
		  "            };",
		  "            return *p++;",
		  "        }",
		  "        inline void scan(char&c){",
		  "            do c=read(); while(isBlank(c));",
		  "            if(isEnd(c)) __END_FLAG__ = true;",
		  "        }",
		  "        inline void scan(string&s){",
		  "            s.clear(); char c; scan(c);",
		  "            while(!isBlank(c) && !isEnd(c)) s.push_back(c), c=read();",
		  "        }",
		  "        inline void scan(float&f){string t; scan(t); f=stof(t);}",
		  "        inline void scan(double&f){string t; scan(t); f=stod(t);}",
		  "        inline void scan(long double&f){string t; scan(t); f=stold(t);}",
		  "        template<typename T=int> inline T geti(){",
		  "            char c; scan(c);",
		  "            T res=0; bool f = true;",
		  "            if(c=='-') f = false, c=read();",
		  "            while(c>='0'&& c<='9'){",
		  "                res = (res << 3) + (res << 1); ",
		  "                c -= '0'; res += f ? c : -c;",
		  "                c = read();",
		  "            }",
		  "            return res;",
		  "        }",
		  "        inline string getline(){",
		  "            string s; char c = read();",
		  "            for(;c!='\\n' && !isEnd(c); c = read()) s.push_back(c);",
		  "            if(__GETLINE_FLAG__) __END_FLAG__ = true;",
		  "            if(isEnd(c)) __GETLINE_FLAG__ =  true;",
		  "            return s;",
		  "        }",
		  "        template<typename T1,typename T2> inline void scan(pair<T1,T2>&p){scan(p.first);scan(p.second);}",
		  "        template<typename T> inline void scan(T&n){ n = geti<T>(); }",
		  "        template<typename T> inline void scan(vector<T>&v){for(auto&k:v) scan(k);}",
		  "        template<typename T, typename... Args> inline void scan(T&n, Args&...args){",
		  "            scan(n); scan(args...);",
		  "        }",
		  "        struct _tmp{void sync_with_stdio(int _){}}_t;",
		  "        _tmp* tie(int _){return &_t;}",
		  "} _in;",
		  "class _OUT{",
		  "    private:",
		  "    char buf[SIZ+1],*p=buf, tmp[42];",
		  "    int prec = 6;",
		  "    public:",
		  "        explicit operator bool(){return true;}",
		  "        inline void flush(){fwrite(buf,1,p-buf,stdout); p=buf;}",
		  "        inline void print(const char c){{if(p==buf+SIZ) flush();} *p++=c; }",
		  "        inline void print(const char*s){for(int i=0;s[i];i++) print(s[i]); }",
		  "        inline void print(const string&s){for(char c:s) print(c);}",
		  "        // floating point precision",
		  "        inline void setprecision(int precision){prec=precision;}",
		  "        inline void print(const long double f){",
		  "            std::stringstream stream;",
		  "            stream << std::fixed << std::setprecision(prec) << f;",
		  "            print(stream.str());",
		  "        }",
		  "        inline void print(const double f){print((long double)f);}",
		  "        inline void print(const float f){print((long double)f);}",
		  "        template<typename T> inline void print(const vector<T>&v){for(auto k:v) print(k), print(' ');}",
		  "        template<typename T1,typename T2> inline void print(const pair<T1,T2>&p){print(p.first); print(' '); print(p.second);}",
		  "        // we assume T is integer",
		  "        template<typename T> inline void print(T ans){",
		  "            bool is_minimum = (ans<0) && ((ans<<1) == 0); // check whether this is the minimum of data type",
		  "            if(ans<0){",
		  "                print('-');",
		  "                if(is_minimum) ans = ~ans;",
		  "                else ans *= -1;",
		  "            }",
		  "            int cnt=0;",
		  "            do tmp[cnt++]=(ans%10)+'0', ans/=10; while(ans>0);",
		  "            if(is_minimum) ++tmp[0]; // we assume this is not 9, in-fact, c++ integer type {min}'s last digit is always '8'",
		  "            for(;cnt;) print(tmp[--cnt]);",
		  "        }",
		  "        ~_OUT(){flush();}",
		  "} _out;",
		  "template<typename T> _IN& operator>> (_IN&in, T&i){in.scan(i); return in; }",
		  "template<typename T> _OUT& operator<< (_OUT&out, T i){out.print(i); return out; }",
		  "#define cin _in",
		  "#define cout _out",
		  "",
		  "#else",
		  "template<typename T1,typename T2> istream& operator>> (istream&in, pair<T1,T2>&p){ in>>p.first>>p.second; return in; }",
		  "template<typename T> istream& operator>> (istream&in, vector<T>&v){for(auto&k:v) in>>k; return in; }",
		  "template<typename T1,typename T2> ostream& operator<< (ostream&out, pair<T1,T2>&p){out<<p.first<<' '<<p.second; return out; }",
		  "template<typename T> ostream& operator<< (ostream&out, vector<T> v){for(auto k:v) out<<k<<' '; return out; }",
		  "",
		  "#endif",
		  "// END FASTIO",
		  "",
		],
		"description": "fastio"
	},
    "hijkl2e mcmf": {
		"prefix": "mcmf",
		"body": [
			"// hijkl2e, https://www.acmicpc.net/source/62155473",
			"class mcf_graph {",
			"public:",
			"    using edge = tuple<int, int, int, int>;",
			"    int mxcost = 0;",
			"    mcf_graph(int V) : G(V), d(V), last(V), vst(V) { }",
			"    void add_edge(int u, int v, int cap, int cost, bool directed = true) {",
			"        G[u].push_back(E.size());",
			"        E.push_back({v, cap, 0, cost});",
			"        G[v].push_back(E.size());",
			"        E.push_back({u, 0, 0, -cost});",
			"        if (!directed) add_edge(v, u, cap, cost);",
			"    }",
			"    pair<int, int> flow(int s, int t, int max_cost = inf) {",
			"        mxcost = max_cost;",
			"        int mf{};",
			"        while (spfa(s, t)) {",
			"            fill(last.begin(), last.end(), 0);",
			"            while (int f = dfs(s, t)) {",
			"                mf += f;",
			"            }",
			"        }",
			"        return {mf, tcost};",
			"    }",
			"private:",
			"    bool spfa(int s, int t) {",
			"        fill(d.begin(), d.end(), inf);",
			"        queue<int> q;",
			"        d[s] = 0, vst[s] = true;",
			"        q.push(s);",
			"        while (q.size()) {",
			"            int u = q.front(); q.pop();",
			"            vst[u] = false;",
			"            for (int idx : G[u]) {",
			"                auto &[v, cap, flow, cost] = E[idx];",
			"                if (d[v] > d[u] + cost && flow < cap) {",
			"                    d[v] = d[u] + cost;",
			"                    if (!vst[v]) {",
			"                        vst[v] = true;",
			"                        q.push(v);",
			"                    }",
			"                }",
			"            }",
			"        }",
			"        return d[t] < mxcost;",
			"    }",
			"    int dfs(int u, int t, int f = inf) {",
			"        if (u == t) {",
			"            return f;",
			"        }",
			"        vst[u] = true;",
			"        for (int &i = last[u]; i < G[u].size(); ++i) {",
			"            auto &[v, cap, flow, cost] = E[G[u][i]];",
			"            if (!vst[v] && d[v] == d[u] + cost && flow < cap) {",
			"                if (int pushed = dfs(v, t, min(f, cap - flow))) {",
			"                    tcost += pushed * cost;",
			"                    flow += pushed;",
			"                    auto &rflow = get<2>(E[G[u][i] ^ 1]);",
			"                    rflow -= pushed;",
			"                    vst[u] = false;",
			"                    return pushed;",
			"                }",
			"            }",
			"        }",
			"        vst[u] = false;",
			"        return 0;",
			"    }",
			"    vector<edge> E;",
			"    vector<vector<int>> G;",
			"    vector<int> d;",
			"    vector<int> last;",
			"    vector<bool> vst;",
			"    int tcost{};",
			"};"
		],
		"description": "hijkl2e mcmf"
	},
	"modint": {
		"prefix": "modint",
		"body": [
		  "/*",
		  "Modint Implementation and Combination",
		  "Reference: https://codeforces.com/blog/entry/127439 Problem E",
		  "*/",
		  "template<class T>",
		  "constexpr T power(T a, ll b) {",
		  "    T res = 1;",
		  "    for (; b; b /= 2, a *= a) {",
		  "        if (b % 2) {",
		  "            res *= a;",
		  "        }",
		  "    }",
		  "    return res;",
		  "}",
		  " ",
		  "template<int P>",
		  "struct modint {",
		  "    int x;",
		  "    constexpr modint() : x{} {}",
		  "    constexpr modint(ll x) : x{norm(x % P)} {}",
		  "    ",
		  "    constexpr int norm(int x) const {",
		  "        if (x < 0) x += P;",
		  "        if (x >= P) x -= P;",
		  "        return x;",
		  "    }",
		  "    constexpr int val() const {return x;}",
		  "    explicit constexpr operator int() const {return x;}",
		  "    constexpr modint operator-() const {",
		  "        modint res;",
		  "        res.x = norm(P - x);",
		  "        return res;",
		  "    }",
		  "    constexpr modint inv() const {",
		  "        assert(x != 0);",
		  "        return power(*this, P - 2);",
		  "    }",
		  "    constexpr modint &operator*=(modint rhs) {",
		  "        x = 1LL * x * rhs.x % P;",
		  "        return *this;",
		  "    }",
		  "    constexpr modint &operator+=(modint rhs) {",
		  "        x = norm(x + rhs.x);",
		  "        return *this;",
		  "    }",
		  "    constexpr modint &operator-=(modint rhs) {",
		  "        x = norm(x - rhs.x);",
		  "        return *this;",
		  "    }",
		  "    constexpr modint &operator/=(modint rhs) {",
		  "        return *this *= rhs.inv();",
		  "    }",
		  "    friend constexpr modint operator*(modint lhs, modint rhs) {",
		  "        modint res = lhs;",
		  "        res *= rhs;",
		  "        return res;",
		  "    }",
		  "    friend constexpr modint operator+(modint lhs, modint rhs) {",
		  "        modint res = lhs;",
		  "        res += rhs;",
		  "        return res;",
		  "    }",
		  "    friend constexpr modint operator-(modint lhs, modint rhs) {",
		  "        modint res = lhs;",
		  "        res -= rhs;",
		  "        return res;",
		  "    }",
		  "    friend constexpr modint operator/(modint lhs, modint rhs) {",
		  "        modint res = lhs;",
		  "        res /= rhs;",
		  "        return res;",
		  "    }",
		  "    friend constexpr std::istream &operator>>(std::istream &is, modint &a) {",
		  "        ll v;",
		  "        is >> v;",
		  "        a = modint(v);",
		  "        return is;",
		  "    }",
		  "    friend constexpr std::ostream &operator<<(std::ostream &os, const modint &a) {",
		  "        return os << a.val();",
		  "    }",
		  "    friend constexpr bool operator==(modint lhs, modint rhs) {",
		  "        return lhs.val() == rhs.val();",
		  "    }",
		  "    friend constexpr bool operator!=(modint lhs, modint rhs) {",
		  "        return lhs.val() != rhs.val();",
		  "    }",
		  "};",
		  " ",
		  "template<int P>",
		  "struct comb {",
		  "    using Z = modint<P>;",
		  "    int n = 0;",
		  "    std::vector<Z> _fac = {1};",
		  "    std::vector<Z> _invfac = {1};",
		  "    std::vector<Z> _inv = {0};",
		  "    void init(int m) {",
		  "        if (m <= n) return;",
		  "        _fac.resize(m + 1);",
		  "        _invfac.resize(m + 1);",
		  "        _inv.resize(m + 1);",
		  "        ",
		  "        for (int i = n + 1; i <= m; i++) {",
		  "            _fac[i] = _fac[i - 1] * i;",
		  "        }",
		  "        _invfac[m] = _fac[m].inv();",
		  "        for (int i = m; i > n; i--) {",
		  "            _invfac[i - 1] = _invfac[i] * i;",
		  "            _inv[i] = _invfac[i] * _fac[i - 1];",
		  "        }",
		  "        n = m;",
		  "    }",
		  "    int fac(int m) {",
		  "        if (m > n) init(2 * m);",
		  "        return _fac[m].val();",
		  "    }",
		  "    int invfac(int m) {",
		  "        if (m > n) init(2 * m);",
		  "        return _invfac[m].val();",
		  "    }",
		  "    int inv(int m) {",
		  "        if (m > n) init(2 * m);",
		  "        return _inv[m].val();",
		  "    }",
		  "    int binom(int m, int k) {",
		  "        if (m < 0 || m < k || k < 0) return 0;",
		  "        return (Z(fac(m)) * invfac(k) * invfac(m - k)).val();",
		  "    }",
		  "    using ull = long long;",
		  "    std::vector<vector<ull>> bm = {{1}}; // we don't care overflow",
		  "    void init_ull(int m){",
		  "        int n = bm.size() - 1;",
		  "        if(m <= n) return;",
		  "        bm.resize(m+1);",
		  "        for(int i = n + 1; i <= m; i++){",
		  "            bm[i].resize(i+1);",
		  "            bm[i][0] = bm[i][i] = 1;",
		  "            for(int j = 1; j < i; j++)",
		  "                bm[i][j] = bm[i-1][j] + bm[i-1][j-1];",
		  "        }",
		  "    }",
		  "    ull binom_ull(int m,int k){",
		  "        if (m < 0 || m < k || k < 0) return 0;",
		  "        init_ull(m);",
		  "        return bm[m][k];",
		  "    }",
		  "};"
		],
		"description": "modint"
	},
}
