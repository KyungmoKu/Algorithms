{
	"simple c++": {
		"prefix": "solve",
		"body": [
		  "#pragma GCC optimize(\"Ofast,unroll-loops\")",
		  "#include\"bits/stdc++.h\"",
		  "using namespace std;",
		  "#define nl '\\n'",
		  "#define sp ' '",
		  "#define all(v) (v).begin(),(v).end()",
		  "#define INIT(v, x) memset(v, x, sizeof v)",
		  "int _dbg, cur_tc;",
		  "#define dbg(i) if(!_dbg||_dbg==cur_tc) cerr << \"Line(\" << __LINE__ << \") -> \" << #i << \" = \" << (i) << endl;",
		  "#define dbgs(...) if(!_dbg||_dbg==cur_tc)fprintf(stderr, __VA_ARGS__)",
		  "template<typename T> istream& operator>> (istream&in, vector<T>&v){for(auto&x:v)in>>x; return in;}",
		  "using ll = int64_t;",
		  "#define int ll",
		  "",
		  "int32_t main(){",
		  "    cin.tie(0)->sync_with_stdio(0); cin.exceptions(ios::badbit | ios::failbit);",
		  "    // cout<<fixed<<setprecision(15);",
		  "    int tc = 1;",
		  "    // cin >> tc;",
		  "    auto solve_tc = [&](){",
		  "        $0",
		  "    };",
		  "    for(cur_tc=1;cur_tc<=tc;cur_tc++) solve_tc();",
		  "    return 0;",
		  "}"
		],
		"description": "simple c++"
	  },
	"solve": {
		"prefix": "solve_old",
		"scope": "cpp",
		"body": [
		  "#define LLHACK",
		  "/*Solution",
		  "Problem: ${TM_FILENAME_BASE}",
		  "1. 문제부터 정확히 읽는다.",
		  "2. 수단과 방법을 가리지 말고 문제를 먼저 맞춘다",
		  "3. 잘 안되면 세수라도 하고 오거나 stress test를 짠다.",
		  "화이팅",
		  "*/",
		  "#pragma GCC optimize(\"Ofast,unroll-loops\")",
		  "#include\"bits/stdc++.h\"",
		  "using namespace std;",
		  "int cur_tc;",
		  "#define nl '\\n'",
		  "#define sp ' '",
		  "#define dbg(i) cerr<<#i<<sp<<i<<endl",
		  "#define dbgs(...) fprintf(stderr, __VA_ARGS__)",
		  "#define all(v) (v).begin(),(v).end()",
		  "#define init(v, x) memset(v, x, sizeof v)",
		  "using ld = long double;",
		  "using ll = long long;",
		  "#ifdef LLHACK",
		  "#define int ll",
		  "#endif",
		  "using pii = pair<int,int>;",
		  "// __builtin_ctzll(x), __builtin_clzll(x), __builtin_popcountll(x)",
		  "int lsb(int x){return x>0?__builtin_ctz(x):-1;}",
		  "int msb(int x){return x>0?31-__builtin_clz(x):-1;}",
		  "int popcnt(int x){return __builtin_popcount(x);}",
		  "std::mt19937_64 gen(time(NULL));",
		  "ll randint(ll l, ll r) { std::uniform_int_distribution<ll> dist(l, r); return dist(gen);}",
		  "template<class T1,class T2>bool updmax(T1&l,T2 r){return (l<r?(l=r),true: false);}",
		  "template<class T1,class T2>bool updmin(T1&l,T2 r){return (l>r?(l=r),true: false);}",
		  "const int inf = (int)1e9 + 7;",
		  "const ll linf = (ll)4e18 + 7;",
		  "",
		  "/*요약: 문제의 본질을 본다",
		  "$0",
		  "*/",
		  "const int N = 7 + 1e5, mod = (int)1e9 + 7;",
		  "",
		  "void _main(){",
		  "    ",
		  "}",
		  "",
		  "signed main(){",
		  "    cin.tie(0)->sync_with_stdio(0);",
		  "    cin.exceptions(ios::badbit | ios::failbit);",
		  "    // cout<<fixed<<setprecision(15);",
		  "    int tc = 1;",
		  "    // cin >> tc;",
		  "    for(cur_tc=1;cur_tc<=tc;++cur_tc) _main();",
		  "    return 0;",
		  "}",
		  "// https://github.com/Pentagon03/Algorithms",
		],
		"description": "solve"
	},
	"C++ vectorization (ofast)": {
	  "prefix": "ofast",
	  "scope": "cpp",
	  "body": [
		"#pragma GCC optimize(3)",
		"#pragma GCC optimize(\"Ofast,unroll-loops\")",
		"#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4.1,sse4.2,avx,avx2,popcnt\")"
	  ],
	  "description": "C++ vectorization"
	},
	"stack pregma hack": {
	  "prefix": "stackpragma",
	  "scope": "cpp",
	  "body": [
		"#pragma comment(linker, \"/stack:102400000,102400000\")"
	  ],
	  "description": "C++ vectorization"
	},
	"stack hack": {
	  "prefix": "stackhack",
	  "scope":"cpp",
	  "body": [
		"#include <bits/stdc++.h>",
		"using namespace std;",
		"void main_() {",
		"    // implement your solution here",
		"}",
		"static void run_with_stack_size(void (*func)(void), size_t stsize) {",
		"    char *stack, *send;",
		"    stack = (char *)malloc(stsize);",
		"    send = stack + stsize - 16;",
		"    send = (char *)((uintptr_t)send / 16 * 16);",
		"    asm volatile(",
		"        \"mov %%rsp, (%0)\\n\"",
		"        \"mov %0, %%rsp\\n\"",
		"        :",
		"        : \"r\"(send));",
		"    func();",
		"    asm volatile(\"mov (%0), %%rsp\\n\" : : \"r\"(send));",
		"    free(stack);",
		"}",
		"int main() {",
		"    run_with_stack_size(main_, 1024 * 1024 * 1024); // run with a 1 GiB stack",
		"    return 0;",
		"}"
	  ],
	  "description": "stack hack"
	},
	"Python solve": {
	  "prefix": "solve",
	  "scope": "python",
	  "body": [
		"from sys import stdin, stdout, exit",
		"RS = lambda:stdin.readline().rstrip()",
		"RI = lambda:int(RS())",
		"RL = lambda:list(map(int,RS().split()))",
		"RLL = lambda n: [RI() for _ in range(n)]",
		"PI = lambda x:stdout.write(str(x)+'\\n')",
		"INF = 10**9",
		"EPS = 1e-9",
		"MOD = 10**9 + 7",
		"",
		"'''Solution",
		"https://acmicpc.net/problem/${TM_FILENAME_BASE}",
		"${0}",
		"'''",
		"",
		"def solve():",
		"    ",
		"    return",
		"",
		"def main():",
		"    TC = 1 ",
		"    # TC = RI()",
		"    for _ in range(TC):",
		"        solve()",
		"",
		"if __name__ == \"__main__\":",
		"    main()"
	  ],
	  "description": "Python solve"
	},
	"grader": {
	  "prefix": "grader",
	  "scope": "python",
	  "body": [
		"import os",
		"i = 1",
		"while True:",
		"    print(i)",
		"    file_name = \"\"",
		"    if os.system(f'.\\\\{file_name}_gen {i} > {file_name}_in'): break",
		"    if os.system(f'.\\\\{file_name} < {file_name}_in > {file_name}_my'): break",
		"    if os.system(f'.\\\\{file_name}_ok < {file_name}_in > {file_name}_you'): break",
		"    if open(f'{file_name}_my').read() != open(f'{file_name}_you').read():",
		"        break",
		"    i += 1"
	  ],
	  "description": "grader"
	},
	"debug": {
	"prefix": "debug",
	"body": [
		"#include <iostream>",
		"#include <vector>",
		"#include <deque>",
		"#include <map>",
		"#include <unordered_map>",
		"#include <set>",
		"#include <unordered_set>",
		"",
		"template <typename T>",
		"std::ostream& operator<<(std::ostream& out, const std::vector<T>& vec) {",
		"    if (vec.empty()) {",
		"        out << \"[]\";",
		"        return out;",
		"    }",
		"    out << '[';",
		"    for (int i = 0; i < vec.size() - 1; i++) {",
		"        out << vec[i] << \", \";",
		"    }",
		"    return out << vec.back() << ']';",
		"}",
		"",
		"template <typename T1, typename T2>",
		"std::ostream& operator<<(std::ostream& out, const std::pair<T1, T2>& pair) {",
		"    return out << '(' << pair.first << \", \" << pair.second << ')';",
		"}",
		"",
		"template <typename T>",
		"std::ostream& operator<<(std::ostream& out, const std::deque<T>& deq) {",
		"    if (deq.empty()) {",
		"        out << \"[]\";",
		"        return out;",
		"    }",
		"    out << '[';",
		"    for (int i = 0; i < deq.size() - 1; i++) {",
		"        out << deq[i] << \", \";",
		"    }",
		"    return out << deq.back() << ']';",
		"}",
		"",
		"template <typename T1, typename T2>",
		"std::ostream& operator<<(std::ostream& out, const std::unordered_map<T1, T2>& map) {",
		"    out << '{';",
		"    for (auto it = map.begin(); it != map.end(); it++) {",
		"        std::pair<T1, T2> element = *it;",
		"        out << element.first << \": \" << element.second;",
		"        if (std::next(it) != map.end()) {",
		"            out << \", \";   ",
		"        }",
		"    }",
		"    return out << '}';",
		"}",
		"",
		"template <typename T1, typename T2>",
		"std::ostream& operator<<(std::ostream& out, const std::map<T1, T2>& map) {",
		"    out << '{';",
		"    for (auto it = map.begin(); it != map.end(); it++) {",
		"        std::pair<T1, T2> element = *it;",
		"        out << element.first << \": \" << element.second;",
		"        if (std::next(it) != map.end()) {",
		"            out << \", \";   ",
		"        }",
		"    }",
		"    return out << '}';",
		"}",
		"",
		"template <typename T>",
		"std::ostream& operator<<(std::ostream& out, const std::unordered_set<T>& set) {",
		"    out << '{';",
		"    for (auto it = set.begin(); it != set.end(); it++) {",
		"        T element = *it;",
		"        out << element;",
		"        if (std::next(it) != set.end()) {",
		"            out << \", \";   ",
		"        }",
		"    }",
		"    return out << '}';",
		"}",
		"",
		"template <typename T>",
		"std::ostream& operator<<(std::ostream& out, const std::multiset<T>& set) {",
		"    out << '{';",
		"    for (auto it = set.begin(); it != set.end(); it++) {",
		"        T element = *it;",
		"        out << element;",
		"        if (std::next(it) != set.end()) {",
		"            out << \", \";   ",
		"        }",
		"    }",
		"    return out << '}';",
		"}",
		"",
		"template <typename T>",
		"std::ostream& operator<<(std::ostream& out, const std::unordered_multiset<T>& set) {",
		"    out << '{';",
		"    for (auto it = set.begin(); it != set.end(); it++) {",
		"        T element = *it;",
		"        out << element;",
		"        if (std::next(it) != set.end()) {",
		"            out << \", \";   ",
		"        }",
		"    }",
		"    return out << '}';",
		"}",
		"",
		"template <typename T>",
		"std::ostream& operator<<(std::ostream& out, const std::set<T>& set) {",
		"    out << '{';",
		"    for (auto it = set.begin(); it != set.end(); it++) {",
		"        T element = *it;",
		"        out << element;",
		"        if (std::next(it) != set.end()) {",
		"            out << \", \";   ",
		"        }",
		"    }",
		"    return out << '}';",
		"}",
		"",
		"// Source: https://stackoverflow.com/a/31116392/12128483",
		"template<typename Type, unsigned N, unsigned Last>",
		"struct TuplePrinter {",
		"    static void print(std::ostream& out, const Type& value) {",
		"        out << std::get<N>(value) << \", \";",
		"        TuplePrinter<Type, N + 1, Last>::print(out, value);",
		"    }",
		"};",
		"",
		"template<typename Type, unsigned N>",
		"struct TuplePrinter<Type, N, N> {",
		"    static void print(std::ostream& out, const Type& value) {",
		"        out << std::get<N>(value);",
		"    }",
		"};",
		"",
		"template<typename... Types>",
		"std::ostream& operator<<(std::ostream& out, const std::tuple<Types...>& value) {",
		"    out << '(';",
		"    TuplePrinter<std::tuple<Types...>, 0, sizeof...(Types) - 1>::print(out, value);",
		"    return out << ')';",
		"}"
	],
	"description": "debug"
	},
}