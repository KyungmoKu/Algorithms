{
  "BigInt.cpp": {
    "prefix": "BigInt",
    "scope": "cpp",
    "body": [
      "// [Option 1] (Faster)",
      "// test: http://boj.kr/12401ac7a9414dc8b96b8c2ebbf6eb49",
      "// watch here: https://github.com/ngthanhtrung23/ACM_Notebook_new/blob/master/Math/bigint.h",
      "",
      "// [Option 2]",
      "// test: http://boj.kr/43fa901846c44b828b13e8b4fa452579",
      "// watch here: https://github.com/sercantutar/infint/blob/master/InfInt.h",
      "",
      "// NOTE:",
      "// - Base 10^k. If need base 2^k, see submissions in:",
      "//   https://www.spoj.com/problems/PBBN2/     (>= 0 only, operations: *, power, xor)",
      "//   https://www.spoj.com/problems/PELLFOUR/  (see CPP, older submissions)",
      "//   https://codeforces.com/contest/504/submission/42348976  (with negative, several operations)",
      "//",
      "// Tested:",
      "// - https://www.e-olymp.com/en/problems/266: Comparison",
      "// - https://www.e-olymp.com/en/problems/267: Subtraction",
      "// - https://www.e-olymp.com/en/problems/271: Multiplication",
      "// - https://www.e-olymp.com/en/problems/272: Multiplication",
      "// - https://www.e-olymp.com/en/problems/313: Addition",
      "// - https://www.e-olymp.com/en/problems/314: Addition/Subtraction",
      "// - https://www.e-olymp.com/en/problems/317: Multiplication (simple / karatsuba / fft)",
      "// - https://www.e-olymp.com/en/problems/1327: Multiplication",
      "// - https://www.e-olymp.com/en/problems/1328",
      "// - VOJ BIGNUM: Addition, Subtraction, Multiplication.",
      "// - SGU 111: sqrt",
      "// - SGU 193",
      "// - SPOJ MUL, VFMUL: Multiplication.",
      "// - SPOJ FDIV, VFDIV: Division.",
      "// - SPOJ SQRROOT: sqrt",
      "",
      "// BigInt {{{",
      "const int BASE_DIGITS = 9;",
      "const int BASE = 1000000000;",
      "",
      "struct BigInt {",
      "    int sign;",
      "    vector<int> a;",
      "",
      "    // -------------------- Constructors --------------------",
      "    // Default constructor.",
      "    BigInt() : sign(1) {}",
      "",
      "    // Constructor from long long.",
      "    BigInt(long long v) {",
      "        *this = v;",
      "    }",
      "    BigInt& operator = (long long v) {",
      "        sign = 1;",
      "        if (v < 0) {",
      "            sign = -1;",
      "            v = -v;",
      "        }",
      "        a.clear();",
      "        for (; v > 0; v = v / BASE)",
      "            a.push_back(v % BASE);",
      "        return *this;",
      "    }",
      "",
      "    // Initialize from string.",
      "    BigInt(const string& s) {",
      "        read(s);",
      "    }",
      "",
      "    // -------------------- Input / Output --------------------",
      "    void read(const string& s) {",
      "        sign = 1;",
      "        a.clear();",
      "        int pos = 0;",
      "        while (pos < (int) s.size() && (s[pos] == '-' || s[pos] == '+')) {",
      "            if (s[pos] == '-')",
      "                sign = -sign;",
      "            ++pos;",
      "        }",
      "        for (int i = s.size() - 1; i >= pos; i -= BASE_DIGITS) {",
      "            int x = 0;",
      "            for (int j = max(pos, i - BASE_DIGITS + 1); j <= i; j++)",
      "                x = x * 10 + s[j] - '0';",
      "            a.push_back(x);",
      "        }",
      "        trim();",
      "    }",
      "    friend istream& operator>>(istream &stream, BigInt &v) {",
      "        string s;",
      "        stream >> s;",
      "        v.read(s);",
      "        return stream;",
      "    }",
      "",
      "    friend ostream& operator<<(ostream &stream, const BigInt &v) {",
      "        if (v.sign == -1 && !v.isZero())",
      "            stream << '-';",
      "        stream << (v.a.empty() ? 0 : v.a.back());",
      "        for (int i = (int) v.a.size() - 2; i >= 0; --i)",
      "            stream << setw(BASE_DIGITS) << setfill('0') << v.a[i];",
      "        return stream;",
      "    }",
      "",
      "    // -------------------- Comparison --------------------",
      "    bool operator<(const BigInt &v) const {",
      "        if (sign != v.sign)",
      "            return sign < v.sign;",
      "        if (a.size() != v.a.size())",
      "            return a.size() * sign < v.a.size() * v.sign;",
      "        for (int i = ((int) a.size()) - 1; i >= 0; i--)",
      "            if (a[i] != v.a[i])",
      "                return a[i] * sign < v.a[i] * sign;",
      "        return false;",
      "    }",
      "",
      "    bool operator>(const BigInt &v) const {",
      "        return v < *this;",
      "    }",
      "    bool operator<=(const BigInt &v) const {",
      "        return !(v < *this);",
      "    }",
      "    bool operator>=(const BigInt &v) const {",
      "        return !(*this < v);",
      "    }",
      "    bool operator==(const BigInt &v) const {",
      "        return !(*this < v) && !(v < *this);",
      "    }",
      "    bool operator!=(const BigInt &v) const {",
      "        return *this < v || v < *this;",
      "    }",
      "",
      "    // Returns:",
      "    // 0 if |x| == |y|",
      "    // -1 if |x| < |y|",
      "    // 1 if |x| > |y|",
      "    friend int __compare_abs(const BigInt& x, const BigInt& y) {",
      "        if (x.a.size() != y.a.size()) {",
      "            return x.a.size() < y.a.size() ? -1 : 1;",
      "        }",
      "",
      "        for (int i = ((int) x.a.size()) - 1; i >= 0; --i) {",
      "            if (x.a[i] != y.a[i]) {",
      "                return x.a[i] < y.a[i] ? -1 : 1;",
      "            }",
      "        }",
      "        return 0;",
      "    }",
      "",
      "    // -------------------- Unary operator - and operators +- --------------------",
      "    BigInt operator-() const {",
      "        BigInt res = *this;",
      "        if (isZero()) return res;",
      "",
      "        res.sign = -sign;",
      "        return res;",
      "    }",
      "",
      "    // Note: sign ignored.",
      "    void __internal_add(const BigInt& v) {",
      "        if (a.size() < v.a.size()) {",
      "            a.resize(v.a.size(), 0);",
      "        }",
      "        for (int i = 0, carry = 0; i < (int) max(a.size(), v.a.size()) || carry; ++i) {",
      "            if (i == (int) a.size()) a.push_back(0);",
      "",
      "            a[i] += carry + (i < (int) v.a.size() ? v.a[i] : 0);",
      "            carry = a[i] >= BASE;",
      "            if (carry) a[i] -= BASE;",
      "        }",
      "    }",
      "",
      "    // Note: sign ignored.",
      "    void __internal_sub(const BigInt& v) {",
      "        for (int i = 0, carry = 0; i < (int) v.a.size() || carry; ++i) {",
      "            a[i] -= carry + (i < (int) v.a.size() ? v.a[i] : 0);",
      "            carry = a[i] < 0;",
      "            if (carry) a[i] += BASE;",
      "        }",
      "        this->trim();",
      "    }",
      "",
      "    BigInt operator += (const BigInt& v) {",
      "        if (sign == v.sign) {",
      "            __internal_add(v);",
      "        } else {",
      "            if (__compare_abs(*this, v) >= 0) {",
      "                __internal_sub(v);",
      "            } else {",
      "                BigInt vv = v;",
      "                swap(*this, vv);",
      "                __internal_sub(vv);",
      "            }",
      "        }",
      "        return *this;",
      "    }",
      "",
      "    BigInt operator -= (const BigInt& v) {",
      "        if (sign == v.sign) {",
      "            if (__compare_abs(*this, v) >= 0) {",
      "                __internal_sub(v);",
      "            } else {",
      "                BigInt vv = v;",
      "                swap(*this, vv);",
      "                __internal_sub(vv);",
      "                this->sign = -this->sign;",
      "            }",
      "        } else {",
      "            __internal_add(v);",
      "        }",
      "        return *this;",
      "    }",
      "",
      "    // Optimize operators + and - according to",
      "    // https://stackoverflow.com/questions/13166079/move-semantics-and-pass-by-rvalue-reference-in-overloaded-arithmetic",
      "    template< typename L, typename R >",
      "        typename std::enable_if<",
      "            std::is_convertible<L, BigInt>::value &&",
      "            std::is_convertible<R, BigInt>::value &&",
      "            std::is_lvalue_reference<R&&>::value,",
      "            BigInt>::type friend operator + (L&& l, R&& r) {",
      "        BigInt result(std::forward<L>(l));",
      "        result += r;",
      "        return result;",
      "    }",
      "    template< typename L, typename R >",
      "        typename std::enable_if<",
      "            std::is_convertible<L, BigInt>::value &&",
      "            std::is_convertible<R, BigInt>::value &&",
      "            std::is_rvalue_reference<R&&>::value,",
      "            BigInt>::type friend operator + (L&& l, R&& r) {",
      "        BigInt result(std::move(r));",
      "        result += l;",
      "        return result;",
      "    }",
      "",
      "    template< typename L, typename R >",
      "        typename std::enable_if<",
      "            std::is_convertible<L, BigInt>::value &&",
      "            std::is_convertible<R, BigInt>::value,",
      "            BigInt>::type friend operator - (L&& l, R&& r) {",
      "        BigInt result(std::forward<L>(l));",
      "        result -= r;",
      "        return result;",
      "    }",
      "",
      "    // -------------------- Operators * / % --------------------",
      "    friend pair<BigInt, BigInt> divmod(const BigInt& a1, const BigInt& b1) {",
      "        assert(b1 > 0);  // divmod not well-defined for b < 0.",
      "",
      "        long long norm = BASE / (b1.a.back() + 1);",
      "        BigInt a = a1.abs() * norm;",
      "        BigInt b = b1.abs() * norm;",
      "        BigInt q = 0, r = 0;",
      "        q.a.resize(a.a.size());",
      "",
      "        for (int i = a.a.size() - 1; i >= 0; i--) {",
      "            r *= BASE;",
      "            r += a.a[i];",
      "            long long s1 = r.a.size() <= b.a.size() ? 0 : r.a[b.a.size()];",
      "            long long s2 = r.a.size() <= b.a.size() - 1 ? 0 : r.a[b.a.size() - 1];",
      "            long long d = ((long long) BASE * s1 + s2) / b.a.back();",
      "            r -= b * d;",
      "            while (r < 0) {",
      "                r += b, --d;",
      "            }",
      "            q.a[i] = d;",
      "        }",
      "",
      "        q.sign = a1.sign * b1.sign;",
      "        r.sign = a1.sign;",
      "        q.trim();",
      "        r.trim();",
      "        auto res = make_pair(q, r / norm);",
      "        if (res.second < 0) res.second += b1;",
      "        return res;",
      "    }",
      "    BigInt operator/(const BigInt &v) const {",
      "        if (v < 0) return divmod(-*this, -v).first;",
      "        return divmod(*this, v).first;",
      "    }",
      "",
      "    BigInt operator%(const BigInt &v) const {",
      "        return divmod(*this, v).second;",
      "    }",
      "",
      "    void operator/=(int v) {",
      "        assert(v > 0);  // operator / not well-defined for v <= 0.",
      "        if (llabs(v) >= BASE) {",
      "            *this /= BigInt(v);",
      "            return ;",
      "        }",
      "        if (v < 0)",
      "            sign = -sign, v = -v;",
      "        for (int i = (int) a.size() - 1, rem = 0; i >= 0; --i) {",
      "            long long cur = a[i] + rem * (long long) BASE;",
      "            a[i] = (int) (cur / v);",
      "            rem = (int) (cur % v);",
      "        }",
      "        trim();",
      "    }",
      "",
      "    BigInt operator/(int v) const {",
      "        assert(v > 0);  // operator / not well-defined for v <= 0.",
      "",
      "        if (llabs(v) >= BASE) {",
      "            return *this / BigInt(v);",
      "        }",
      "        BigInt res = *this;",
      "        res /= v;",
      "        return res;",
      "    }",
      "    void operator/=(const BigInt &v) {",
      "        *this = *this / v;",
      "    }",
      "",
      "    long long operator%(long long v) const {",
      "        assert(v > 0);  // operator / not well-defined for v <= 0.",
      "        assert(v < BASE);",
      "        int m = 0;",
      "        for (int i = a.size() - 1; i >= 0; --i)",
      "            m = (a[i] + m * (long long) BASE) % v;",
      "        return m * sign;",
      "    }",
      "",
      "    void operator*=(int v) {",
      "        if (llabs(v) >= BASE) {",
      "            *this *= BigInt(v);",
      "            return ;",
      "        }",
      "        if (v < 0)",
      "            sign = -sign, v = -v;",
      "        for (int i = 0, carry = 0; i < (int) a.size() || carry; ++i) {",
      "            if (i == (int) a.size())",
      "                a.push_back(0);",
      "            long long cur = a[i] * (long long) v + carry;",
      "            carry = (int) (cur / BASE);",
      "            a[i] = (int) (cur % BASE);",
      "            //asm(\"divl %%ecx\" : \"=a\"(carry), \"=d\"(a[i]) : \"A\"(cur), \"c\"(base));",
      "            /*",
      "             int val;",
      "             __asm {",
      "             lea esi, cur",
      "             mov eax, [esi]",
      "             mov edx, [esi+4]",
      "             mov ecx, base",
      "             div ecx",
      "             mov carry, eax",
      "             mov val, edx;",
      "             }",
      "             a[i] = val;",
      "             */",
      "        }",
      "        trim();",
      "    }",
      "",
      "    BigInt operator*(int v) const {",
      "        if (llabs(v) >= BASE) {",
      "            return *this * BigInt(v);",
      "        }",
      "        BigInt res = *this;",
      "        res *= v;",
      "        return res;",
      "    }",
      "",
      "    // Convert BASE 10^old --> 10^new.",
      "    static vector<int> convert_base(const vector<int> &a, int old_digits, int new_digits) {",
      "        vector<long long> p(max(old_digits, new_digits) + 1);",
      "        p[0] = 1;",
      "        for (int i = 1; i < (int) p.size(); i++)",
      "            p[i] = p[i - 1] * 10;",
      "        vector<int> res;",
      "        long long cur = 0;",
      "        int cur_digits = 0;",
      "        for (int i = 0; i < (int) a.size(); i++) {",
      "            cur += a[i] * p[cur_digits];",
      "            cur_digits += old_digits;",
      "            while (cur_digits >= new_digits) {",
      "                res.push_back((long long)(cur % p[new_digits]));",
      "                cur /= p[new_digits];",
      "                cur_digits -= new_digits;",
      "            }",
      "        }",
      "        res.push_back((int) cur);",
      "        while (!res.empty() && !res.back())",
      "            res.pop_back();",
      "        return res;",
      "    }",
      "",
      "    void fft(vector<complex<double> > &x, bool invert) const {",
      "        int n = (int) x.size();",
      "",
      "        for (int i = 1, j = 0; i < n; ++i) {",
      "            int bit = n >> 1;",
      "            for (; j >= bit; bit >>= 1)",
      "                j -= bit;",
      "            j += bit;",
      "            if (i < j)",
      "                swap(x[i], x[j]);",
      "        }",
      "",
      "        for (int len = 2; len <= n; len <<= 1) {",
      "            double ang = 2 * 3.14159265358979323846 / len * (invert ? -1 : 1);",
      "            complex<double> wlen(cos(ang), sin(ang));",
      "            for (int i = 0; i < n; i += len) {",
      "                complex<double> w(1);",
      "                for (int j = 0; j < len / 2; ++j) {",
      "                    complex<double> u = x[i + j];",
      "                    complex<double> v = x[i + j + len / 2] * w;",
      "                    x[i + j] = u + v;",
      "                    x[i + j + len / 2] = u - v;",
      "                    w *= wlen;",
      "                }",
      "            }",
      "        }",
      "        if (invert)",
      "            for (int i = 0; i < n; ++i)",
      "                x[i] /= n;",
      "    }",
      "",
      "    void multiply_fft(const vector<int> &x, const vector<int> &y, vector<int> &res) const {",
      "        vector<complex<double> > fa(x.begin(), x.end());",
      "        vector<complex<double> > fb(y.begin(), y.end());",
      "        int n = 1;",
      "        while (n < (int) max(x.size(), y.size()))",
      "            n <<= 1;",
      "        n <<= 1;",
      "        fa.resize(n);",
      "        fb.resize(n);",
      "",
      "        fft(fa, false);",
      "        fft(fb, false);",
      "        for (int i = 0; i < n; ++i)",
      "            fa[i] *= fb[i];",
      "        fft(fa, true);",
      "",
      "        res.resize(n);",
      "        long long carry = 0;",
      "        for (int i = 0; i < n; ++i) {",
      "            long long t = (long long) (fa[i].real() + 0.5) + carry;",
      "            carry = t / 1000;",
      "            res[i] = t % 1000;",
      "        }",
      "    }",
      "",
      "    BigInt mul_simple(const BigInt &v) const {",
      "        BigInt res;",
      "        res.sign = sign * v.sign;",
      "        res.a.resize(a.size() + v.a.size());",
      "        for (int i = 0; i < (int) a.size(); ++i)",
      "            if (a[i])",
      "                for (int j = 0, carry = 0; j < (int) v.a.size() || carry; ++j) {",
      "                    long long cur = res.a[i + j] + (long long) a[i] * (j < (int) v.a.size() ? v.a[j] : 0) + carry;",
      "                    carry = (int) (cur / BASE);",
      "                    res.a[i + j] = (int) (cur % BASE);",
      "                }",
      "        res.trim();",
      "        return res;",
      "    }",
      "",
      "    typedef vector<long long> vll;",
      "",
      "    static vll karatsubaMultiply(const vll &a, const vll &b) {",
      "        int n = a.size();",
      "        vll res(n + n);",
      "        if (n <= 32) {",
      "            for (int i = 0; i < n; i++)",
      "                for (int j = 0; j < n; j++)",
      "                    res[i + j] += a[i] * b[j];",
      "            return res;",
      "        }",
      "",
      "        int k = n >> 1;",
      "        vll a1(a.begin(), a.begin() + k);",
      "        vll a2(a.begin() + k, a.end());",
      "        vll b1(b.begin(), b.begin() + k);",
      "        vll b2(b.begin() + k, b.end());",
      "",
      "        vll a1b1 = karatsubaMultiply(a1, b1);",
      "        vll a2b2 = karatsubaMultiply(a2, b2);",
      "",
      "        for (int i = 0; i < k; i++)",
      "            a2[i] += a1[i];",
      "        for (int i = 0; i < k; i++)",
      "            b2[i] += b1[i];",
      "",
      "        vll r = karatsubaMultiply(a2, b2);",
      "        for (int i = 0; i < (int) a1b1.size(); i++)",
      "            r[i] -= a1b1[i];",
      "        for (int i = 0; i < (int) a2b2.size(); i++)",
      "            r[i] -= a2b2[i];",
      "",
      "        for (int i = 0; i < (int) r.size(); i++)",
      "            res[i + k] += r[i];",
      "        for (int i = 0; i < (int) a1b1.size(); i++)",
      "            res[i] += a1b1[i];",
      "        for (int i = 0; i < (int) a2b2.size(); i++)",
      "            res[i + n] += a2b2[i];",
      "        return res;",
      "    }",
      "",
      "    BigInt mul_karatsuba(const BigInt &v) const {",
      "        vector<int> x6 = convert_base(this->a, BASE_DIGITS, 6);",
      "        vector<int> y6 = convert_base(v.a, BASE_DIGITS, 6);",
      "        vll x(x6.begin(), x6.end());",
      "        vll y(y6.begin(), y6.end());",
      "        while (x.size() < y.size())",
      "            x.push_back(0);",
      "        while (y.size() < x.size())",
      "            y.push_back(0);",
      "        while (x.size() & (x.size() - 1))",
      "            x.push_back(0), y.push_back(0);",
      "        vll c = karatsubaMultiply(x, y);",
      "        BigInt res;",
      "        res.sign = sign * v.sign;",
      "        long long carry = 0;",
      "        for (int i = 0; i < (int) c.size(); i++) {",
      "            long long cur = c[i] + carry;",
      "            res.a.push_back((int) (cur % 1000000));",
      "            carry = cur / 1000000;",
      "        }",
      "        res.a = convert_base(res.a, 6, BASE_DIGITS);",
      "        res.trim();",
      "        return res;",
      "    }",
      "",
      "    void operator*=(const BigInt &v) {",
      "        *this = *this * v;",
      "    }",
      "    BigInt operator*(const BigInt &v) const {",
      "        if (a.size() * v.a.size() <= 1000111) return mul_simple(v);",
      "        if (a.size() > 500111 || v.a.size() > 500111) return mul_fft(v);",
      "        return mul_karatsuba(v);",
      "    }",
      "",
      "    BigInt mul_fft(const BigInt& v) const {",
      "        BigInt res;",
      "        res.sign = sign * v.sign;",
      "        multiply_fft(convert_base(a, BASE_DIGITS, 3), convert_base(v.a, BASE_DIGITS, 3), res.a);",
      "        res.a = convert_base(res.a, 3, BASE_DIGITS);",
      "        res.trim();",
      "        return res;",
      "    }",
      "",
      "    // -------------------- Misc --------------------",
      "    BigInt abs() const {",
      "        BigInt res = *this;",
      "        res.sign *= res.sign;",
      "        return res;",
      "    }",
      "    void trim() {",
      "        while (!a.empty() && !a.back())",
      "            a.pop_back();",
      "        if (a.empty())",
      "            sign = 1;",
      "    }",
      "",
      "    bool isZero() const {",
      "        return a.empty() || (a.size() == 1 && !a[0]);",
      "    }",
      "",
      "    friend BigInt gcd(const BigInt &x, const BigInt &y) {",
      "        return y.isZero() ? x : gcd(y, x % y);",
      "    }",
      "    friend BigInt lcm(const BigInt &x, const BigInt &y) {",
      "        return x / gcd(x, y) * y;",
      "    }",
      "",
      "    friend BigInt sqrt(const BigInt &a1) {",
      "        BigInt a = a1;",
      "        while (a.a.empty() || a.a.size() % 2 == 1)",
      "            a.a.push_back(0);",
      "",
      "        int n = a.a.size();",
      "",
      "        int firstDigit = (int) sqrt((double) a.a[n - 1] * BASE + a.a[n - 2]);",
      "        int norm = BASE / (firstDigit + 1);",
      "        a *= norm;",
      "        a *= norm;",
      "        while (a.a.empty() || a.a.size() % 2 == 1)",
      "            a.a.push_back(0);",
      "",
      "        BigInt r = (long long) a.a[n - 1] * BASE + a.a[n - 2];",
      "        firstDigit = (int) sqrt((double) a.a[n - 1] * BASE + a.a[n - 2]);",
      "        int q = firstDigit;",
      "        BigInt res;",
      "",
      "        for(int j = n / 2 - 1; j >= 0; j--) {",
      "            for(; ; --q) {",
      "                BigInt r1 = (r - (res * 2 * BigInt(BASE) + q) * q) * BigInt(BASE) * BigInt(BASE) + (j > 0 ? (long long) a.a[2 * j - 1] * BASE + a.a[2 * j - 2] : 0);",
      "                if (r1 >= 0) {",
      "                    r = r1;",
      "                    break;",
      "                }",
      "            }",
      "            res *= BASE;",
      "            res += q;",
      "",
      "            if (j > 0) {",
      "                int d1 = res.a.size() + 2 < r.a.size() ? r.a[res.a.size() + 2] : 0;",
      "                int d2 = res.a.size() + 1 < r.a.size() ? r.a[res.a.size() + 1] : 0;",
      "                int d3 = res.a.size() < r.a.size() ? r.a[res.a.size()] : 0;",
      "                q = ((long long) d1 * BASE * BASE + (long long) d2 * BASE + d3) / (firstDigit * 2);",
      "            }",
      "        }",
      "",
      "        res.trim();",
      "        return res / norm;",
      "    }",
      "};",
      "// }}}"
    ],
    "description": "BigInt"
  },
  "bisect.cpp": {
    "prefix": "bisect",
    "scope": "cpp",
    "body": [
      "int lo = $1, hi = $2, mid;",
      "// chk(lo) = true, chk(hi) = false",
      "auto chk = [&](auto x)->bool{",
      "    $0",
      "};",
      "while(lo + 1 < hi) chk(mid = midpoint(lo, hi)) ? lo = mid, hi = mid;"
    ],
    "description": "bisect"
  },
  "Compresser.cpp": {
    "prefix": "Compresser",
    "scope": "cpp",
    "body": [
      "// reference: https://sotanishy.github.io/cp-library-cpp/misc/compress.hpp.html",
      "template<class T>",
      "struct Compresser{",
      "    vector<T> t;",
      "    Compresser() = default;",
      "    Compresser(const vector<T> &v): t(v){}",
      "    void add(const auto&... x){ ((t.push_back(x)), ...); }",
      "    void compress(){",
      "        ranges::sort(t);",
      "        t.erase(begin(ranges::unique(t)), end(t));",
      "    }",
      "    int floor(const T& x) const{",
      "        return ranges::distance(begin(t), ranges::upper_bound(t, x)) - 1;",
      "    }",
      "    int ceil(const T& x) const{",
      "        return compress(x);",
      "    }",
      "    int compress(const T& x) const {",
      "        return ranges::distance(begin(t), ranges::lower_bound(t, x));",
      "    }",
      "    void compress(vector<T> &v) const {",
      "        ranges::transform(v, begin(v), [&](T x){return compress(x);});",
      "    }",
      "    const T& val(int i) const { return t[i]; }",
      "    int size() const{ return t.size(); }",
      "};"
    ],
    "description": "Compresser"
  },
  "countInversion.cpp": {
    "prefix": "countInversion",
    "scope": "cpp",
    "body": [
      "/*",
      "countInversion: number of swap operations to make nums from original",
      "O(n log n)",
      "*/",
      "// put BIT(fenwick tree) struct here",
      "ll countInversion(const vector<int>&original,const vector<int>&nums){",
      "    assert(original.size() == nums.size());",
      "    int n = nums.size();",
      "    vector<int> t(original);",
      "    sort(all(t)); t.erase(unique(all(t)), t.end());",
      "    int nn = t.size();",
      "    vector<vector<int>> v(nn);",
      "    for(int i=0;i<n;i++)",
      "        v[lower_bound(all(t), original[i]) - t.begin()].push_back(i);",
      "    BIT f(n+1);",
      "    ll ans = 0;",
      "    for(int i=n-1;i>=0;i--){",
      "        int x = lower_bound(all(t), nums[i]) - t.begin();",
      "        int idx = v[x].back(); v[x].pop_back();",
      "        ++idx; // 1-base",
      "        ans += f.qry(idx - 1);",
      "        f.upd(idx, 1);",
      "    }",
      "    return ans;",
      "}"
    ],
    "description": "countInversion"
  },
  "Date.cpp": {
    "prefix": "Date",
    "scope": "cpp",
    "body": [
      "// src: 2011 Rocky Mountain Regional Contest H",
      "struct Date {",
      "    int month, day, year;",
      "    Date(int mm = 1, int dd = 1, int yy = 1900) : month(mm), day(dd), year(yy) {}",
      "    static constexpr int daysInMonth[2][13] = {",
      "        { 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 },",
      "        { 0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }",
      "    };",
      "    static constexpr bool isLeap(int y){return (y % 4 == 0 && y % 100 != 0) || (y % 400 == 0);}",
      "    bool operator<(const Date& date) const {",
      "        if (year != date.year) return year < date.year;",
      "        if (month != date.month) return month < date.month;",
      "        return day < date.day;",
      "    }",
      "    bool operator <=(const Date& date) const{",
      "        return not (date < *this);",
      "    }",
      "    bool operator >(const Date& date) const{",
      "        return date < *this;",
      "    }",
      "    bool operator >=(const Date& date) const{",
      "        return not (*this < date);",
      "    }",
      "    void inc() {",
      "        if (day++ == daysInMonth[isLeap(year)][month]) {",
      "            day = 1;",
      "            if (month++ == 12) {",
      "                month = 1;",
      "                year++;",
      "            }",
      "        }",
      "    }",
      "    void dec() {",
      "        if (day-- == 1) {",
      "            if (month-- == 1) {",
      "                month = 12;",
      "                assert(year > 0);",
      "                year--;",
      "            }",
      "            day = daysInMonth[isLeap(year)][month];",
      "        }",
      "    }",
      "    void change(int step){",
      "        if(step == 0) return;",
      "        if(step > 0){",
      "            for(int i=0;i<step;i++) inc();",
      "        }else{",
      "            step *= -1;",
      "            for(int i=0;i<step;i++) dec();",
      "        }",
      "    }",
      "    friend istream& operator>>(istream& is, Date& date) {",
      "        char c;",
      "        return is >> date.month >> c >> date.day >> c >> date.year;",
      "    }",
      "    friend ostream& operator<<(ostream& os, const Date& date) {",
      "        return os << date.month << '/' << date.day << '/' << date.year;",
      "    }",
      "};"
    ],
    "description": "Date"
  },
  "erasable_heap.cpp": {
    "prefix": "erasable_heap",
    "scope": "cpp",
    "body": [
      "/** Eraseable heap",
      " * cmp\ub294 bool operator()\uc774 \uc815\uc758\ub41c struct \ub610\ub294 class",
      " * cmp \uc0c1\uc73c\ub85c \uac00\uc7a5 \ud070 \uac83\uc774 \ubc18\ud658\ub428",
      " */",
      "template<class T, class cmp = less<T>>",
      "struct heap{",
      "    priority_queue<T, vector<T>, cmp> iq, dq;",
      "    cmp f;",
      "    bool eq(const T&l, const T&r){return not f(l, r) and not f(r, l);}",
      "    void push(T x){iq.push(x);}",
      "    void del(T x){dq.push(x);}",
      "    void upd(){",
      "        while(not dq.empty()){",
      "            if(iq.empty() or f(iq.top(), dq.top())) dq.pop();",
      "            else{",
      "                if(eq(iq.top(), dq.top())) iq.pop(), dq.pop();",
      "                else break;",
      "            }",
      "        }",
      "    }",
      "    bool empty(){upd(); return iq.empty();}",
      "    T pop(){upd(); T x = iq.top(); iq.pop(); return x;}",
      "    T top(){upd(); return iq.top();}",
      "};"
    ],
    "description": "erasable_heap"
  },
  "leftist_heap.cpp": {
    "prefix": "leftist_heap",
    "scope": "cpp",
    "body": [
      "#include<deque>",
      "#include<cassert>",
      "#include<algorithm>",
      "",
      "/**",
      " * Title: \"Min\" Persistent Leftist Heap",
      " * Repository: https://github.com/Pentagon03/Algorithms/blob/master/Data%20Structures/leftist_heap.cpp",
      " * Reference: nor( https://judge.yosupo.jp/submission/87297 )",
      " */",
      "template <typename Key, typename Value>",
      "struct LeftistHeap {",
      "    using self_t = LeftistHeap<Key, Value>;",
      "    int node_rank;",
      "    Key key;",
      "    Value value;",
      "    self_t *left, *right;",
      "    LeftistHeap(int rank_, Key key_, Value value_, self_t* left_,",
      "                self_t* right_)",
      "            : node_rank{rank_}, key{key_}, value{value_}, left{left_}, right{right_} {}",
      "    // contains Leftistheap itself for each node. We use deque for non-reallocation such as vector. pointers don't get invalidated.",
      "    inline static thread_local std::deque<LeftistHeap> alloc;",
      "    friend self_t* heap_insert(LeftistHeap* a, const Key &k, const Value &v) {",
      "        if (not a or not (a->key < k)) { // Important: k == a.key case should be considerd. if not, k will be repeatively inserted through the whole heap.",
      "            alloc.emplace_back(1, k, v, a, nullptr);",
      "            return &alloc.back();",
      "        }",
      "        auto l = a->left, r = heap_insert(a->right, k, v);",
      "        // Gurantee => l valid and l->rank >= r->rank",
      "        if (not l or l->node_rank < r->node_rank)",
      "            std::swap(l, r);",
      "        alloc.emplace_back(r ? r->node_rank + 1 : 0, a->key, a->value, l, r);",
      "        return &alloc.back();",
      "    }",
      "};"
    ],
    "description": "leftist_heap"
  },
  "LineContainer.cpp": {
    "prefix": "LineContainer",
    "scope": "cpp",
    "body": [
      "/*",
      "Modified Line container for dynamic CHT",
      "y = kx + m",
      "qry: gives minimum value for given x, upper hull",
      "find bool operator< (const Line& o) to change minimum / maximum properties.",
      "for minimum: k > o.k, x->m > y->m",
      "for maximum: k < o.k, x->m < y->m",
      "for doubles, change all (ll -> double), (inf -> 1/.0), (div(a,b) = a/b)",
      "reference: https://github.com/kth-competitive-programming/kactl/blob/main/content/data-structures/LineContainer.h",
      "*/",
      "#define MIN_VALUE",
      "struct Line{",
      "    mutable ll k, m, p;",
      "    // int cnt; // additional info",
      "    #ifdef MIN_VALUE",
      "    bool operator<(const Line& o) const{return k!=o.k?k>o.k:m>o.m;}",
      "    #else",
      "    bool operator<(const Line& o) const{return k!=o.k?k<o.k:m<o.m;}",
      "    #endif",
      "    bool operator<(ll x) const {return p < x;}",
      "    ll f(ll x) const{return k * x + m;}",
      "};",
      "struct LC : multiset<Line, less<>> {",
      "    void print_it(iterator it){fprintf(stderr, \"[%d] %lld %lld %lld\\n\",(int)distance(begin(),it), it->k, it->m, it->p);}",
      "    void print(){",
      "        fprintf(stderr, \"size: %d\\n\", (int)size());",
      "        for(auto it = begin(); it != end(); it++)",
      "            print_it(it);",
      "    }",
      "    static const ll inf = numeric_limits<ll>::max();",
      "    inline ll div(ll a, ll b){ // floored division",
      "        return a / b - ((a^b)<0 && a%b);",
      "    }",
      "    bool apply(iterator x, iterator y){",
      "        assert(x != end() && next(x) == y);",
      "        if(y == end()) return x->p = inf, false;",
      "        if(x->k == y->k) x->p = (*y<*x?inf:-inf);",
      "        else x->p = div(y->m - x->m, x->k - y->k);",
      "        return x->p >= y->p;",
      "    }",
      "    bool add(const Line &t){",
      "        auto y = insert(t), z = next(y), x = y;",
      "        if(z!=end() && y->k == z->k) return erase(y), false;",
      "        while(apply(y, z)) z = erase(z);",
      "        if(x != begin() && apply(--x, y)) return apply(x, y = erase(y)), false;",
      "        while((y=x) != begin() && (--x)->p >= y->p) apply(x, erase(y));",
      "        return true;",
      "    }",
      "    Line qry(ll x){",
      "        assert(!empty());",
      "        auto l = lower_bound(x); assert(l != end());",
      "        return *l;",
      "    }",
      "};"
    ],
    "description": "LineContainer"
  },
  "UnionFindwithRollback.cpp": {
    "prefix": "UnionFindwithRollback",
    "scope": "cpp",
    "body": [
      "struct disjoint_set {",
      "\tvector<int> par;",
      "    vector<array<int, 3>> S;",
      "\tdisjoint_set(int n = 0) : par(n+1, -1) {}",
      "\tint find(int u) {",
      "\t\treturn par[u] < 0 ? u : par[u] = find(par[u]);",
      "\t}",
      "\tbool merge(int u, int v) {",
      "\t\tu = find(u), v = find(v);",
      "\t\tif (u == v) return false;",
      "\t\tif (par[u] < par[v]) swap(u, v);",
      "\t\t// sz[u] <= sz[v]",
      "        S.push_back({u, v, par[u]});",
      "\t\tpar[v] += par[u];",
      "\t\tpar[u] = v;",
      "\t\treturn true;",
      "\t}",
      "    void rollback(int n = 1){",
      "        for(int i=0;i<n;i++){",
      "\t\t\tassert(not empty(S));",
      "\t\t\tauto [u,v,psz] = S.back(); S.pop_back();",
      "\t\t\tpar[v] -= psz; par[u] = psz;",
      "\t\t}",
      "    }",
      "};"
    ],
    "description": "UnionFindwithRollback"
  },
  "[NOT_TESTED] Roll-back-able Line Container.cpp": {
    "prefix": "[NOT_TESTED] Roll-back-able Line Container",
    "scope": "cpp",
    "body": [
      "/*",
      "Rollback-able Line container for dynamic CHT that can be Rollbacked.",
      "y = kx + m",
      "qry: gives minimum value for given x, Lower hull",
      "find bool operator< (const Line& o) to change minimum / maximum properties.",
      "for minimum: k > o.k, x->m > y->m",
      "for maximum: k < o.k, x->m < y->m",
      "for doubles, change all (ll -> double), (inf -> 1/.0), (div(a,b) = a/b)",
      "reference: https://github.com/kth-competitive-programming/kactl/blob/main/content/data-structures/LineContainer.h",
      "*/",
      "struct Line{",
      "    mutable ll k, m, p;",
      "    bool operator<(const Line& o) const{return k!=o.k?k>o.k:m>o.m;} // chg here",
      "    bool operator<(ll x) const {return p < x;}",
      "};",
      "struct LineContainer : multiset<Line, less<>> {",
      "    void print_it(iterator it){fprintf(stderr, \"%dth %lld %lld %lld\\n\",(int)distance(begin(),it), it->k, it->m, it->p);}",
      "    void print(){",
      "        fprintf(stderr, \"size: %d\\n\", (int)size());",
      "        for(auto it = begin(); it != end(); it++)",
      "            print_it(it);",
      "    }",
      "    static const ll inf = LLONG_MAX;",
      "    ll div(ll a, ll b){ // floored division",
      "        return a / b - ((a ^ b) < 0 && a % b);",
      "    }",
      "    bool apply(iterator x, iterator y){",
      "        assert(x != end() && next(x) == y);",
      "        if(y == end()){",
      "            x->p = inf;",
      "            return false;",
      "        }",
      "        if(x->k == y->k) x->p = (*y<*x?inf:-inf);",
      "        else x->p = div(y->m - x->m, x->k - y->k);",
      "        return x->p >= y->p;",
      "    }",
      "    vector<int> info; vector<Line> S;",
      "    bool add(ll k, ll m){",
      "        Line t{k, m, -inf};",
      "        auto z = insert(t), y = z++, x = y;",
      "        if(z!=end() && k == z->k){erase(y); info.push_back(0); return false;}",
      "        vector<Line> v;",
      "        while(apply(y, z)) v.push_back(*z), z = erase(z);",
      "        if(x != begin() && apply(--x, y)){",
      "            apply(x, y = erase(y));",
      "            info.push_back(0); return false;",
      "        }",
      "        reverse(v.begin(), v.end());",
      "        while((y=x) != begin() && (--x)->p >= y->p) v.push_back(*y), apply(x, erase(y));",
      "        v.push_back(t);",
      "        S.insert(S.end(), v.begin(), v.end()); info.push_back(v.size());",
      "        return true;",
      "    }",
      "    void rollback(){",
      "        assert(!info.empty());",
      "        auto c = info.back(); info.pop_back();",
      "        if(c == 0) return;",
      "        assert(c <= (int)S.size());",
      "        auto l = S.back(); S.pop_back(); --c;",
      "        auto it = lower_bound(l);",
      "        assert(it != end() && it->k == l.k && it->m == l.m);",
      "        it = erase(it);",
      "        if(c==0){",
      "            if(size() > 0 && it != begin()) apply(prev(it), it);",
      "            return;",
      "        }",
      "        bool flag = it != begin(); if(flag) --it;",
      "        auto y = it;",
      "        if(flag) y = insert(y, S.back()), apply(it, y);",
      "        else y = insert(S.back());",
      "        for(int i=2;i<=c;i++) y = insert(y, S[S.size()-i]), apply(prev(y), y);",
      "        assert(y != end());",
      "        apply(y, next(y));",
      "        S.resize(S.size()-c);",
      "    }",
      "    ll qry(ll x){",
      "        assert(!empty());",
      "        auto l = lower_bound(x);",
      "        assert(l != end());",
      "        return l->k * x + l->m;",
      "    }",
      "};"
    ],
    "description": "[NOT_TESTED] Roll-back-able Line Container"
  },
  "ConvexHullTrick.cpp": {
    "prefix": "ConvexHullTrick",
    "scope": "cpp",
    "body": [
      "/*",
      "Convex Hull Trick Container",
      "concave (max value)\uc774\uba74 k \uc624\ub984\ucc28\uc21c \uc0bd\uc785 \uac15\uc81c\ub418\uc5b4\uc57c \ud568.",
      "convex (min value)\uc774\uba74 k \ub0b4\ub9bc\ucc28\uc21c \uc0bd\uc785 \uac15\uc81c\ub418\uc5b4\uc57c \ud568.",
      "typename P: point\uc758 \uc790\ub8cc\ud615\uc784. \uae30\ubcf8\uc740 ll",
      "for doubles, change all (ll -> double), (div(l,r) = l/r)",
      "*/",
      "// #define MIN_VALUE",
      "static constexpr ll INF = numeric_limits<ll>::max(); // change it for int",
      "template<typename P = int64_t>",
      "struct Line{",
      "    ll k, m; // kx + m",
      "    // int idx; // additional info",
      "    P p{INF};",
      "    #ifdef MIN_VALUE",
      "    bool operator<(const Line& o) const{return k!=o.k?k>o.k:m>o.m;}",
      "    #else",
      "    bool operator<(const Line& o) const{return k!=o.k?k<o.k:m<o.m;}",
      "    #endif",
      "    friend inline P inter(const Line&l, const Line&r){",
      "        assert(l.k != r.k);",
      "        auto div = [&](P l, P r)->P{",
      "            return l / r - ((l^r) < 0 && l % r); // int: floored division",
      "            // return l / r;",
      "        };",
      "        return div(l.m-r.m, r.k-l.k);",
      "    }",
      "    P f(P x){return k * x + m;}",
      "};",
      "template<typename P = int64_t>",
      "struct CHT{",
      "    using L = Line<P>;",
      "    vector<L> stk;",
      "    int n, p; // \uc9c1\uc120\uc758 \uac1c\uc218, \ub9c8\uc9c0\ub9c9\uc73c\ub85c \uc0b4\ud3b4\ubcf8 \uc9c1\uc120\uc758 \uc704\uce58",
      "    CHT():stk(1),n(0),p(0){}",
      "    bool add(const L& t){",
      "        if(n>=1 && stk[n-1].k == t.k){",
      "            if(!(stk[n-1] < t)) return false;",
      "            --n;",
      "        }",
      "        for(P x; n>=2 && !(stk[n-2].p < (x = inter(stk[n-1], t))); n--){",
      "            // do smth with stk[n-2] and x",
      "        }",
      "        if(n == stk.size()) stk.resize(stk.size() * 2); // double it",
      "        if(n>=1) stk[n-1].p = inter(stk[n-1], t);",
      "        stk[n++] = t;",
      "        return true;",
      "    }",
      "    // x\uac00 \uc99d\uac00\ud558\ub294 \uc21c\uc11c\ub85c \ub4e4\uc5b4\uc62c \ub54c, amortized O(1)",
      "    L qry(P x){",
      "        assert(n > 0 && \"n should be positive\");",
      "        p = min(p, n-1);",
      "        while(p > 0 && !(stk[p-1].p < x)) p--;",
      "        while(p < n-1 && stk[p].p < x) p++;",
      "        assert(x <= stk[p].p);",
      "        return stk[p];",
      "    }",
      "    // returns idx ; x\uc758 \uc21c\uc11c\ub97c \ubaa8\ub984, \uc774\ubd84\ud0d0\uc0c9, O(log N)",
      "    L qry_bs(P x){",
      "        assert(n > 0 && \"n should be positive\");",
      "        int lo = -1, hi = n-1;",
      "        while(lo+1<hi){",
      "            int mid = (lo+hi) / 2;",
      "            if(stk[mid].p < x) lo = mid;",
      "            else hi = mid;",
      "        }",
      "        return stk[hi];",
      "    }",
      "};"
    ],
    "description": "ConvexHullTrick"
  },
  "DnC_opt.cpp": {
    "prefix": "DnC_opt",
    "scope": "cpp",
    "body": [
      "/**",
      " * cur[i] = min(pre[j] + C(j,i))",
      " * if Opt(i) is monotone, we can apply Dnc opt.",
      " * Usually C(j, i) is a monge array",
      "*/",
      "auto dnc = [&](int steps, int n){",
      "    const ll infl = numeric_limits<ll>::max()/2;",
      "    auto C = [&](int j, int i){",
      "        // You should carefully handle j > i case",
      "        if(j > i) return infl;",
      "        return ;",
      "    };",
      "    vector<ll> pre(n+1), cur(n+1);",
      "    for(int i=0;i<=n;i++) pre[i] = C(i, 0);",
      "    auto dnc = [&](auto&self, int l, int r, int optl, int optr){",
      "        if(l > r) return;",
      "        int m = l + r >> 1;",
      "        pair<ll, int> best({infl, m});",
      "        for(int i=optl;i<=min(m, optr);i++){",
      "            if(pre[i] >= infl) continue;",
      "            best = min(best, {pre[i] + C(i, m), i});",
      "        }",
      "        int opt; tie(cur[m], opt) = best;",
      "        self(self, l, m-1, optl, opt);",
      "        self(self, m+1, r, opt, optr);",
      "    };",
      "    for(int i=1;i<=steps;i++){",
      "        dnc(dnc, 0, n, 0, n);",
      "        pre.swap(cur);",
      "    }",
      "    return pre;",
      "};"
    ],
    "description": "DnC_opt"
  },
  "Lagrange_Relaxation.cpp": {
    "prefix": "Lagrange_Relaxation",
    "scope": "cpp",
    "body": [
      "void Lagrange(){",
      "    // dp(i) = dp(j) + C(j,i)",
      "    // f(x): using at most x index. If f(x) is convex or concave... f(x) - \\lambda x is always concave..",
      "    auto f = [&](ll lambda){",
      "        // solve",
      "        return pair<ll,ll>{dpval,cnt};",
      "    };",
      "    ll lo = 0, hi = 1LL * m * m + 1;",
      "    // lo: k \ucd08\uacfc",
      "    // hi: k \uc774\ud558",
      "    // \ubc18\uc815\uc218\ud558\ub294\uac8c \ub098\uc911\uc5d0 \uc5ed\ucd94\uc801\ud560 \ub54c \uae54\ub054\ud558\uae34 \ud558\ub098, \ub2f5\ub9cc \uad6c\ud560\uac70\ub77c\uba74 \ud544\uc694\uc5c6\uc74c.",
      "    while(lo + 1 < hi){",
      "        auto mid = (lo+hi)/2;",
      "        auto [x, c] = f(mid);",
      "        if(c <= k) hi = mid;",
      "        else lo = mid;",
      "    }",
      "    ll ans = max(f(lo).first - lo * k, f(hi).first - hi * k);",
      "    return ans;",
      "}"
    ],
    "description": "Lagrange_Relaxation"
  },
  "SOS_DP.cpp": {
    "prefix": "SOS_DP",
    "scope": "cpp",
    "body": [
      "// SOS DP",
      "",
      "// F[mask] = sum of A[i] where i is subset of mask",
      "// 1. Naive, O(3^N)",
      "F[mask] = A[0];",
      "for(int i = mask; i > 0; i = i-1 & mask)",
      "\tF[mask] += A[i];",
      "",
      "// 2. SOS DP, O(N 2^N).  S(i, mask) as set of subsets such that it differ for the first $i$ bits. (0-based)",
      "for(int i=0;i<(1<<N);i++) F[i] = A[i];",
      "for(int i=0;i<N;i++) for(int mask=0;mask<(1<<N);mask++)",
      "\tif(mask & (1<<i))",
      "\t\tF[mask] += F[mask ^ (1<<i)]",
      "",
      "// 3. Next Lexicographical number with same bit count",
      "int mxb = 30, mx = (1<<mxb) - 1; // max bit count",
      "int b; // b\uac1c\uc758 \ube44\ud2b8\ub97c \uac00\uc9c0\ub294 \uc218\ub4e4\uc744 x\ubd80\ud130 \uc0ac\uc804\uc21c\uc73c\ub85c \uc21c\ud68c",
      "// \ud639\uc740 x = mask\ub85c \uc2dc\uc791",
      "for(int x = (1<<b)-1; x <= mx; c = x&-x, r = x+c, x = ( (((r\u02c6x) >> 2)/c) | r) ){",
      "  // do smth with x",
      "}"
    ],
    "description": "SOS_DP"
  },
  "custom_hash.cpp": {
    "prefix": "custom_hash",
    "scope": "cpp",
    "body": [
      "// source: https://codeforces.com/blog/entry/62393",
      "",
      "struct custom_hash {",
      "    using u64 = uint64_t;",
      "    static u64 splitmix64(u64 x) {",
      "        // http://xorshift.di.unimi.it/splitmix64.c",
      "        x += 0x9e3779b97f4a7c15;",
      "        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
      "        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
      "        return x ^ (x >> 31);",
      "    }",
      "",
      "    size_t operator()(u64 x) const {",
      "        static const u64 FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();",
      "        return splitmix64(x + FIXED_RANDOM);",
      "    }",
      "    size_t operator()(pair<u64, u64> x) const{",
      "        static const u64 FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();",
      "\t\treturn splitmix64(x.first + FIXED_RANDOM)^(splitmix64(x.second + FIXED_RANDOM) >> 1);",
      "    }",
      "};",
      "",
      "unordered_map<int64_t, int, custom_hash> safe_map;",
      "#include <ext/pb_ds/assoc_container.hpp>",
      "__gnu_pbds::gp_hash_table<int64_t, int, custom_hash> safe_hash_table;"
    ],
    "description": "custom_hash"
  },
  "HashMap.cpp": {
    "prefix": "HashMap",
    "scope": "cpp",
    "body": [
      "// source: https://judge.yosupo.jp/submission/172003",
      "// 1<<LG is bucket size, IS = Insert Order, LG heavily depends on situation",
      "// use custom_hash for other data structures",
      "// let (x, y) => (a, b) hash results. we combine them by => (a ^ (b>>1))",
      "using u64 = uint64_t;",
      "template <typename K = u64, typename V = int, int LG = 22, bool KEEP_IS = false>",
      "struct HashMap {",
      "    static const u64 FIXED_RANDOM;",
      "    static constexpr int N = 1 << LG;",
      "    u64* key = new u64[N];",
      "    V* val = new V[N];",
      "    vector<int> IS;",
      "    std::bitset<N> vis;",
      "    static uint32_t hash(u64 x) { return (u64(x + FIXED_RANDOM) * 11995408973635179863ULL) >> (64 - LG); }",
      "    static uint32_t hash(pair<u64, u64> x){",
      "        return (hash(x.first) ^ (hash(x.second) >> 1));",
      "    }",
      "    int index(K k) const {",
      "        int i = hash(k);",
      "        while (vis[i] && key[i] != k)",
      "            i = (i + 1) & (N - 1);",
      "        return i;",
      "    }",
      "    V& operator[](K k) {",
      "        int i = index(k);",
      "        if (!vis[i]) {",
      "            vis[i] = true;",
      "            key[i] = k;",
      "            val[i] = {};",
      "            if constexpr (KEEP_IS)",
      "                IS.emplace_back(i);",
      "        }",
      "        return val[i];",
      "    }",
      "    V get(K k, V d = {}) const {",
      "        int i = index(k);",
      "        return vis[i] ? val[i] : d;",
      "    }",
      "    bool contains(K k) const {",
      "        int i = index(k);",
      "        return vis[i] and key[i] == k;",
      "    }",
      "    void clear() {",
      "        vis.reset();",
      "        if constexpr (KEEP_IS)",
      "            IS.clear();",
      "    }",
      "    void enumerate(auto&& f) const {",
      "        static_assert(KEEP_IS);",
      "        for(auto i: IS)",
      "            f(key[i], val[i]);",
      "    }",
      "    ~HashMap() {",
      "        delete[] key;",
      "        delete[] val;",
      "    }",
      "};",
      "template <typename K, typename V, int LG, bool KEEP_IS>",
      "const u64 HashMap<K, V, LG, KEEP_IS>::FIXED_RANDOM = std::chrono::steady_clock::now().time_since_epoch().count();"
    ],
    "description": "HashMap"
  },
  "ordered_set,multiset.cpp": {
    "prefix": "ordered_set,multiset",
    "scope": "cpp",
    "body": [
      "/*",
      "ordered set and ordered multiset inheritted by gnu policy-based-structures",
      "kth_element(idx): get iterator of idx-th element. O(log |size|) => ex) {0,1,3,6,7}, auto it = kth_element(3); cout<< (*it); // prints 6",
      "index(value): return index of lower bound of value. O(log |size|) => int idx = index(5); // lower bound is 6, so idx = 3;",
      "reference: https://codeforces.com/blog/entry/11080",
      "source: me",
      "code help(class inherittence): frozenca (https://github.com/frozenca)",
      "*/",
      "",
      "// ORDERED_SET START",
      "#include \"ext/pb_ds/assoc_container.hpp\"",
      "using namespace __gnu_pbds;",
      "template <typename Typename = int, class Parent = tree<Typename, null_type, less<Typename>, rb_tree_tag,tree_order_statistics_node_update>>",
      "struct ordered_set : Parent{",
      "    using iterator = typename Parent::iterator;",
      "    // this returns the element of idx-th index in O(log n)",
      "    iterator kth_element(int idx){",
      "        assert(0 <= idx && idx < Parent::size());",
      "        return Parent::find_by_order(idx);",
      "    }",
      "    // this returns the index of lower bound of val in O(log n)",
      "    int index(Typename val){",
      "        assert(Parent::size() > 0);",
      "        return Parent::order_of_key(val);",
      "    }",
      "};",
      "// ORDERED_SET END",
      "",
      "// ORDERED_MULTISET START",
      "#include \"ext/pb_ds/assoc_container.hpp\"",
      "using namespace __gnu_pbds;",
      "template <typename Typename = int, class Parent = tree<Typename, null_type, less_equal<Typename>, rb_tree_tag,tree_order_statistics_node_update>>",
      "struct ordered_multiset : Parent{",
      "    /*",
      "        for multiset, functions of lower_bound and upper_bound swap.",
      "        see the declaration",
      "        lower_bound: smallest idx that \"a[idx] '<=' val\" is false; thus val < a[idx]",
      "        upper_bound: smallest idx that \"val '<=' a[i]\" is true; thus val <= a[idx]",
      "    */",
      "    using iterator = typename Parent::iterator;",
      "    iterator lower_bound(Typename val){return Parent::upper_bound(val);}",
      "    iterator upper_bound(Typename val){return Parent::lower_bound(val);}",
      "    void erase(iterator it){Parent::erase(it);}",
      "    bool erase(Typename val){",
      "        auto it = Parent::lower_bound(val);",
      "        if(it != Parent::end() && *it == val){",
      "            Parent::erase(it); return true;",
      "        }",
      "        return false;",
      "    }",
      "    // this returns the element of idx-th index in O(log n)",
      "    iterator kth_element(int idx){",
      "        assert(0 <= idx && idx < Parent::size());",
      "        return Parent::find_by_order(idx);",
      "    }",
      "    // this returns the index of lower bound of val in O(log n)",
      "    int index(Typename val){",
      "        assert(Parent::size() > 0);",
      "        return Parent::order_of_key(val);",
      "    }",
      "};",
      "// ORDERED_MULTISET END"
    ],
    "description": "ordered_set,multiset"
  },
  "pbds_tourist.cpp": {
    "prefix": "pbds_tourist",
    "scope": "cpp",
    "body": [
      "#include <ext/pb_ds/assoc_container.hpp>",
      "",
      "template <typename K, typename V, typename Comp = std::less<K>>",
      "using ordered_map = __gnu_pbds::tree<",
      "\tK, V, Comp,",
      "\t__gnu_pbds::rb_tree_tag,",
      "\t__gnu_pbds::tree_order_statistics_node_update",
      ">;",
      "",
      "template <typename K, typename Comp = std::less<K>>",
      "using ordered_set = ordered_map<K, __gnu_pbds::null_type, Comp>;",
      "",
      "// Supports",
      "//  auto iterator = ordered_set().find_by_order(idx); // (0-indexed)",
      "//  int num_strictly_smaller = ordered_set().order_of_key(key);"
    ],
    "description": "pbds_tourist"
  },
  "BIT.cpp": {
    "prefix": "BIT",
    "scope": "cpp",
    "body": [
      "/*",
      "- Binary indexed Tree",
      "- set your operation function op",
      "- You may make off-by-one error, so it prevents it",
      "*/",
      "template<typename T>",
      "struct BIT{",
      "    int n; vector<T> t;",
      "    BIT(int _n=0):n(_n+4),t(n+1){}",
      "    inline void op(T &l,T r) const{l += r;}",
      "    inline void upd(int p,T v){",
      "        assert(1 <= p+2 && p+2 <= n);",
      "        for(p+=2;p<=n;p+=p&-p) op(t[p],v);",
      "    }",
      "    inline T qry(int p) const{",
      "        assert(1 <= p+2 && p+2 <= n);",
      "        T res=0;",
      "        for(p+=2;p>0;p-=p&-p) op(res,t[p]);",
      "        return res;",
      "    }",
      "    // min lb>=1 s.t. sum[lb] >= x",
      "    inline int lower_bound(T x){",
      "        int p = 0; T sum = 0;",
      "        for(int i = __lg(n); i >= 0; i--){",
      "            if((p|1<<i) <= n and sum + t[p | (1<<i)] < x){",
      "                p |= (1<<i);",
      "                op(sum, t[p]);",
      "            }",
      "        }",
      "        ++p; // so that sum >= x",
      "        return p-2;",
      "    }",
      "};"
    ],
    "description": "BIT"
  },
  "BIT_2D.cpp": {
    "prefix": "BIT_2D",
    "scope": "cpp",
    "body": [
      "template<typename T>",
      "struct BIT_2D{",
      "\tint n,m;",
      "\tvector<vector<T>> v;",
      "\tBIT_2D(int a=0,int b=0){",
      "\t\tn=a; m=b;",
      "\t\tv.assign(n+1,vector<T>(m+1));",
      "\t}",
      "    void upd(int x,int y,T val){",
      "\t\tfor(int i=x;i<=n;i+=i&-i)for(int j=y;j<=m;j+=j&-j)v[i][j]+=val;",
      "\t}",
      "    // (1,1) to (x,y)",
      "\tT qry(int x,int y) const{",
      "\t\tT sum=0;",
      "\t\tfor(int i=x;i>0;i-=i&-i)for(int j=y;j>0;j-=j&-j)sum+=v[i][j];",
      "\t\treturn sum;",
      "\t}",
      "    // (a,b) to (c,d)",
      "    T qry(int a, int b, int c, int d){",
      "        if(a > c or b > d) return 0;",
      "        return qry(c, d) - qry(c, b-1) - qry(a-1, d) + qry(a-1, b-1);",
      "    }",
      "};"
    ],
    "description": "BIT_2D"
  },
  "DynamicLazySeg.cpp": {
    "prefix": "DynamicLazySeg",
    "scope": "cpp",
    "body": [
      "/*",
      "# Dynamic Lazy Segtree - Memory Opt",
      "- same convention with LazySeg",
      "- Lazy Seg Tutorial: https://github.com/Pentagon03/Algorithms/blob/master/Data%20Structures/RangeQueries/LazySeg_Tutorial.md",
      "- `DynamicLazySeg seg(Range l, Range r);`",
      "- If you need index information, consider one of following",
      "    - 1. modify `make` function to put info.",
      "    - 2. modify `mapping` function to get additional parameter (index), and modify `apply` function",
      "- Range=> index type, S=> node monoid, F=> update monoid",
      "- If you need constant-optimization, use Array version in github.",
      "    - adjust LG = Log Size of Array.",
      "*/",
      "",
      "$0",
      "using Range = int;",
      "// Example",
      "// https://www.acmicpc.net/problem/20212",
      "// Range: int, S: range sum, F: range add",
      "struct S{",
      "    ll sum;",
      "    int len;",
      "};",
      "constexpr S e(){return {0, 0};}",
      "S op(S a, S b){return {",
      "    a.sum + b.sum,",
      "    a.len + b.len,",
      "};};",
      "using F = ll; // add",
      "constexpr F id(){return 0;}",
      "// x = f(x)",
      "void mapping(F f, S&x){x.sum += x.len * f;}",
      "// g(x) = f(g(x))",
      "void composition(F f, F&g){g += f;}",
      "",
      "",
      "// template<   class Range,",
      "//             class S, S (*e)(),",
      "//             S (*op)(S, S),",
      "//             class F, F(*id)(),",
      "//             void (*mapping)(F, S&),",
      "//             void (*composition)(F, F&)>",
      "struct DynamicLazySeg{",
      "    public:",
      "    struct Node{",
      "        Range ns, ne;",
      "        S value;",
      "        F lz;",
      "        Node *l, *r;",
      "        Node(Range l, Range r): ns(l), ne(r), value(e()), lz(id()), l(NULL), r(NULL){}",
      "    };",
      "    inline Node* make(Range l, Range r){",
      "        alloc.emplace_back(l, r);",
      "        // example (range add, sum)",
      "        alloc.back().value.len = r - l + 1;",
      "        return &alloc.back();",
      "    }",
      "",
      "    // Node Range: ex) -inf, inf",
      "    DynamicLazySeg(Range l, Range r){",
      "        root = make(l, r);",
      "    }",
      "",
      "    // i \\in [l, r], A[i] => f(A[i])",
      "    void upd(Range l, Range r, F f, Node *nd = NULL){",
      "        if(nd == NULL) nd = root;",
      "        if(r < nd->ns or nd->ne < l) return;",
      "        if(l <= nd->ns and nd->ne <= r){",
      "            apply(nd, f);",
      "            return;",
      "        }",
      "        push(nd);",
      "        assert(nd -> l and nd -> r);",
      "        upd(l, r, f, nd->l); upd(l, r, f, nd->r);",
      "        pull(nd);",
      "    }",
      "",
      "    S qry(Range l, Range r, Node *nd = NULL){",
      "        if(nd == NULL) nd = root;",
      "        if(r < nd->ns or nd->ne < l) return e();",
      "        if(l <= nd->ns and nd->ne <= r) return nd->value;",
      "        push(nd);",
      "        return op(qry(l, r, nd->l), qry(l, r, nd->r));",
      "    }",
      "",
      "    S qry_all(){ return root->value; }",
      "",
      "    private:",
      "    Node *root;",
      "    deque<Node> alloc;",
      "    void pull(Node*nd){",
      "        assert(nd -> l and nd -> r); // always pull after push",
      "        nd->value = op(nd->l->value, nd->r->value);",
      "    }",
      "    void apply(Node*nd, F f){",
      "        if(f == id()) return;",
      "        mapping(f, nd->value);",
      "        if(nd->ns < nd->ne){",
      "            composition(f, nd->lz);",
      "            // if(nd->value.fail) push(nd), pull(nd); // SegTree Beats, add mapping fail info to 'S' (necessary)",
      "        }",
      "    }",
      "    // should make all child nodes",
      "    void push(Node*nd){",
      "        if(not nd->l) nd->l = make(nd->ns, midpoint(nd->ns, nd->ne));",
      "        apply(nd->l, nd->lz);",
      "        if(not nd->r) nd->r = make(midpoint(nd->ns, nd->ne) + 1, nd->ne);",
      "        apply(nd->r, nd->lz);",
      "        nd->lz = id();",
      "    }",
      "};"
    ],
    "description": "DynamicLazySeg"
  },
  "DynamicLazySeg_Array.cpp": {
    "prefix": "DynamicLazySeg_Array",
    "scope": "cpp",
    "body": [
      "/*",
      "# Dynamic Lazy Segtree - Memory Opt",
      "- same convention with LazySeg",
      "- Lazy Seg Tutorial: https://github.com/Pentagon03/Algorithms/blob/master/Data%20Structures/RangeQueries/LazySeg_Tutorial.md",
      "- `DynamicLazySeg seg(Range l, Range r);`",
      "- If you need index information, consider one of following",
      "    - 1. modify `make` function to put info.",
      "    - 2. modify `mapping` function to get additional parameter (index), and modify `apply` function",
      "- Range=> index type, S=> node monoid, F=> update monoid",
      "- If you need constant-optimization, use Array version in github.",
      "    - adjust LG = Log Size of Array.",
      "*/",
      "$0",
      "// Example",
      "// https://www.acmicpc.net/problem/20212",
      "// Range: int, S: range sum, F: range add",
      "constexpr int LG = 21; // Log Size of Array",
      "using Range = int;",
      "using S = ll;",
      "constexpr S e(){return 0;}",
      "S op(S a, S b){return S{a + b};}",
      "using F = ll; // add",
      "constexpr F id(){return 0;}",
      "// x = f(x)",
      "void mapping(F f, S&x, Range len){x += len * f;}",
      "// g(x) = f(g(x))",
      "void composition(F f, F&g){g += f;}",
      "",
      "",
      "// template<   class Range,",
      "//             class S, S (*e)(),",
      "//             S (*op)(S, S),",
      "//             class F, F(*id)(),",
      "//             void (*mapping)(F, S&),",
      "//             void (*composition)(F, F&),",
      "//             int LG = 21 >",
      "template<int LG = 21>",
      "struct DynamicLazySeg{",
      "    public:",
      "    struct Node{",
      "        Range ns, ne;",
      "        S value;",
      "        F lz;",
      "        int l, r;",
      "        Node():value(e()){}",
      "        Node(Range l, Range r): ns(l), ne(r), value(e()), lz(id()), l(0), r(0){}",
      "    };",
      "    inline int make(Range l, Range r){",
      "        assert(pivot < size);",
      "        alloc[pivot] = Node(l, r);",
      "        return pivot++;",
      "    }",
      "    // Node Range: ex) -inf, inf",
      "    DynamicLazySeg(Range l, Range r){",
      "        size = 1 << LG;",
      "        alloc = new Node[size]; pivot = 1;",
      "        root = make(l, r);",
      "    }",
      "    // i \\in [l, r], A[i] => f(A[i])",
      "    void upd(Range l, Range r, F f){",
      "        return upd(l, r, f, &alloc[root]);",
      "    }",
      "    // op(A[l], ... , A[r])",
      "    S qry(Range l, Range r){",
      "        return qry(l, r, &alloc[root]);",
      "    }",
      "",
      "    S qry_all(){ return alloc[root].value; }",
      "",
      "    ~DynamicLazySeg(){",
      "        delete[] alloc;",
      "    }",
      "",
      "    private:",
      "    int root;",
      "    Node *alloc; int size, pivot;",
      "    inline bool disjoint(Range l, Range r, Range s, Range e){",
      "        return r < s or e < l;",
      "    }",
      "    void pull(Node*nd){",
      "        nd->value = op(nd->l ? alloc[nd->l].value : e(), nd->r ? alloc[nd->r].value : e());",
      "    }",
      "    void apply(Node*nd, F f){",
      "        if(f == id()) return;",
      "        mapping(f, nd->value, nd->ne - nd->ns + 1);",
      "        if(nd->ns < nd->ne){",
      "            composition(f, nd->lz);",
      "            // if(nd->value.fail) push(nd), pull(nd); // SegTree Beats, add mapping fail info to 'S' (necessary)",
      "        }",
      "    }",
      "    void push(Node*nd){",
      "        if(nd -> lz == id()) return;",
      "        Range nm = midpoint(nd->ns, nd->ne);",
      "        if(not nd->l) nd->l = make(nd->ns, nm);",
      "        apply(&alloc[nd->l], nd->lz);",
      "        if(not nd->r) nd->r = make(nm + 1, nd->ne);",
      "        apply(&alloc[nd->r], nd->lz);",
      "        nd->lz = id();",
      "    }",
      "    void upd(Range l, Range r, F f, Node*nd){",
      "        if(not nd or disjoint(l, r, nd->ns, nd->ne)) return;",
      "        if(l <= nd->ns and nd->ne <= r){",
      "            apply(nd, f);",
      "            return;",
      "        }",
      "        push(nd);",
      "        Range nm = midpoint(nd->ns, nd->ne);",
      "        if(not nd->l and not disjoint(l, r, nd->ns, nm)) nd->l = make(nd->ns, nm);",
      "        if(not nd->r and not disjoint(l, r, nm + 1, nd->ne)) nd->r = make(nm + 1, nd->ne);",
      "        upd(l, r, f, &alloc[nd->l]);",
      "        upd(l, r, f, &alloc[nd->r]);",
      "        pull(nd);",
      "    }",
      "    S qry(Range l, Range r, Node *nd){",
      "        if(not nd or disjoint(l, r, nd->ns, nd->ne)) return e();",
      "        if(l <= nd->ns and nd->ne <= r) return nd->value;",
      "        push(nd);",
      "        return op(qry(l, r, &alloc[nd->l]), qry(l, r, &alloc[nd->r]));",
      "    }",
      "};"
    ],
    "description": "DynamicLazySeg_Array"
  },
  "DynamicLazySeg_AutoAdjust.cpp": {
    "prefix": "DynamicLazySeg_AutoAdjust",
    "scope": "cpp",
    "body": [
      "/*",
      "# Dynamic Lazy Segtree - Memory Opt",
      "- same convention with LazySeg",
      "- Lazy Seg Tutorial: https://github.com/Pentagon03/Algorithms/blob/master/Data%20Structures/RangeQueries/LazySeg_Tutorial.md",
      "- `DynamicLazySeg seg(Range l, Range r);`",
      "- If you need index information, consider one of following",
      "    - 1. modify `make` function to put info.",
      "    - 2. modify `mapping` function to get additional parameter (index), and modify `apply` function",
      "- Range=> index type, S=> node monoid, F=> update monoid",
      "- If you need constant-optimization, use Array version in github.",
      "    - adjust LG = Log Size of Array.",
      "*/",
      "",
      "$0",
      "// Example",
      "// https://www.acmicpc.net/problem/20212",
      "// Range: int, S: range sum, F: range add",
      "constexpr int LG = 21; // Log Size of Array",
      "using Range = int;",
      "using S = ll;",
      "constexpr S e(){return 0;}",
      "S op(S a, S b){return S{a + b};}",
      "using F = ll; // add",
      "constexpr F id(){return 0;}",
      "// x = f(x)",
      "void mapping(F f, S&x, Range len){x += len * f;}",
      "// g(x) = f(g(x))",
      "void composition(F f, F&g){g += f;}",
      "",
      "",
      "// template<   class Range,",
      "//             class S, S (*e)(),",
      "//             S (*op)(S, S),",
      "//             class F, F(*id)(),",
      "//             void (*mapping)(F, S&),",
      "//             void (*composition)(F, F&),",
      "//             int LG = 21 >",
      "struct DynamicLazySeg{",
      "    public:",
      "    int size = 1 << LG;",
      "    struct Node{",
      "        Range ns, ne;",
      "        S value;",
      "        F lz;",
      "        int l, r;",
      "        Node():value(e()){}",
      "        Node(Range l, Range r): ns(l), ne(r), value(e()), lz(id()), l(0), r(0){}",
      "    };",
      "    inline int make(Range l, Range r){",
      "        if(pivot == size){",
      "            nalloc = new Node[size * 2];",
      "            ranges::move(alloc, alloc+size, nalloc);",
      "            delete[] alloc;",
      "            alloc = nalloc;",
      "            nalloc = nullptr;",
      "            size *= 2;",
      "        }",
      "        assert(pivot < size);",
      "        alloc[pivot] = Node(l, r);",
      "        return pivot++;",
      "    }",
      "    // Node Range: ex) -inf, inf",
      "    DynamicLazySeg(Range l, Range r){",
      "        alloc = new Node[size]; nalloc = nullptr; pivot = 1;",
      "        root = make(l, r);",
      "    }",
      "    // i \\in [l, r], A[i] => f(A[i])",
      "    void upd(Range l, Range r, F f){",
      "        return upd(l, r, f, root);",
      "    }",
      "    // op(A[l], ... , A[r])",
      "    S qry(Range l, Range r){",
      "        return qry(l, r, root);",
      "    }",
      "",
      "    S qry_all(){ return alloc[root].value; }",
      "",
      "    ~DynamicLazySeg(){",
      "        delete[] alloc;",
      "    }",
      "",
      "    private:",
      "    int root;",
      "    Node *alloc, *nalloc; int pivot;",
      "    inline bool disjoint(Range l, Range r, Range s, Range e){",
      "        return r < s or e < l;",
      "    }",
      "    void pull(int i){",
      "        alloc[i].value = op(alloc[i].l ? alloc[alloc[i].l].value : e(), alloc[i].r ? alloc[alloc[i].r].value : e());",
      "    }",
      "    void apply(int i, F f){",
      "        if(f == id()) return;",
      "        // index information",
      "        mapping(f, alloc[i].value, alloc[i].ne - alloc[i].ns + 1);",
      "        if(alloc[i].ns < alloc[i].ne){",
      "            composition(f, alloc[i].lz);",
      "            // if(nd->value.fail) push(i), pull(i); // SegTree Beats, add mapping fail info to 'S' (necessary)",
      "        }",
      "    }",
      "    void push(int i){",
      "        if(alloc[i].lz == id()) return;",
      "        Range nm = midpoint(alloc[i].ns, alloc[i].ne);",
      "        if(not alloc[i].l) {",
      "            int l = make(alloc[i].ns, nm);",
      "            alloc[i].l = l;",
      "        }",
      "        if(not alloc[i].r){",
      "            int r = make(nm + 1, alloc[i].ne);",
      "            alloc[i].r = r;",
      "        }",
      "        apply(alloc[i].l, alloc[i].lz);",
      "        apply(alloc[i].r, alloc[i].lz);",
      "        alloc[i].lz = id();",
      "    }",
      "    void upd(Range l, Range r, F f, int i){",
      "        if(not i or disjoint(l, r, alloc[i].ns, alloc[i].ne)) return;",
      "        if(l <= alloc[i].ns and alloc[i].ne <= r){",
      "            apply(i, f);",
      "            return;",
      "        }",
      "        push(i);",
      "        Range nm = midpoint(alloc[i].ns, alloc[i].ne);",
      "        if(not alloc[i].l and not disjoint(l, r, alloc[i].ns, nm)){",
      "            int l = make(alloc[i].ns, nm);",
      "            alloc[i].l = l;",
      "        }",
      "        if(not alloc[i].r and not disjoint(l, r, nm + 1, alloc[i].ne)){",
      "            int r = make(nm + 1, alloc[i].ne);",
      "            alloc[i].r = r;",
      "        }",
      "        upd(l, r, f, alloc[i].l);",
      "        upd(l, r, f, alloc[i].r);",
      "        pull(i);",
      "    }",
      "    S qry(Range l, Range r, int i){",
      "        if(not i or disjoint(l, r, alloc[i].ns, alloc[i].ne)) return e();",
      "        if(l <= alloc[i].ns and alloc[i].ne <= r) return alloc[i].value;",
      "        push(i);",
      "        return op(qry(l, r, alloc[i].l), qry(l, r, alloc[i].r));",
      "    }",
      "};"
    ],
    "description": "DynamicLazySeg_AutoAdjust"
  },
  "DynamicSegGeneralized.cpp": {
    "prefix": "DynamicSegGeneralized",
    "scope": "cpp",
    "body": [
      "/*",
      "# Dynamic Seg Generalized<Range, S> (Point Update)",
      "- `void upd(point, unary function(S&x), combine function(S&x, S&l, S&r))`",
      "- `V qry(point, unary function(S&x), fold function(V x, S&x), V init)`",
      "ex) https://www.acmicpc.net/source/share/1049c3d8d92f4f348e28d8af4a10795a",
      "*/",
      "template<   class Range,",
      "            class S>",
      "struct DynamicSeg{",
      "    static constexpr Range NIL = numeric_limits<Range>::max();",
      "    struct Node{",
      "        S value;",
      "        Range only;",
      "        Node *l, *r;",
      "        Node(S val, Range only = NIL): value(val), only(only), l(NULL), r(NULL){}",
      "    };",
      "    inline Node* make(S val, Range only = NIL){",
      "        Node *nd = new Node(val, only);",
      "        return nd;",
      "    }",
      "    Range L, R;",
      "    Node *root;",
      "    S eval;",
      "    DynamicSeg() = default;",
      "    explicit DynamicSeg(Range l, Range r, S ev):L(l), R(r), eval(ev){",
      "        root = make(eval);",
      "    }",
      "    DynamicSeg& operator=(const DynamicSeg& rht) {",
      "        L = rht.L; R = rht.R; eval = rht.eval;",
      "        root = copydfs(rht, rht.root);",
      "        return *this;",
      "    }",
      "    DynamicSeg(const DynamicSeg& rht){",
      "        *this = rht;",
      "    }",
      "    Node* copydfs(const DynamicSeg& rht, Node*rnd){",
      "        if(not rnd) return NULL;",
      "        Node* nd = make(rnd->value, rnd->only);",
      "        nd->l = copydfs(rht, rnd->l);",
      "        nd->r = copydfs(rht, rnd->r);",
      "        return nd;",
      "    }",
      "    // unary(A[x])",
      "    template<class U, class C>",
      "    void upd(Range i, U &&unary, C &&combine){",
      "        assert(L <= i and i <= R);",
      "        upd(i, unary, combine, root, L, R);",
      "    }",
      "    // fold(init, A[l]) ... r",
      "    template<class U, class C, class V>",
      "    V qry(Range l, Range r, U &&unary, C &&fold, V init) const{",
      "        // assert(l <= r);",
      "        if(l > r) return init;",
      "        if(r < L or R < l) return init;",
      "        l = clamp(l, L, R); r = clamp(r, L, R);",
      "        return qry(l, r, unary, fold, init, root, L, R);",
      "    }",
      "    template<class U>",
      "    auto qry_all(U &&unary) const{",
      "        return unary(root->value);",
      "    }",
      "    // r such that fold(A[0]...A[r-1]) = true, op(A[0]...A[r]) = false. a.k.a first false",
      "    template<typename G, class C, class V>",
      "    Range partition_point(G &&g, C &&fold, V init){",
      "        if(not g(init)) return L;",
      "        V allval = fold(init, root->value);",
      "        if(g(allval)) return R + 1;",
      "        return partition_point(g, fold, init, root, L, R);",
      "    }",
      "    template<class U, class C>",
      "    void upd(Range i, U &&unary, C &&combine, Node *nd, Range ns, Range ne){",
      "        assert(nd);",
      "        if(ns == ne or nd->only == i){",
      "            assert(ns <= i and i <= ne);",
      "            unary(nd->value);",
      "            return;",
      "        }",
      "        Range nm = midpoint(ns, ne);",
      "        if(nd->only != NIL){",
      "            auto &ch = (nd->only <= nm) ? nd->l : nd->r;",
      "            assert(not ch);",
      "            ch = make(nd->value, nd->only);",
      "            nd->only = NIL;",
      "        }",
      "        if(i <= nm){",
      "            if(not nd->l){",
      "                nd->l = make(eval, i);",
      "                unary(nd->l->value);",
      "            }else{",
      "                upd(i, unary, combine, nd->l, ns, nm);",
      "            }",
      "        }else{",
      "            if(not nd->r){",
      "                nd->r = make(eval, i);",
      "                unary(nd->r->value);",
      "            }else{",
      "                upd(i, unary, combine, nd->r, nm+1, ne);",
      "            }",
      "        }",
      "        assert(nd->l or nd->r);",
      "        combine(nd->value, nd->l ? nd->l->value : eval, nd->r ? nd->r->value : eval);",
      "    }",
      "    template<class U, class C, class V>",
      "    V qry(Range l, Range r, U &&unary, C &&fold, V init, Node *nd, Range ns, Range ne) const{",
      "        assert(nd);",
      "        if(r < ns or ne < l) return init;",
      "        if(l <= ns and ne <= r) return unary(nd->value);",
      "        if(nd->only != NIL){",
      "            if(l <= nd->only and nd->only <= r) return unary(nd->value);",
      "            else return init;",
      "        }",
      "        Range nm = midpoint(ns, ne);",
      "        V ans = init;",
      "        if(nd->l) ans = fold(ans, qry(l, r, unary, fold, init, nd->l, ns, nm));",
      "        if(nd->r) ans = fold(ans, qry(l, r, unary, fold, init, nd->r, nm+1, ne));",
      "        return ans;",
      "    }",
      "    template<typename G, class C, class V>",
      "    Range partition_point(G &&g, C &&fold, V val, Node* nd, Range ns, Range ne){",
      "        assert(nd);",
      "        assert(g(val));",
      "        if(ns == ne) return ns;",
      "        if(nd->only != NIL){",
      "            V nval = fold(val, nd->value);",
      "            assert(not(g(nval)));",
      "            return nd->only;",
      "        }",
      "        assert(nd->l or nd->r);",
      "        Range nm = midpoint(ns, ne);",
      "        if(not nd->l) return partition_point(g, fold, val, nd->r, nm+1, ne);",
      "        assert(nd->l);",
      "        V lval = fold(val, nd->l->value);",
      "        if(not g(lval)) return partition_point(g, fold, val, nd->l, ns, nm);",
      "        assert(nd->r);",
      "        return partition_point(g, fold, lval, nd->r, nm+1, ne);",
      "    }",
      "    void deldfs(Node *nd){",
      "        if(not nd) return;",
      "        deldfs(nd->l); deldfs(nd->r);",
      "        delete nd;",
      "    }",
      "    ~DynamicSeg(){",
      "        deldfs(root);",
      "    }",
      "};"
    ],
    "description": "DynamicSegGeneralized"
  },
  "LazySeg.cpp": {
    "prefix": "LazySeg",
    "scope": "cpp",
    "body": [
      "/*",
      "# Lazy Segtree Tutorial",
      "- S: monoid for tree",
      "- S e() : identity of S",
      "- S op(S a, S b): monoid action",
      "- F: mapping function",
      "- F id(): identity of f",
      "- void mapping(F f, S&x) : x => f(x)",
      "- void composition(F f, F&g): g(x) => f(g(x))",
      "- (optional) `LazySeg<S, e, op, F, id, mapping, composition>`",
      "- `upd(l, r, f) : i \\in [l, r], A[i] => f(A[i])`",
      "- `qry(l, r) : op(A[l], ... , A[r])`",
      "- Tutorial(+Beats): https://github.com/Pentagon03/Algorithms/blob/master/Data%20Structures/RangeQueries/LazySeg_Tutorial.md",
      "*/",
      "",
      "$0",
      "// Example 1",
      "// https://www.acmicpc.net/problem/10999",
      "// S: range sum, F: range add",
      "struct S{",
      "    ll sum;",
      "    int cnt;",
      "};",
      "constexpr S e(){return {0, 0};}",
      "S op(const S& a,const S& b){",
      "    return S{",
      "        a.sum + b.sum,",
      "        a.cnt + b.cnt",
      "    };",
      "};",
      "using F = ll; // add",
      "constexpr F id(){return 0;}",
      "// x = f(x)",
      "void mapping(F f, S&x){x.sum += x.cnt * f;}",
      "// g(x) = f(g(x))",
      "void composition(F f, F&g){g += f;}",
      "",
      "",
      "// template<   class S, S (*e)(),",
      "//             S (*op)(S, S),",
      "//             class F, F(*id)(),",
      "//             void (*mapping)(F, S&),",
      "//             void (*composition)(F, F&)>",
      "struct LazySeg{",
      "    public:",
      "    LazySeg(int n = 0) : LazySeg(vector(n, e())) {}",
      "    LazySeg(const vector<S>& v){",
      "        n = bit_ceil(size(v));",
      "        tree = vector (n<<1, e());",
      "        lz = vector (n, id());",
      "        ranges::copy(v, begin(tree) + n);",
      "        for(int i=n-1;i>=0;i--) pull(i);",
      "    }",
      "    // i \\in [l, r], A[i] => f(A[i])",
      "    void upd(int l, int r, F f, int nd = 1, int ns = 0, int ne = -1){",
      "        // assert(0 <= l and l <= r and r <= n - 1);",
      "        if(ne == -1) ne = n - 1;",
      "        if(r < ns or ne < l) return; // add 'strengthend condition' for segtree beats (optional)",
      "        if(l <= ns and ne <= r){",
      "            apply(nd, f);",
      "            return;",
      "        }",
      "        push(nd);",
      "        int nm = midpoint(ns, ne);",
      "        upd(l, r, f, nd << 1, ns, nm); upd(l, r, f, nd << 1 | 1, nm+1, ne);",
      "        pull(nd);",
      "    }",
      "    // op(A[l], ... , A[r])",
      "    S qry(int l, int r, int nd = 1, int ns = 0, int ne = -1){",
      "        // assert(0 <= l and l <= r and r <= n - 1);",
      "        if(ne == -1) ne = n - 1;",
      "        if(r < ns or ne < l) return e();",
      "        if(l <= ns and ne <= r) return tree[nd];",
      "        push(nd);",
      "        int nm = midpoint(ns, ne);",
      "        return op(qry(l, r, nd << 1, ns, nm), qry(l, r, nd << 1 | 1, nm+1, ne));",
      "    }",
      "    S qry_all(){ return tree[1]; }",
      "",
      "    private:",
      "    int n;",
      "    vector<S> tree; vector<F> lz;",
      "    void pull(int i){ tree[i] = op(tree[i<<1], tree[i<<1|1]);}",
      "    void apply(int i, F f){",
      "        mapping(f, tree[i]);",
      "        if(i < n){",
      "            composition(f, lz[i]);",
      "            // if(tree[i].fail) push(i), pull(i); // SegTree Beats, add mapping fail info to 'S'(necessary)",
      "        }",
      "    }",
      "    void push(int i){",
      "        apply(i << 1, lz[i]);",
      "        apply(i << 1 | 1, lz[i]);",
      "        lz[i] = id();",
      "    }",
      "};"
    ],
    "description": "LazySeg"
  },
  "LiChaoTree.cpp": {
    "prefix": "LiChaoTree",
    "scope": "cpp",
    "body": [
      "// Lichao Tree",
      "// edited, source: psb0623, https://www.acmicpc.net/source/85126114",
      "const ll INF_ = 1e18;",
      "struct Line{",
      "    ll a = 0, b = -INF_;",
      "    ll operator()(ll x) {return a*x+b;}",
      "};",
      "// using Line = function<ll(ll)>;",
      "struct LCT {",
      "\tll s, e;",
      "\tLine line;",
      "\tLCT *l=0, *r=0;",
      "\tLCT(ll S, ll E):s(S),e(E){}",
      "    inline static thread_local deque<LCT> alloc;",
      "    static LCT* make(ll S, ll E){",
      "        alloc.emplace_back(S, E);",
      "        return &alloc.back();",
      "    }",
      "\tvoid insert(Line f) {",
      "\t\tauto hi = line; auto& lo = f; ll m = s + (e-s)/2;",
      "\t\tif(hi(s) < lo(s)) swap(hi, lo);",
      "\t\tif(hi(e) >= lo(e)) { line = hi; return; }",
      "\t\tif(hi(m) > lo(m)) { line = hi; if(!r) r = make(m+1, e); r->insert(lo); }",
      "\t\telse { line = lo; if(!l) l = make(s, m); l->insert(hi); }",
      "\t}",
      "\tll get(ll x) {",
      "\t\tif(s<=x&&x<=e) return max(line(x), max(l ? l->get(x) : -INF_, r ? r->get(x) : -INF_));",
      "\t\telse return -INF_;",
      "\t}",
      "};",
      "LCT* lct = LCT::make(-1e12, 1e12);"
    ],
    "description": "LiChaoTree"
  },
  "LiChaoTree_Rollback.cpp": {
    "prefix": "LiChaoTree_Rollback",
    "scope": "cpp",
    "body": [
      "// source: benedict0724 https://www.acmicpc.net/source/65475052",
      "struct Line{",
      "    ll m, y;",
      "    Line() {}",
      "    Line(ll _m, ll _y) {",
      "        m = _m;",
      "        y = _y;",
      "    }",
      "    ll get(ll x) {",
      "        return m * x + y;",
      "    }",
      "};",
      "",
      "struct Node{",
      "    int l, r;",
      "    ll s, e;",
      "    Line line;",
      "};",
      "",
      "vector<vector<pair<int, Line>>> rollback;",
      "",
      "struct Li_Chao{",
      "    vector<Node> tree;",
      "    void init(ll s, ll e) {",
      "        tree.push_back({-1, -1, s, e, Line(0, inf)});",
      "    }",
      "",
      "    void update(int node, Line v, int now) {",
      "",
      "        ll s = tree[node].s, e = tree[node].e;",
      "        ll m = s + e >> 1;",
      "",
      "        rollback[now].push_back({node, tree[node].line});",
      "",
      "        Line low = tree[node].line, high = v;",
      "        if(low.get(s) > high.get(s)) swap(low, high);",
      "",
      "        if(low.get(e) <= high.get(e)) {",
      "            tree[node].line = low; return;",
      "        }",
      "",
      "        if(low.get(m) < high.get(m)){",
      "            tree[node].line = low;",
      "            if(tree[node].r == -1) {",
      "                tree[node].r = tree.size();",
      "                tree.push_back({-1, -1, m+1, e, {0, inf}});",
      "            }",
      "            update(tree[node].r, high, now);",
      "        }",
      "        else {",
      "            tree[node].line = high;",
      "            if(tree[node].l == -1) {",
      "                tree[node].l = tree.size();",
      "                tree.push_back({-1, -1, s, m, {0, inf}});",
      "            }",
      "            update(tree[node].l, low, now);",
      "        }",
      "    }",
      "",
      "    ll query(int node, ll x){",
      "        if(node == -1) return inf;",
      "        ll s = tree[node].s, e = tree[node].e;",
      "        ll m = s + e >> 1;",
      "        if(x <= m) return min(tree[node].line.get(x), query(tree[node].l, x));",
      "        else return min(tree[node].line.get(x), query(tree[node].r, x));",
      "    }",
      "",
      "    void rb(int now) {",
      "        for(auto u : rollback[now]) {",
      "            int node = u.first;",
      "            Line line = u.second;",
      "            tree[node].line = line;",
      "        }",
      "    }",
      "} seg;"
    ],
    "description": "LiChaoTree_Rollback"
  },
  "MergeSortTree.cpp": {
    "prefix": "MergeSortTree",
    "scope": "cpp",
    "body": [
      "template<typename T = int>",
      "struct MergeSortTree{",
      "    using Vec = vector<T>;",
      "    int n, base;",
      "    vector<Vec> tree;",
      "    MergeSortTree(){}",
      "    MergeSortTree(const Vec& v){",
      "        int n = size(v);",
      "        base = bit_ceil((unsigned)n);",
      "        tree.resize(base<<1);",
      "        ranges::copy(v, begin(tree)+base);",
      "        for(int i=base-1;i>=1;i--)",
      "            merge(all(tree[i<<1]),all(tree[i<<1|1]),back_inserter(tree[i]));",
      "    }",
      "    int elem(int k){",
      "        assert(0 <= k and k < n);",
      "        return tree[k+base][0];",
      "    }",
      "    /* op is an operation to a vector",
      "    ex) cnt_qry(0, n-1, [&](const vec& v){return f.less(v, x);})",
      "    */",
      "    // O(log n * T(op))",
      "    int cnt_qry(int l,int r,const function<int(const Vec&)>& op){",
      "        int ans = 0;",
      "        l+=base; r+=base;",
      "        while(l<=r){",
      "            if(l&1) ans += op(tree[l++]);",
      "            if(~r&1) ans += op(tree[r--]);",
      "            l>>=1; r>>=1;",
      "        }",
      "        return ans;",
      "    }",
      "    // max t that op([l, t]) <= k.  O(log^2 n * T(op))",
      "    int rightmost(int l, int k, const function<int(const Vec&)>& op){",
      "        if(k < 0) return l - 1;",
      "        int lo = l, hi = n, mid;",
      "        while(lo+1<hi) cnt_qry(l, mid = lo + hi >> 1, op) <= k ? lo = mid : hi = mid;",
      "        return lo;",
      "    }",
      "    // min t that op([t, r], x) <= k. O(log^2 n * T(op))",
      "    int leftmost(int r, int k, const function<int(const Vec&)>& op){",
      "        if(k < 0) return r+1;",
      "        int lo = -1, hi = r, mid;",
      "        while(lo+1<hi) cnt_qry(mid = lo + hi >> 1, r, op) <= k ? hi = mid : lo = mid;",
      "        return hi;",
      "    }",
      "    static inline int greater(const Vec&v, int x){",
      "        return v.end() - upper_bound(all(v), x);",
      "    }",
      "    static inline int less(const Vec&v, int x){",
      "        return lower_bound(all(v), x) - v.begin();",
      "    }",
      "    static inline int greater_equal(const Vec&v, int x){",
      "        return v.size() - less(v, x);",
      "    }",
      "    static inline int less_equal(const Vec&v,  int x){",
      "        return v.size() - greater(v, x);",
      "    }",
      "    static inline int in_range(const Vec&v,  int x, int y){",
      "        if(x > y) return 0;",
      "        return upper_bound(all(v), y) - lower_bound(all(v), x);",
      "    }",
      "    static inline int equal(const Vec&v, int x){",
      "        return in_range(v, x, x);",
      "    }",
      "};"
    ],
    "description": "MergeSortTree"
  },
  "RMQ.cpp": {
    "prefix": "RMQ",
    "scope": "cpp",
    "body": [
      "/*",
      "RMQ (range minimum query)",
      "usage:",
      "vector<int> v;",
      "RMQ st(v, ranges::min);",
      "reference: https://github.com/kth-competitive-programming/kactl/blob/main/content/data-structures/RMQ.h",
      "*/",
      "template<typename T, class Func = function<T(const T&, const T&)>>",
      "struct RMQ {",
      "\tvector<vector<T>> jmp;",
      "\tFunc f;",
      "\tRMQ(const vector<T>& V, Func g) : jmp(1, V), f(g) {",
      "\t\tfor (int pw = 1, k = 1; pw * 2 <= size(V); pw *= 2, ++k) {",
      "\t\t\tjmp.emplace_back(size(V) - pw * 2 + 1);",
      "\t\t\tfor(int j=0;j<size(jmp[k]);j++)",
      "\t\t\t\tjmp[k][j] = f(jmp[k - 1][j], jmp[k - 1][j + pw]);",
      "\t\t}",
      "\t}",
      "\tT query(int a, int b) {",
      "\t\tassert(a <= b); // or return inf if a > b",
      "\t\t++b;",
      "\t\t// __builtin_clz(1) - __builtin_clz(b - a);",
      "\t\tint dep = 31 - __builtin_clz(b - a);",
      "\t\treturn f(jmp[dep][a], jmp[dep][b - (1 << dep)]);",
      "\t}",
      "};"
    ],
    "description": "RMQ"
  },
  "Seg.cpp": {
    "prefix": "Seg",
    "scope": "cpp",
    "body": [
      "/* Segtree with point update",
      "S: monoid for tree",
      "S e() : identity of S",
      "S op(S a, S b): monoid action",
      "Seg<S, e, op>",
      "`upd(i, val);`",
      "`qry(l, r);`",
      "*/",
      "",
      "$0",
      "// Example:",
      "// S : Range add",
      "using S = int;",
      "S e(){return 0;}",
      "S op(const S&a, const S&b){return a + b;}",
      "",
      "// template<class S, S (*e)(), S (*op)(S, S)>",
      "struct Seg{",
      "    public:",
      "    Seg(int n = 0): Seg(vector (n, e())){}",
      "    Seg(const vector<S>&v){",
      "        // n = bit_ceil(size(v));",
      "        n = ssize(v);",
      "        tree = vector (n<<1, e());",
      "        ranges::copy(v, begin(tree)+n);",
      "        for(int i=n-1;i>=1;i--) pull(i);",
      "    }",
      "    const S& get(int i) const{return tree[i+n];}",
      "    void upd(int i, S val){",
      "        tree[i+=n] = val;",
      "        for(i>>=1;i>=1;i>>=1) pull(i);",
      "    }",
      "    S qry_all(){return tree[1];}",
      "    //[l, r]",
      "    S qry(int l,int r) const{",
      "        S resL, resR;",
      "        resL = resR = e();",
      "        for(l+=n,r+=n;l<=r;l>>=1,r>>=1){",
      "            if(l&1) resL = op(resL, tree[l++]);",
      "            if(~r&1) resR = op(tree[r--], resR);",
      "        }",
      "        return op(resL, resR);",
      "    }",
      "    private:",
      "    int n;",
      "    vector<S> tree;",
      "    void pull(int i){",
      "        tree[i] = op(tree[i<<1], tree[i<<1|1]);",
      "    }",
      "};"
    ],
    "description": "Seg"
  },
  "SweepLineMaxUncovered_Segtree.cpp": {
    "prefix": "SweepLineMaxUncovered_Segtree",
    "scope": "cpp",
    "body": [
      "template<typename T>",
      "struct SweepLineMaxUncovered{",
      "    int n;",
      "    struct Node{",
      "        int cover;",
      "        T len, mx, lmx, rmx;",
      "        void init(bool covered){mx = lmx = rmx = (covered ? 0 : len);}",
      "        friend Node operator +(Node a, Node b){",
      "            return Node{",
      "                0,",
      "                a.len + b.len,",
      "                max({a.mx, b.mx, a.rmx + b.lmx}),",
      "                a.lmx != a.len ? a.lmx : a.len + b.lmx,",
      "                b.rmx != b.len ? b.rmx : b.len + a.rmx,",
      "            };",
      "        }",
      "    };",
      "    static constexpr Node enode = Node{0, 0, 0, 0, 0};",
      "    vector<Node> tree;",
      "    // [0, n)",
      "    SweepLineMaxUncovered(int n){",
      "        vector<T> c(n+1); iota(begin(c), end(c), 0);",
      "        *this = SweepLineMaxUncovered(c);",
      "    }",
      "    SweepLineMaxUncovered(const vector<T>& compressed){",
      "        n = ssize(compressed) - 1;",
      "        assert(n >= 1);",
      "        int size  = bit_ceil((unsigned)n);",
      "        tree.assign(size << 1, enode);",
      "        build(compressed);",
      "    }",
      "    void build(const vector<T> & c, int nd = 1, int s = 0, int e = -1){",
      "        if(e == -1) e = n;",
      "        int len = c[e] - c[s];",
      "        tree[nd] = {0, len, len, len, len};",
      "        if(e - s > 1){",
      "            int mid = midpoint(s, e);",
      "            build(c, nd << 1, s, mid); build(c, nd << 1 | 1, mid, e);",
      "        }",
      "    }",
      "    // [l, r), [s, e)",
      "    void upd(int l, int r, int x, int nd = 1, int s = 0, int e = -1){",
      "        if(e == -1) e = n;",
      "        if(e <= l or r <= s) return;",
      "        if(l <= s and e <= r){",
      "            tree[nd].cover += x;",
      "        }else{",
      "            int mid = midpoint(s, e);",
      "            upd(l, r, x, nd << 1, s, mid);",
      "            upd(l, r, x, nd << 1 | 1, mid, e);",
      "        }",
      "        if(tree[nd].cover > 0) tree[nd].init(true);",
      "        else{",
      "            if(e - s > 1) tree[nd] = tree[nd << 1] + tree[nd << 1 | 1];",
      "            else tree[nd].init(false);",
      "        }",
      "    }",
      "    Node qry_all(){return tree[1];}",
      "    // [l, r), [s, e)",
      "    Node qry(int l, int r, int nd = 1, int s = 0, int e = -1){",
      "        if(e == -1) e = n;",
      "        if(e <= l or r <= s) return enode;",
      "        if(l <= s and e <= r) return tree[nd];",
      "        int mid = midpoint(s, e);",
      "        Node ans = qry(l, r, nd << 1, s, mid) + qry(l, r, nd << 1 | 1, mid, e);",
      "        if(tree[nd].cover > 0) ans.init(true);",
      "        return ans;",
      "    }",
      "};"
    ],
    "description": "SweepLineMaxUncovered_Segtree"
  },
  "SweepLine_SegTree.cpp": {
    "prefix": "SweepLine_SegTree",
    "scope": "cpp",
    "body": [
      "// reference: https://www.acmicpc.net/source/31632142",
      "template<class T>",
      "struct SweepLine{",
      "    const vector<T>& c;",
      "    unsigned n;",
      "    struct Node{",
      "        int cover;",
      "        T sum;",
      "    };",
      "    vector<Node> tree;",
      "    SweepLine(const vector<T>& compressed): c(compressed), n(size(c)-1), tree(bit_ceil(n)<<1){}",
      "    // [l, r), [s, e)",
      "    void upd(int l, int r, int x, int nd = 1, int s = 0, int e = -1){",
      "        if(e == -1) e = n;",
      "        if(e <= l or r <= s) return;",
      "        if(l <= s and e <= r){",
      "            tree[nd].cover += x;",
      "        }else{",
      "            int mid = midpoint(s, e);",
      "            upd(l, r, x, nd << 1, s, mid);",
      "            upd(l, r, x, nd << 1 | 1, mid, e);",
      "        }",
      "        if(tree[nd].cover > 0) tree[nd].sum = c[e] - c[s];",
      "        else tree[nd].sum = e - s > 1 ? tree[nd<<1].sum + tree[nd<<1|1].sum : 0;",
      "    }",
      "    int qry_all(){return tree[1].sum;}",
      "    // [l, r), [s, e)",
      "    int qry(int l, int r, int nd = 1, int s = 0, int e = -1){",
      "        if(e == -1) e = n;",
      "        if(e <= l or r <= s) return 0;",
      "        if(l <= s and e <= r) return tree[nd].sum;",
      "        if(tree[nd].cover > 0){",
      "            int lo = max(l, s), hi = min(r, e);",
      "            return c[hi] - c[lo];",
      "        }",
      "        int mid = midpoint(s, e);",
      "        return qry(l, r, nd << 1, s, mid) + qry(l, r, nd << 1 | 1, mid, e);",
      "    }",
      "};"
    ],
    "description": "SweepLine_SegTree"
  },
  "array_assign.cpp": {
    "prefix": "array_assign",
    "scope": "cpp",
    "body": [
      "// assign(array/vector, Dim1, ..., DimK, value)",
      "void assign(auto&A, auto n, auto...v){",
      "    if constexpr(sizeof...(v) == 0) A = n;",
      "    else for(int i=0;i<n;i++) assign(A[i], v...);",
      "}"
    ],
    "description": "array_assign"
  },
  "bit_header.cpp": {
    "prefix": "bit_header",
    "scope": "cpp",
    "body": [
      "#include<bits/stdc++.h>",
      "using namespace std;",
      "using ll = int64_t;",
      "// #define int ll",
      "using u32 = uint32_t;",
      "",
      "/*",
      "- uint32_t n\uc5d0 \ub300\ud574 \uc0dd\uac01.",
      "- n \uc774\uc0c1\uc758 \ucd5c\uc18c 2\uc758 \uac70\ub4ed\uc81c\uacf1: bit_ceil(n)",
      "- n \uc774\ud558\uc758 \ucd5c\ub300 2\uc758 \uac70\ub4ed\uc81c\uacf1: bit_floor(n)",
      "- log2(n)\uc744 \uad6c\ud558\uace0 \uc2f6\uc740 \uacbd\uc6b0: bit_width(n) - 1 (n = 0\uc758 \uacbd\uc6b0 -1\uc774 \ub41c\ub2e4)  (or) __lg(n)",
      "- 2\uc758 \uac70\ub4ed\uc81c\uacf1\uc778\uc9c0 \ud655\uc778\ud558\uace0 \uc2f6\uc740 \uacbd\uc6b0: has_single_bit(n)",
      "- \ucf1c\uc9c4 \ube44\ud2b8\uc758 \uac1c\uc218: popcount(n)",
      "- \uac00\uc7a5 \uc791\uc740 \ucf1c\uc9c4 \ube44\ud2b8 : countr_zero(n)",
      "- \uac00\uc7a5 \ud070 \ucf1c\uc9c4 \ube44\ud2b8 : bit_width(n) - 1 (or) countl_zero(0ULL) - countl_zero(n) - 1",
      "*/",
      "void solve(int cur_tc){",
      "    using bset = bitset<5>;",
      "    for(auto i{0};i<=0B1111;i++){",
      "        cout << \"i = \" << i << \" = \" << bset(i) << '\\n';",
      "        // rotl",
      "        cout << \"rotl 1: \" << bset(rotl((u32)i, 1)) << '\\n';",
      "        // rotr",
      "        cout << \"rotr 1: \" << bset(rotr((u32)i, 1)) << '\\n';",
      "",
      "        // bit_width (\uc774 \uc218\ub97c \ud45c\ud604\ud558\uae30 \uc704\ud55c \ucd5c\uc18c \ub108\ube44)",
      "        cout << \"bit_width: \" << bit_width((u32)i) << '\\n';",
      "        // popcount (1\uc758 \uac1c\uc218)",
      "        cout << \"popcount: \" << popcount((u32)i) << '\\n';",
      "",
      "        // has_single_bit (2\uc758 \uac70\ub4ed\uc81c\uacf1\uc778\uc9c0 \uac80\uc0ac)",
      "        cout << \"has_single_bit: \" << has_single_bit((u32)i) << '\\n';",
      "        // bit_ceil (N \uc774\uc0c1\uc758 \ucd5c\uc18c 2\uc758 \uac70\ub4ed\uc81c\uacf1)",
      "        cout << \"bit_ceil: \" << bit_ceil((u32)i) << '\\n';",
      "        // bit_floor (N \uc774\ud558\uc758 \ucd5c\ub300 2\uc758 \uac70\ub4ed\uc81c\uacf1)",
      "        cout << \"bit_floor: \" << bit_floor((u32)i) << '\\n';",
      "",
      "        // countl_zero (clz)",
      "        cout << \"countl_zero: \" << countl_zero((u32)i) << '\\n';",
      "        // countl_one",
      "        cout << \"countl_one: \" << countl_one((u32)i) << '\\n';",
      "        // countr_zero (crz)",
      "        cout << \"countr_zero: \" << countr_zero((u32)i) << '\\n';",
      "        // countr_one",
      "        cout << \"countr_one: \" << countr_one((u32)i) << '\\n';",
      "",
      "        cout << '\\n';",
      "    }",
      "}",
      "int32_t main(){",
      "    cin.tie(0)->sync_with_stdio(0);",
      "    int tc = 1;",
      "    // cin>>tc;",
      "    for(int i=1;i<=tc;i++) solve(i);",
      "}"
    ],
    "description": "bit_header"
  },
  "constants.cpp": {
    "prefix": "constants",
    "scope": "cpp",
    "body": [
      "using ld = long double;",
      "constexpr ld PI = numbers::pi_v<ld>;",
      "constexpr ld E = numbers::e_v<ld>;",
      "",
      "template <typename T>",
      "constexpr T inf;",
      "",
      "template <>",
      "constexpr int32_t inf<int32_t> = 1'000'000'009;",
      "",
      "template <>",
      "constexpr int64_t inf<int64_t> = 1'000'000'000'000'000'009LL;",
      "",
      "template<>",
      "constexpr double inf<double> = 1e300;",
      "",
      "template<>",
      "constexpr long double inf<long double> = 1e300;"
    ],
    "description": "constants"
  },
  "debug_my.cpp": {
    "prefix": "debug_my",
    "scope": "cpp",
    "body": [
      "// g++ -std=c++20 -D _DEBUG",
      "#ifdef _DEBUG",
      "#define Pentagon03",
      "#include<Pentagon03/debug.h>",
      "#else",
      "#define dbg(...)",
      "#define dbgArr(...)",
      "#endif"
    ],
    "description": "debug_my"
  },
  "debug_simple.cpp": {
    "prefix": "debug_simple",
    "scope": "cpp",
    "body": [
      "// source: https://codeforces.com/blog/entry/91347?#comment-798799",
      "#ifndef ONLINE_JUDGE",
      "#define gg(...) [](const auto&...x){ \\",
      "char c='='; cerr<<#__VA_ARGS__<<\" \"; ((cerr<<exchange(c,',')<<\" \"<<x),...); cerr<<endl;\\",
      "}(__VA_ARGS__);",
      "#else",
      "#define gg(...)",
      "#endif"
    ],
    "description": "debug_simple"
  },
  "fastio.cpp": {
    "prefix": "fastio",
    "scope": "cpp",
    "body": [
      "/**",
      " * FASTIO",
      " * https://github.com/Pentagon03/Algorithms/blob/master/Etc/fastio.cpp",
      " * Just use as if we use cin, cout. + u dont have to get rid of cin.tie(0)->sync_with_stdio(0);",
      " * call cout.setprecision(prec) for double precision. default is 6",
      " * __int128_t -> input or print is ok",
      " * you can call numeric_limits min/max // most implementations can't input or output numeric_limits<int>::min();",
      " * cin.geti() , cin.geti<ll>(), cin.getline() all works.",
      " * Special function: vector, pair input/output => vector<int> v(3); cin>>v; // Works!",
      " *",
      " * TEST",
      "    static const __uint128_t UINT128_MAX =__uint128_t(__int128_t(-1L));",
      "    static const __int128_t INT128_MAX = UINT128_MAX >> 1;",
      "    static const __int128_t INT128_MIN = -INT128_MAX - 1;",
      "    __int128_t x;",
      "    cin >> x; // works",
      "    cout<< x << '\\n'; // works",
      "    cout<< INT128_MIN << '\\n'; // works",
      "**/",
      "#define FASTIO 1",
      "#if FASTIO",
      "constexpr int SIZ = 1<<20;",
      "class _IN{",
      "    private:",
      "        char buf[SIZ+1], *p=buf;",
      "        int __END_FLAG__{}, __GETLINE_FLAG__{};",
      "    public:",
      "        explicit operator bool(){return !__END_FLAG__;}",
      "        inline bool isEnd(char c){ return c == '\\0';}",
      "        inline bool isBlank(char c){return c=='\\n'||c==' '||c=='\\t'||c=='\\r';}",
      "        inline char read(){",
      "            if(__END_FLAG__) return '\\0';",
      "            if(isEnd(*p)) {",
      "                buf[fread(buf,sizeof(char),SIZ,stdin)] = 0;",
      "                p = buf;",
      "                if(isEnd(*p)) return '\\0';",
      "            };",
      "            return *p++;",
      "        }",
      "        inline void scan(char&c){",
      "            do c=read(); while(isBlank(c));",
      "            if(isEnd(c)) __END_FLAG__ = true;",
      "        }",
      "        inline void scan(string&s){",
      "            s.clear(); char c; scan(c);",
      "            while(!isBlank(c) && !isEnd(c)) s.push_back(c), c=read();",
      "        }",
      "        inline void scan(float&f){string t; scan(t); f=stof(t);}",
      "        inline void scan(double&f){string t; scan(t); f=stod(t);}",
      "        inline void scan(long double&f){string t; scan(t); f=stold(t);}",
      "        template<typename T=int> inline T geti(){",
      "            char c; scan(c);",
      "            T res=0; bool sign = true;",
      "            if(c=='-') sign = false, c=read();",
      "            else if(c == '+') c = read();",
      "            while('0'<=c && c<='9'){",
      "                res = (res << 3) + (res << 1);",
      "                c -= '0'; res += sign ? c : -c;",
      "                c = read();",
      "            }",
      "            return res;",
      "        }",
      "        inline string getline(){",
      "            string s; char c = read();",
      "            for(;c!='\\n' && !isEnd(c); c = read()) s.push_back(c);",
      "            if(__GETLINE_FLAG__) __END_FLAG__ = true;",
      "            if(isEnd(c)) __GETLINE_FLAG__ =  true;",
      "            return s;",
      "        }",
      "        template<typename T1,typename T2> inline void scan(pair<T1,T2>&p){scan(p.first);scan(p.second);}",
      "        template<typename T> inline void scan(T&n){ n = geti<T>(); }",
      "        template<typename T> inline void scan(vector<T>&v){for(auto&k:v) scan(k);}",
      "        template<typename T, typename... Args> inline void scan(T&n, Args&...args){",
      "            scan(n); scan(args...);",
      "        }",
      "        struct _tmp{void sync_with_stdio(int _){}}_t;",
      "        _tmp* tie(int _){return &_t;}",
      "        void exceptions(bool b){}",
      "} _in;",
      "class _OUT{",
      "    private:",
      "    char buf[SIZ+1],*p=buf, tmp[42];",
      "    int prec = 6;",
      "    public:",
      "        explicit operator bool(){return true;}",
      "        inline void flush(){fwrite(buf,1,p-buf,stdout); p=buf;}",
      "        inline void print(const char c){{if(p==buf+SIZ) flush();} *p++=c; }",
      "        inline void print(const char*s){for(int i=0;s[i];i++) print(s[i]); }",
      "        inline void print(const string&s){for(char c:s) print(c);}",
      "        // floating point precision",
      "        inline void setprecision(int precision){prec=precision;}",
      "        inline void print(const long double f){",
      "            std::stringstream stream;",
      "            stream << std::fixed << std::setprecision(prec) << f;",
      "            print(stream.str());",
      "        }",
      "        inline void print(const double f){print((long double)f);}",
      "        inline void print(const float f){print((long double)f);}",
      "        template<typename T> inline void print(const vector<T>&v){for(auto k:v) print(k), print(' ');}",
      "        template<typename T1,typename T2> inline void print(const pair<T1,T2>&p){print(p.first); print(' '); print(p.second);}",
      "        // we assume T is integer",
      "        template<typename T> inline void print(T ans){",
      "            bool is_minimum = (ans<0) && ((ans<<1) == 0); // check whether this is the minimum of data type",
      "            if(ans<0){",
      "                print('-');",
      "                if(is_minimum) ans = ~ans;",
      "                else ans *= -1;",
      "            }",
      "            int cnt=0;",
      "            do tmp[cnt++]=(ans%10)+'0', ans/=10; while(ans>0);",
      "            if(is_minimum) ++tmp[0]; // we assume this is not 9, in-fact, c++ integer type {min}'s last digit is always '8'",
      "            for(;cnt;) print(tmp[--cnt]);",
      "        }",
      "        ~_OUT(){flush();}",
      "} _out;",
      "template<typename T> _IN& operator>> (_IN&in, T&i){in.scan(i); return in; }",
      "template<typename T> _OUT& operator<< (_OUT&out, T i){out.print(i); return out; }",
      "#define cin _in",
      "#define cout _out",
      "",
      "#else",
      "template<typename T1,typename T2> istream& operator>> (istream&in, pair<T1,T2>&p){ in>>p.first>>p.second; return in; }",
      "template<typename T> istream& operator>> (istream&in, vector<T>&v){for(auto&k:v) in>>k; return in; }",
      "template<typename T1,typename T2> ostream& operator<< (ostream&out, pair<T1,T2>&p){out<<p.first<<' '<<p.second; return out; }",
      "template<typename T> ostream& operator<< (ostream&out, vector<T> v){for(auto k:v) out<<k<<' '; return out; }",
      "",
      "#endif",
      "// END FASTIO"
    ],
    "description": "fastio"
  },
  "fastio_simple.cpp": {
    "prefix": "fastio_simple",
    "scope": "cpp",
    "body": [
      "constexpr int SZ = 1 << 18;",
      "struct IN{",
      "    char buf[SZ + 1], *p = buf;",
      "    inline char read(){",
      "        if(*p == 0){",
      "            buf[fread(buf, 1, SZ, stdin)] = 0;",
      "            p = buf;",
      "        }",
      "        return *p++;",
      "    }",
      "    template<typename T>",
      "    inline void scan(T &x){",
      "        char c; do c = read(); while(isblank(c));",
      "        T ans = 0; bool sign = true;",
      "        if(c == '-') sign = false, c = read();",
      "        while(isdigit(c)) ans = ans * 10 + c - '0', c = read();",
      "        x = sign?ans:-ans;",
      "    }",
      "}_in;",
      "template<typename T> IN& operator >> (IN &in, T&x){in.scan(x); return in;}",
      "#define cin _in",
      "",
      "struct OUT{",
      "    char buf[SZ + 1], *p = buf, tmp[42];",
      "    inline void flush(){",
      "        fwrite(buf, 1, p - buf, stdout); p = buf;",
      "    }",
      "    inline void print(char c){",
      "        if(p == buf + SZ) flush();",
      "        *p++ = c;",
      "    }",
      "    template<typename T>",
      "    inline void print(T x){",
      "        if(x < 0) print('-');",
      "        int cnt = 0;",
      "        do tmp[cnt++] = x % 10 + '0', x /= 10; while(x > 0);",
      "        for(int i=cnt-1;i>=0;i--) print(tmp[i]);",
      "    }",
      "    ~OUT(){flush();}",
      "}_out;",
      "template<typename T> OUT& operator << (OUT &out, T x){out.print(x); return out;}",
      "#define cout _out"
    ],
    "description": "fastio_simple"
  },
  "myio.cpp": {
    "prefix": "myio",
    "scope": "cpp",
    "body": [
      "/** input,print functions that can print any element or iterable",
      " * source: pentagon03, idea: swoon",
      " * set 'debug_ = 1' to change from cout to cerr",
      " * Note: ONLY printing (iterables of iterables) will print '\\n' at the end",
      " * examples)",
      " * vector<int> A(5), B(3); input(A, B);",
      " * vector<vector<int>> v = {{1,2,3}, {3,4,5}, {5,6,7}};",
      " * int a = 3; double b = 3.14; string c = \"asdf\";",
      " * print(\"wow\", v, a, b, c);",
      " */",
      "constexpr bool debug_ = 0;",
      "",
      "void input(auto&...x){((cin>>x),...);}",
      "void print(auto &&x) { (debug_?cerr:cout)<<x; }",
      "",
      "template <class T>",
      "concept is_string =",
      "    is_same_v<remove_cvref_t<T>, string> ||",
      "    is_same_v<decay_t<T>, char*> ||",
      "    is_same_v<decay_t<T>, const char*>;",
      "",
      "template <class T>",
      "concept is_iterable = requires(T &&x) { begin(x); end(x); } && !is_string<T>;",
      "",
      "template<is_iterable T>",
      "void input(T &&container){",
      "    for(auto &&element : container)",
      "        input(element);",
      "}",
      "",
      "template<is_iterable T>",
      "void print(T &&container) {",
      "    for (auto &&element : container) {",
      "        using E = decltype(element);",
      "        print(forward<E>(element));",
      "        print(is_iterable<E> ? '\\n': ' ');",
      "    }",
      "}",
      "",
      "template<class T, class... Args>",
      "void print(T &&x, Args &&...args) {",
      "    print(forward<T>(x));",
      "    if constexpr(not is_iterable<T>) print(' ');",
      "    print(forward<Args>(args)...);",
      "    if constexpr(sizeof...(args) == 1) print('\\n');",
      "}"
    ],
    "description": "myio"
  },
  "my_vec.cpp": {
    "prefix": "my_vec",
    "scope": "cpp",
    "body": [
      "/** Multidimensional Vector",
      " * modified, source: https://judge.yosupo.jp/submission/172003",
      " * usage: auto V = vec(D1, D2, ... , Initial Value)",
      " */",
      "auto vec(int n, auto&&... s) {",
      "    static_assert(sizeof...(s) >= 1 and \"last parameter should be initial value\");",
      "    if constexpr (sizeof...(s) == 1) return vector (n, s...);",
      "    else return vector (n, vec(s...));",
      "}"
    ],
    "description": "my_vec"
  },
  "my_vec_class.cpp": {
    "prefix": "my_vec_class",
    "scope": "cpp",
    "body": [
      "// source: somewhere from codeforces",
      "",
      "struct Vec : public vector<Vec<D - 1, T>> {",
      "    static_assert(D >= 1, \"Dimension must be positive\");",
      "    template <typename... Args>",
      "    Vec(int n = 0, Args... args) : vector<Vec<D - 1, T>>(n, Vec<D - 1, T>(args...)) {}",
      "};",
      "",
      "template <typename T>",
      "struct Vec<1, T> : public vector<T> {",
      "    Vec(int n = 0, T val = T()) : std::vector<T>(n, val) {}",
      "};",
      "",
      "/* Example",
      "    Vec<4, int64_t> f(n, k, 2, 2); // = f[n][k][2][2];",
      "    Vec<2, int> adj(n); // graph",
      "*/"
    ],
    "description": "my_vec_class"
  },
  "nor_enumerate_zip.cpp": {
    "prefix": "nor_enumerate_zip",
    "scope": "cpp",
    "body": [
      "// source: https://nor-blog.codeberg.page/posts/2023-01-11-cpp-like-python/",
      "",
      "template <typename T>",
      "struct iterable;",
      "template <typename T>",
      "struct iterable<T&> {",
      "    using type = T&;",
      "};",
      "template <typename T>",
      "struct iterable<T&&> {",
      "    using type = T;",
      "};",
      "template <typename T, std::size_t N>",
      "struct iterable<T (&&)[N]> {",
      "    using type = typename T::unsupported;",
      "};",
      "template <typename T>",
      "struct iterator_from_iterable {",
      "    using iterable = typename std::remove_reference<T>::type&;",
      "    using type = decltype(std::begin(std::declval<iterable>()));",
      "};",
      "template <typename T>",
      "struct iterable_traits {",
      "    using raw_iterable = T;",
      "    using raw_iterator = typename iterator_from_iterable<raw_iterable>::type;",
      "    using wrapped_iterable = typename iterable<T>::type;",
      "    using deref_value_type = decltype(*std::declval<raw_iterator>());",
      "};",
      "",
      "template <typename T>",
      "struct Range {",
      "   private:",
      "    const T l, r, skip;",
      "",
      "   public:",
      "    struct It : public std::iterator<std::forward_iterator_tag, T> {",
      "        T i;",
      "        const T skip;",
      "        explicit It(T _i, T _skip) : i(_i), skip(_skip) {}",
      "        It& operator++() { return i += skip, *this; }",
      "        const It& operator++(int) {",
      "            auto temp = *this;",
      "            return operator++(), temp;",
      "        }",
      "        T operator*() const { return i; }",
      "        bool operator!=(const It& it) const { return (skip >= 0) ? (i < *it) : (i > *it); }",
      "        bool operator==(const It& it) const { return (skip >= 0) ? (i >= *it) : (i <= *it); }",
      "    };",
      "    using iterator = It;",
      "    using value_type = T;",
      "    Range(T _l, T _r, T _skip = 1) : l(_l), r(_r), skip(_skip) {",
      "#ifdef DEBUG",
      "        assert(skip != 0);",
      "#endif",
      "    }",
      "    Range(T n) : Range(T(0), n, T(1)) {}",
      "    It begin() const {",
      "        return It(l, skip);",
      "    }",
      "    It end() const {",
      "        return It(r, skip);",
      "    }",
      "    It begin() {",
      "        return It(l, skip);",
      "    }",
      "    It end() {",
      "        return It(r, skip);",
      "    }",
      "};",
      "",
      "template <typename... T>",
      "struct zip {",
      "   public:",
      "    using value_type = std::tuple<typename iterable_traits<T>::deref_value_type...>;",
      "    using wrapped_iterables = std::tuple<typename iterable_traits<T>::wrapped_iterable...>;",
      "    using raw_iterators = std::tuple<typename iterable_traits<T>::raw_iterator...>;",
      "    using sequence = std::index_sequence_for<T...>;",
      "    struct It : public std::iterator<std::forward_iterator_tag, value_type> {",
      "       public:",
      "        explicit It(raw_iterators iterators) : iterators_(std::move(iterators)) {}",
      "        bool operator==(const It& it) const { return any_eq(it, sequence()); }",
      "        bool operator!=(const It& it) const { return !any_eq(it, sequence()); }",
      "        value_type operator*() const { return deref(sequence()); }",
      "        It& operator++() { return inc(sequence()), *this; }",
      "        const It& operator++(int) {",
      "            auto temp = *this;",
      "            return operator++(), temp;",
      "        }",
      "",
      "       private:",
      "        raw_iterators iterators_;",
      "        template <std::size_t... I>",
      "        bool any_eq(const It& it, std::index_sequence<I...>) const {",
      "            return (... || (std::get<I>(iterators_) == std::get<I>(it.iterators_)));",
      "        }",
      "        template <std::size_t... I>",
      "        value_type deref(std::index_sequence<I...>) const {",
      "            return {(*std::get<I>(iterators_))...};",
      "        }",
      "        template <std::size_t... I>",
      "        void inc(std::index_sequence<I...>) {",
      "            (++std::get<I>(iterators_), ...);",
      "        }",
      "    };",
      "    using iterator = It;",
      "    explicit zip(T&&... iterables) : iterables_(std::forward<T>(iterables)...) {}",
      "    It begin() { return begin_(sequence()); }",
      "    It end() { return end_(sequence()); }",
      "    It begin() const { return begin_(sequence()); }",
      "    It end() const { return end_(sequence()); }",
      "",
      "   private:",
      "    wrapped_iterables iterables_;",
      "    template <std::size_t... Int>",
      "    iterator begin_(std::index_sequence<Int...>) {",
      "        return iterator(std::tuple(std::begin(std::get<Int>(iterables_))...));",
      "    }",
      "    template <std::size_t... Int>",
      "    iterator end_(std::index_sequence<Int...>) {",
      "        return iterator(std::tuple(std::end(std::get<Int>(iterables_))...));",
      "    }",
      "};",
      "",
      "template <typename... T>",
      "zip(T&&...) -> zip<T&&...>;",
      "",
      "template <typename T>",
      "struct enumerate {",
      "   public:",
      "    using size_type = typename std::make_signed<std::size_t>::type;",
      "    using wrapped_iterable = typename iterable_traits<T>::wrapped_iterable;",
      "    using raw_iterator = typename iterable_traits<T>::raw_iterator;",
      "    using value_type = std::pair<size_type, typename iterable_traits<T>::deref_value_type>;",
      "    struct It : public std::iterator<std::forward_iterator_tag, value_type> {",
      "        raw_iterator iter_;",
      "        size_type start_;",
      "",
      "       public:",
      "        It(raw_iterator it, size_type start) : iter_(it), start_(start) {}",
      "        bool operator==(const It& it) const { return iter_ == it.iter_; }",
      "        bool operator!=(const It& it) const { return iter_ != it.iter_; }",
      "        It& operator++() { return ++iter_, ++start_, *this; }",
      "        const It operator++(int32_t) {",
      "            auto temp = *this;",
      "            return operator++(), temp;",
      "        }",
      "        value_type operator*() const { return {start_, *iter_}; }",
      "    };",
      "    using iterator = It;",
      "    explicit enumerate(T&& iterable, size_type start = 0) : iterable_(std::forward<T>(iterable)), start_(start) {}",
      "    It begin() { return It(std::begin(iterable_), start_); }",
      "    It end() { return It(std::end(iterable_), 0); }",
      "    It begin() const { return It(std::begin(iterable_), start_); }",
      "    It end() const { return It(std::end(iterable_), 0); }",
      "",
      "   private:",
      "    wrapped_iterable iterable_;",
      "    size_type start_;",
      "};",
      "",
      "template <typename T>",
      "enumerate(T&&) -> enumerate<T&&>;",
      "template <typename T, typename Index>",
      "enumerate(T&&, Index) -> enumerate<T&&>;",
      "",
      "/*",
      "Usage:",
      "int main() {",
      "    vector<int> a = {1, 2, 3};",
      "    vector<double> b = {4, 5, 6};",
      "    for (auto&& [x, y] : zip(a, b)) cout << x++ << ' ' << y++ << '\\n';",
      "    for (auto&& [i, x] : enumerate(a)) cout << i++ << ' ' << x++ << '\\n';",
      "    for (auto&& [x, y] : zip(a, b)) cout << x++ << ' ' << y++ << '\\n';",
      "    for (auto&& [i, x] : enumerate(a)) cout << i++ << ' ' << x++ << '\\n';",
      "    for (auto&& [x, y] : zip(vector{1, 2, 3}, array{3, 4, 5})) cout << x++ << ' ' << y++ << '\\n';",
      "    return 0;",
      "}",
      "*/"
    ],
    "description": "nor_enumerate_zip"
  },
  "pragmas.cpp": {
    "prefix": "pragmas",
    "scope": "cpp",
    "body": [
      "#pragma comment(linker, \"/stack:102400000,102400000\")",
      "#pragma GCC optimize(\"Ofast,unroll-loops\")",
      "#pragma GCC target(\"avx2,popcnt\")"
    ],
    "description": "pragmas"
  },
  "readline.cpp": {
    "prefix": "readline",
    "scope": "cpp",
    "body": [
      "string readline(char delim = '\\n'){",
      "    string t; getline(cin, t, delim);",
      "    return move(t);",
      "}"
    ],
    "description": "readline"
  },
  "stackhack.cpp": {
    "prefix": "stackhack",
    "scope": "cpp",
    "body": [
      "// source: somewhere from codeforces",
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "void main_() {",
      "    // implement your solution here",
      "}",
      "static void run_with_stack_size(void (*func)(void), size_t stsize) {",
      "    char *stack, *send;",
      "    stack = (char *)malloc(stsize);",
      "    send = stack + stsize - 16;",
      "    send = (char *)((uintptr_t)send / 16 * 16);",
      "    asm volatile(",
      "        \"mov %%rsp, (%0)\\n\"",
      "        \"mov %0, %%rsp\\n\"",
      "        :",
      "        : \"r\"(send));",
      "    func();",
      "    asm volatile(\"mov (%0), %%rsp\\n\" : : \"r\"(send));",
      "    free(stack);",
      "}",
      "int main() {",
      "    run_with_stack_size(main_, 1024 * 1024 * 1024); // run with a 1 GiB stack, change at your risk",
      "    return 0;",
      "}"
    ],
    "description": "stackhack"
  },
  "simple_solve.cpp": {
    "prefix": "simple_solve",
    "scope": "cpp",
    "body": [
      "#pragma GCC optimize(\"Ofast\")",
      "#include<bits/stdc++.h>",
      "using namespace std;",
      "using ll = int64_t;",
      "#define int ll",
      "#define all(v) begin(v), end(v)",
      "",
      "void solve(int tc){",
      "    ${0}",
      "}",
      "",
      "int32_t main(){",
      "    cin.tie(0)->sync_with_stdio(0);",
      "    int tc = 1;",
      "    // cin>>tc;",
      "    for(int i=1;i<=tc;i++) solve(i);",
      "}"
    ],
    "description": "simple_solve"
  },
  "solve.cpp": {
    "prefix": "solve",
    "scope": "cpp",
    "body": [
      "// https://github.com/Pentagon03/Algorithms",
      "// g++ -std=c++20 -D _DEBUG",
      "#ifdef _DEBUG",
      "#define Pentagon03",
      "#include<Pentagon03/debug.h>",
      "#else",
      "#define dbg(...)",
      "#define dbgArr(...)",
      "#endif",
      "#pragma GCC optimize(\"Ofast\", \"unroll-loops\")",
      "// #pragma GCC target(\"avx2\", \"popcnt\")",
      "#include\"bits/stdc++.h\"",
      "// ext headers here: ext/pb_ds/assoc_container.hpp, tr2/dynamic_bitset",
      "using namespace std;",
      "namespace R = std::ranges;",
      "namespace V = std::ranges::views;",
      "string readline(char delim = '\\n'){",
      "    string t; getline(cin, t, delim);",
      "    return move(t);",
      "}",
      "template<typename T> istream& operator>> (istream&in, vector<T>&v){for(auto&x:v)in>>x; return in;}",
      "template<typename T> ostream& operator<< (ostream&out, vector<T>&v){for(auto&x:v)out<<x<<' '; return out;}",
      "auto vec(int n, auto&&... s) {",
      "    static_assert(sizeof...(s) >= 1 and \"last parameter should be initial value\");",
      "    if constexpr (sizeof...(s) == 1) return vector (n, s...);",
      "    else return vector (n, vec(s...));",
      "}",
      "void assign(auto&A, auto&&n, auto&&...v){",
      "    if constexpr(sizeof...(v) == 0) A = n;",
      "    else for(int i=0;i<n;i++) assign(A[i], v...);",
      "}",
      "void append(auto&x, auto&&y){x.reserve(x.size()+y.size()), x.insert(x.end(), y.begin(), y.end());}",
      "void addv(auto&v, auto&&...x){(v.push_back(x),...);}",
      "template<typename T> T randint(T l, T r) {static std::mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count()); return std::uniform_int_distribution<T>(l,r)(gen);}",
      "#define all(v) (v).begin(),(v).end()",
      "#define nl '\\n'",
      "#define sp ' '",
      "#define rep(i, n) for(int i=0;i<(n);i++)",
      "#define rep1(i, n) for(int i=1;i<=(n);i++)",
      "#define repr(i, a, b) for(int i=(a);i<=(b);i++)",
      "#define repd(i, b, a) for(int i=(b);i>=(a);i--)",
      "#define int int64_t",
      "using ll = int64_t; using pii = pair<int,int>; int cur_tc;",
      "constexpr int inf = (int) 1e9 + 3; constexpr ll infl = (ll) 1e18 + 3;",
      "",
      "",
      "int32_t main(){",
      "    cin.tie(0)->sync_with_stdio(0); cin.exceptions(ios::badbit | ios::failbit);",
      "    // cout<<fixed<<setprecision(15);",
      "    int tc = 1;",
      "    // cin >> tc;",
      "    auto solve_tc = [&](){",
      "        ${0}",
      "    };",
      "    for(cur_tc=1;cur_tc<=tc;cur_tc++) solve_tc();",
      "    return 0;",
      "}"
    ],
    "description": "solve"
  },
  "solve.py": {
    "prefix": "solve",
    "scope": "py",
    "body": [
      "from sys import stdin, stdout, exit",
      "rs = lambda:stdin.readline().rstrip()",
      "ri = lambda:int(rs())",
      "rl = lambda:list(map(int,rs().split()))",
      "rls = lambda n: [ri() for _ in range(n)]",
      "prt = lambda *x:stdout.write(' '.join(map(str, x))+'\\n')",
      "inf = 10**9; mod = 10**9 + 7",
      "",
      "def solve():",
      "    ${0}",
      "    return",
      "",
      "def main():",
      "    TC = 1",
      "    TC = ri()",
      "    for _ in range(TC):",
      "        solve()",
      "",
      "if __name__ == \"__main__\":",
      "    main()"
    ],
    "description": "solve"
  },
  "BipartiteMatching.cpp": {
    "prefix": "BipartiteMatching",
    "scope": "cpp",
    "body": [
      "/*",
      "Bipartite matching",
      "\ucd5c\ub300\uc774\ubd84\ub9e4\uce6d - \uc774\ubd84 \uadf8\ub798\ud504\uc5d0\uc11c \uac04\uc120\uc744 \uc120\ud0dd\ud560\uac74\ub370, \uac01 \uc815\uc810\uc740 \ucd5c\ub300 \ud55c\ubc88\ub9cc \uc120\ud0dd \uac00\ub2a5. \uc120\ud0dd \uac00\ub2a5\ud55c \ucd5c\ub300 \uac04\uc120 \uc218.",
      "\ucd5c\uc18c\ubc84\ud14d\uc2a4\ucee4\ubc84 - \ubaa8\ub4e0 \uac04\uc120\uc758 \ucd5c\uc18c \ud55c \ub05d\uc810\uc774 \uc120\ud0dd\ub418\uae30 \uc704\ud55c \ucd5c\uc18c \uc815\uc810 \uc9d1\ud569",
      "\ucd5c\ub300\ub3c5\ub9bd\uc9d1\ud569 - \uc5b4\ub5a4 \uc815\uc810\ub3c4 \uc778\uc811\ud558\uc9c0 \uc54a\uc740 \ucd5c\ub300 \uc815\uc810 \uc9d1\ud569 (\ucd5c\uc18c \ubc84\ud14d\uc2a4 \ucee4\ubc84\uc758 \uc5ec\uc9d1\ud569)",
      "\ucfa8\ub2c9\uc758 \uc815\ub9ac\uc5d0 \uc758\ud574 \ucd5c\uc18c \ubc84\ud14d\uc2a4 \ucee4\ubc84\uc758 \ud06c\uae30\ub294 \uc774\ubd84\ub9e4\uce6d\uacfc \uac19\ub2e4. \uc99d\uba85: https://blog.naver.com/kks227/220985628523",
      "max_matching for matching value",
      "get_max_matching for actual matchings (vector<pii>)",
      "get_min_vertex_cover: [groupA/B, vertex]",
      "get_max_independent_set: [groupA/B, vertex], complement of min_vertex_cover.",
      "*/",
      "struct BipartiteMatching{",
      "    using pii = pair<int,int>;",
      "    vector<int> vis, A, B;",
      "    vector<vector<int>> g;",
      "    int pv;",
      "    BipartiteMatching(int n,int m): vis(m, 0), A(n,-1), B(m,-1), g(n), pv(0) {};",
      "    void add_edge(int a,int b){",
      "        g[a].push_back(b);",
      "    }",
      "    bool dfs(int x){",
      "        for(int nx:g[x]){",
      "            if(vis[nx]!=pv && B[nx]==-1){",
      "                vis[nx] = pv;",
      "                A[x] = nx;",
      "                B[nx] = x;",
      "                return true;",
      "            }",
      "        }",
      "        for(int nx:g[x]){",
      "            if(vis[nx]!=pv){",
      "                vis[nx] = pv;",
      "                if(dfs(B[nx])){",
      "                    A[x] = nx;",
      "                    B[nx] = x;",
      "                    return true;",
      "                }",
      "            }",
      "        }",
      "        return false;",
      "    }",
      "    int max_matching(){",
      "        pv = 0;",
      "        int ans = 0;",
      "        for(int i=0;i<size(g);i++){",
      "            ++pv;",
      "            if(dfs(i)) ++ans;",
      "        }",
      "        return ans;",
      "    }",
      "    vector<pii> get_max_matching(){",
      "        if(pv == 0) max_matching();",
      "        vector<pii> ans;",
      "        for(int i=0;i<size(A);i++){",
      "            if(A[i]!=-1){",
      "                ans.emplace_back(i, A[i]);",
      "            }",
      "        }",
      "        return ans;",
      "    }",
      "    vector<pii> get_min_vertex_cover(){",
      "        if(pv == 0) max_matching();",
      "        vector<vector<int>> g2(size(B));",
      "        for(int i=0;i<size(A);i++){",
      "            for(int x:g[i]){",
      "                g2[x].push_back(i);",
      "            }",
      "        }",
      "        vector<bool> chkA(size(A)), chkB(size(B));",
      "        function<void(int,int)> dfs2 = [&](int x,int team){",
      "            auto&chk = team?chkB:chkA;",
      "            if(chk[x]) return;",
      "            chk[x] = true;",
      "            auto&rg = team?g2:g;",
      "            for(int nx: rg[x])",
      "                if((team == 0 && A[x] != nx) || (team == 1 && B[x] == nx))",
      "                    dfs2(nx, !team);",
      "        };",
      "        for(int i=0;i<size(A);i++)",
      "            if(A[i] == -1)",
      "                dfs2(i, 0);",
      "        vector<pii> ans;",
      "        for(int i=0;i<size(A);i++)",
      "            if(!chkA[i])",
      "                ans.emplace_back(0, i);",
      "        for(int i=0;i<size(B);i++)",
      "            if(chkB[i])",
      "                ans.emplace_back(1, i);",
      "        return ans;",
      "    }",
      "    vector<pii> get_max_independent_set(){",
      "        auto mvc = get_min_vertex_cover();",
      "        vector<bool> chkA(size(A)), chkB(size(B));",
      "        for(auto[c,x]: mvc)",
      "            (c?chkB:chkA)[x] = true;",
      "        vector<pii> ans;",
      "        for(int i=0;i<size(A);i++)",
      "            if(!chkA[i])",
      "                ans.emplace_back(0, i);",
      "        for(int i=0;i<size(B);i++)",
      "            if(!chkB[i])",
      "                ans.emplace_back(1, i);",
      "        return ans;",
      "    }",
      "};"
    ],
    "description": "BipartiteMatching"
  },
  "MaxFlow.cpp": {
    "prefix": "MaxFlow",
    "scope": "cpp",
    "body": [
      "/*",
      "# Max Flow",
      "- mf_graph<int> fg(V = number of vertices)",
      "- fg.add_edge(u, v, cap)",
      "- fg.flow(source, sink, flow_limit = inf)",
      "- fg.min_cut() // flow should be called once, returns vector<bool>, true means in source",
      "- fg.get_edge(i) // returns ith edge added, can see how much flow it",
      "- fg.edges() // returns all edge",
      "- reference: hijkl2e",
      "*/",
      "// using Cap = int;",
      "template<class Cap>",
      "class mf_graph {",
      "private:",
      "\tstruct _edge{ int to; Cap cap;};",
      "    vector<_edge> E; vector<vector<int>> G;",
      "    vector<int> d, last;",
      "    bool bfs(int s, int t) {",
      "        fill(d.begin(), d.end(), -1);",
      "        queue<int> q({s}); d[s] = 0;",
      "        while (q.size()) {",
      "            int u = q.front(); q.pop();",
      "            for (int idx : G[u]) {",
      "                auto &[v, cap] = E[idx];",
      "                if (d[v] == -1 and cap > 0) {",
      "                    d[v] = d[u] + 1;",
      "                    q.push(v);",
      "                    if (v == t) return true;",
      "                }",
      "            }",
      "        }",
      "        return false;",
      "    }",
      "    Cap dfs(int u, int t, Cap f) {",
      "        if (u == t) return f;",
      "        for (int &i = last[u]; i < G[u].size(); ++i) {",
      "            auto &[v, cap] = E[G[u][i]];",
      "            if (d[v] == d[u] + 1 and cap > 0) {",
      "                if (Cap pushed = dfs(v, t, min(f, cap))) {",
      "                    cap -= pushed;",
      "                    auto &rflow = E[G[u][i] ^ 1].cap;",
      "                    rflow += pushed;",
      "                    return pushed;",
      "                }",
      "            }",
      "        }",
      "        return 0;",
      "    }",
      "public:",
      "\tstatic constexpr Cap flow_inf = numeric_limits<Cap>::max();",
      "    // V = number of vertices",
      "    mf_graph(int V = 0) : G(V), d(V), last(V){ }",
      "    // just add 2 directed edges for bidirectional. doesn't matter.",
      "    void add_edge(int u, int v, Cap c) {",
      "\t\tassert(0 <= u and u < V and 0 <= v and v < V and c >= 0);",
      "        G[u].push_back(E.size()); E.push_back({v, c});",
      "        G[v].push_back(E.size()); E.push_back({u, 0});",
      "    }",
      "    Cap flow(int s, int t, Cap flow_limit = flow_inf){",
      "\t\tassert(s != t);",
      "        Cap flow{};",
      "        while (flow < flow_limit) {",
      "            if(bool res = bfs(s, t); not res) break;",
      "            fill(last.begin(), last.end(), 0);",
      "            while (flow < flow_limit) {",
      "                Cap f = dfs(s, t, flow_limit - flow);",
      "                if(not f) break;",
      "                flow += f;",
      "            }",
      "        }",
      "        return flow;",
      "    }",
      "    // flow should be called first, vis[i] = true means i is visited from source",
      "    vector<bool> min_cut(){",
      "        vector<bool> vis(G.size());",
      "        for (int i = 0; i < G.size(); i++)",
      "            vis[i] = (d[i] != -1);",
      "        return vis;",
      "    }",
      "    struct edge{",
      "        int from, to;",
      "        Cap cap, flow;",
      "    };",
      "    edge get_edge(int i){",
      "        i *= 2;",
      "        assert(0 <= i and i < E.size());",
      "        auto[to, cap] = E[i];",
      "        auto[from, rcap] = E[i^1];",
      "        return edge{from, to, cap + rcap, rcap};",
      "    }",
      "\tvector<edge> edges(){",
      "\t\tint m = ssize(E) / 2;",
      "\t\tvector<edge> es(m);",
      "\t\tfor(int i=0;i<m;i++) es[i] = get_edge(i);",
      "\t\treturn move(es);",
      "\t}",
      "    void change_edge(int i, Cap new_cap, Cap new_flow) {",
      "        i *= 2;",
      "        assert(0 <= i and i < E.size());",
      "        assert(0 <= new_flow and new_flow <= new_cap);",
      "        auto& e = E[i];",
      "        auto& re = E[i^1];",
      "        e.cap = new_cap - new_flow;",
      "        re.cap = new_flow;",
      "    }",
      "};"
    ],
    "description": "MaxFlow"
  },
  "MinCostFlow.cpp": {
    "prefix": "MinCostFlow",
    "scope": "cpp",
    "body": [
      "// Edited, source: hijkl2e, https://www.acmicpc.net/source/62155473",
      "// O(VEf) but average O(Ef)",
      "// Test: https://www.acmicpc.net/source/83574185",
      "template<typename Cost = int>",
      "class mcf_graph {",
      "public:",
      "    static constexpr Cost inf = numeric_limits<Cost>::max() / 4;",
      "\tstatic constexpr int iinf = numeric_limits<int>::max() / 2;",
      "    using edge = tuple<int, int, int, Cost>;",
      "    vector<edge> E;",
      "    vector<vector<int>> G;",
      "    vector<int> last;",
      "    vector<bool> vst;",
      "    vector<Cost> d;",
      "    Cost tcost{}, mxcost{};",
      "    mcf_graph(int V) : G(V), d(V), last(V), vst(V){ }",
      "    void add_edge(int u, int v, int cap, Cost cost, bool d = true) {",
      "        G[u].push_back(E.size());",
      "        E.push_back({v, cap, 0, cost});",
      "        G[v].push_back(E.size());",
      "        E.push_back({u, 0, 0, -cost});",
      "        if (!d) add_edge(v, u, cap, cost);",
      "    }",
      "    // put _mxcost = inf for no constrains for _mxcost",
      "    pair<int, Cost> flow(int s, int t, Cost _mxcost = inf) {",
      "        mxcost = _mxcost;",
      "        int mf{};",
      "        while (spfa(s, t)) {",
      "            fill(last.begin(), last.end(), 0);",
      "            while (int f = dfs(s, t, iinf)) {",
      "                mf += f;",
      "            }",
      "        }",
      "        return {mf, tcost};",
      "    }",
      "private:",
      "    bool spfa(int s, int t) {",
      "        fill(d.begin(), d.end(), inf);",
      "        queue<int> q;",
      "        d[s] = 0, vst[s] = true;",
      "        q.push(s);",
      "        while (q.size()) {",
      "            int u = q.front(); q.pop();",
      "            vst[u] = false;",
      "            for (int idx : G[u]) {",
      "                auto &[v, cap, flow, cost] = E[idx];",
      "                if (d[v] > d[u] + cost && flow < cap) {",
      "                    d[v] = d[u] + cost;",
      "                    if (!vst[v]) {",
      "                        vst[v] = true;",
      "                        q.push(v);",
      "                    }",
      "                }",
      "            }",
      "        }",
      "        return d[t] <= mxcost;",
      "    }",
      "    int dfs(int u, int t, int f) {",
      "        if (u == t) {",
      "            return f;",
      "        }",
      "        vst[u] = true;",
      "        for (int &i = last[u]; i < G[u].size(); ++i) {",
      "            auto &[v, cap, flow, cost] = E[G[u][i]];",
      "            if (!vst[v] && d[v] == d[u] + cost && flow < cap) {",
      "                if (int pushed = dfs(v, t, min(f, cap - flow))) {",
      "                    tcost += pushed * cost;",
      "                    flow += pushed;",
      "                    auto &rflow = get<2>(E[G[u][i] ^ 1]);",
      "                    rflow -= pushed;",
      "                    vst[u] = false;",
      "                    return pushed;",
      "                }",
      "            }",
      "        }",
      "        vst[u] = false;",
      "        return 0;",
      "    }",
      "};"
    ],
    "description": "MinCostFlow"
  },
  "cp-geo.cpp": {
    "prefix": "cp-geo",
    "scope": "cpp",
    "body": [
      "// from: https://codeforces.com/contest/1936/submission/249350779",
      "namespace geo { // https://victorlecomte.com/cp-geo.pdf",
      "    using ld = long double;",
      "    const ld inf = 1e100;",
      "    const ld eps = 1e-12;",
      "    const ld PI = acos((ld) -1.0);",
      "    int sign(ld x) { return (x > eps) - (x < -eps); }",
      "    // # POINT START",
      "    struct PT {",
      "        ld x, y;",
      "        PT() { x = 0, y = 0; }",
      "        PT(ld x, ld y) : x(x), y(y) {}",
      "        PT(const PT &p) : x(p.x), y(p.y) {}",
      "        PT operator+(const PT &a) const { return PT(x + a.x, y + a.y); }",
      "        PT operator-(const PT &a) const { return PT(x - a.x, y - a.y); }",
      "        PT operator*(const ld a) const { return PT(x * a, y * a); }",
      "        friend PT operator*(const ld &a, const PT &b) { return PT(a * b.x, a * b.y); }",
      "        PT operator/(const ld a) const { return PT(x / a, y / a); }",
      "        PT& operator+=(const PT &a) { x += a.x; y += a.y; return *this; }",
      "        PT& operator-=(const PT &a) { x -= a.x; y -= a.y; return *this; }",
      "        PT& operator*=(const ld a) { x *= a; y *= a; return *this; }",
      "        PT& operator/=(const ld a) { x /= a; y /= a; return *this; }",
      "        bool operator==(PT a) const { return sign(a.x - x) == 0 && sign(a.y - y) == 0; }",
      "        bool operator!=(PT a) const { return !(*this == a); }",
      "        bool operator<(PT a) const { return sign(a.x - x) == 0 ? y < a.y : x < a.x; }",
      "        bool operator<=(PT a) const { return *this < a or *this == a;}",
      "        bool operator>(PT a) const { return sign(a.x - x) == 0 ? y > a.y : x > a.x; }",
      "        bool operator>=(PT a) const{ return *this > a or *this == a;}",
      "        ld norm() { return sqrt(x * x + y * y); }",
      "        ld norm2() { return x * x + y * y; }",
      "        PT perp() { return PT(-y, x); }",
      "        ld arg() { return atan2(y, x); }",
      "        PT truncate(ld r) { // returns a vector with norm r and having same direction",
      "            ld k = norm();",
      "            if (!sign(k)) return *this;",
      "            r /= k;",
      "            return PT(x * r, y * r);",
      "        }",
      "    };",
      "    istream &operator>>(istream &in, PT &p) { return in >> p.x >> p.y; }",
      "    ostream &operator<<(ostream &out, PT &p) { return out << \"(\" << p.x << \",\" << p.y << \")\"; }",
      "    inline ld dot(PT a, PT b) { return a.x * b.x + a.y * b.y; }",
      "    inline ld dist2(PT a, PT b) { return dot(a - b, a - b); }",
      "    inline ld dist(PT a, PT b) { return sqrt(dot(a - b, a - b)); }",
      "    inline ld cross(PT a, PT b) { return a.x * b.y - a.y * b.x; }",
      "    inline ld cross2(PT a, PT b, PT c) { return cross(b - a, c - a); }",
      "    inline int orientation(PT a, PT b, PT c) { return sign(cross(b - a, c - a)); }",
      "    PT perp(PT a) { return PT(-a.y, a.x); }",
      "    PT rotateccw90(PT a) { return PT(-a.y, a.x); }",
      "    PT rotatecw90(PT a) { return PT(a.y, -a.x); }",
      "    PT rotateccw(PT a, ld t) { return PT(a.x * cos(t) - a.y * sin(t), a.x * sin(t) + a.y * cos(t)); }",
      "    PT rotatecw(PT a, ld t) { return PT(a.x * cos(t) + a.y * sin(t), -a.x * sin(t) + a.y * cos(t)); }",
      "    ld SQ(ld x) { return x * x; }",
      "    ld rad_to_deg(ld r) { return (r * 180.0 / PI); }",
      "    ld deg_to_rad(ld d) { return (d * PI / 180.0); }",
      "    void rad_normalize(ld &ang) { // use division if ang is arbitrally big or small",
      "        while (ang < 0) ang += PI * 2;",
      "        while (ang > 2 * PI) ang -= PI * 2;",
      "    }",
      "    ld get_angle(PT a, PT b) {",
      "        ld costheta = dot(a, b) / a.norm() / b.norm();",
      "        return acos(max((ld) -1.0, min((ld) 1.0, costheta)));",
      "    }",
      "    bool is_point_in_angle(PT b, PT a, PT c, PT p) { // does point p lie in angle <bac",
      "        assert(orientation(a, b, c) != 0);",
      "        if (orientation(a, c, b) < 0) swap(b, c);",
      "        return orientation(a, c, p) >= 0 && orientation(a, b, p) <= 0;",
      "    }",
      "    bool half(PT p) {",
      "        return p.y > 0.0 || (p.y == 0.0 && p.x < 0.0);",
      "    }",
      "    void polar_sort(vector<PT> &v) { // sort points in counterclockwise",
      "        sort(v.begin(), v.end(), [](PT a, PT b) {",
      "            return make_tuple(half(a), 0.0, a.norm2()) < make_tuple(half(b), cross(a, b), b.norm2());",
      "        });",
      "    }",
      "    void polar_sort(vector<PT> &v, PT o) { // sort points in counterclockwise with respect to point o",
      "        sort(v.begin(), v.end(), [&](PT a, PT b) {",
      "            return make_tuple(half(a - o), 0.0, (a - o).norm2()) <",
      "                make_tuple(half(b - o), cross(a - o, b - o), (b - o).norm2());",
      "        });",
      "    }",
      "",
      "    // # LINE START",
      "    struct line {",
      "        PT a, b; // goes through points a and b",
      "        PT v;",
      "        ld c;  //line form: direction vec [cross] (x, y) = c",
      "        line() {}",
      "",
      "        //direction vector v and offset c",
      "        line(PT v, ld c) : v(v), c(c) {",
      "            auto p = get_points();",
      "            a = p.first;",
      "            b = p.second;",
      "        }",
      "",
      "        // equation ax + by + c = 0",
      "        line(ld _a, ld _b, ld _c) : v({_b, -_a}), c(-_c) {",
      "            auto p = get_points();",
      "            a = p.first;",
      "            b = p.second;",
      "        }",
      "",
      "        // goes through points p and q",
      "        line(PT p, PT q) : v(q - p), c(cross(v, p)), a(p), b(q) {}",
      "        pair<PT, PT> get_points() { //extract any two points from this line",
      "            PT p, q;",
      "            ld a = -v.y, b = v.x; // ax + by = c",
      "            if (sign(a) == 0) {",
      "                p = PT(0, c / b);",
      "                q = PT(1, c / b);",
      "            } else if (sign(b) == 0) {",
      "                p = PT(c / a, 0);",
      "                q = PT(c / a, 1);",
      "            } else {",
      "                p = PT(0, c / b);",
      "                q = PT(1, (c - a) / b);",
      "            }",
      "            return {p, q};",
      "        }",
      "",
      "        // ax + by + c = 0",
      "        array<ld, 3> get_abc() {",
      "            ld a = -v.y, b = v.x;",
      "            return {a, b, -c};",
      "        }",
      "",
      "        // 1 if on the left, -1 if on the right, 0 if on the line",
      "        int side(PT p) { return sign(cross(v, p) - c); }",
      "",
      "        // line that is perpendicular to this and goes through point p",
      "        line perpendicular_through(PT p) { return {p, p + perp(v)}; }",
      "",
      "        // translate the line by vector t i.e. shifting it by vector t",
      "        line translate(PT t) { return {v, c + cross(v, t)}; }",
      "",
      "        // compare two points by their orthogonal projection on this line",
      "        // a projection point comes before another if it comes first according to vector v",
      "        bool cmp_by_projection(PT p, PT q) { return dot(v, p) < dot(v, q); }",
      "",
      "        line shift_left(ld d) {",
      "            PT z = v.perp().truncate(d);",
      "            return line(a + z, b + z);",
      "        }",
      "    };",
      "",
      "    // find a point from a through b with distance d",
      "    PT point_along_line(PT a, PT b, ld d) {",
      "        assert(a != b);",
      "        return a + (((b - a) / (b - a).norm()) * d);",
      "    }",
      "",
      "    // projection point c onto line through a and b  assuming a != b",
      "    PT project_from_point_to_line(PT a, PT b, PT c) {",
      "        return a + (b - a) * dot(c - a, b - a) / (b - a).norm2();",
      "    }",
      "",
      "    // reflection point c onto line through a and b  assuming a != b",
      "    PT reflection_from_point_to_line(PT a, PT b, PT c) {",
      "        PT p = project_from_point_to_line(a, b, c);",
      "        return p + p - c;",
      "    }",
      "",
      "    // minimum distance from point c to line through a and b",
      "    ld dist_from_point_to_line(PT a, PT b, PT c) {",
      "        return fabs(cross(b - a, c - a) / (b - a).norm());",
      "    }",
      "",
      "    // returns true if  point p is on line segment ab",
      "    bool is_point_on_seg(PT a, PT b, PT p) {",
      "        if (fabs(cross(p - b, a - b)) < eps) {",
      "            if (p.x < min(a.x, b.x) - eps || p.x > max(a.x, b.x) + eps) return false;",
      "            if (p.y < min(a.y, b.y) - eps || p.y > max(a.y, b.y) + eps) return false;",
      "            return true;",
      "        }",
      "        return false;",
      "    }",
      "",
      "    // minimum distance point from point c to segment ab that lies on segment ab",
      "    PT project_from_point_to_seg(PT a, PT b, PT c) {",
      "        ld r = dist2(a, b);",
      "        if (sign(r) == 0) return a;",
      "        r = dot(c - a, b - a) / r;",
      "        if (r < 0) return a;",
      "        if (r > 1) return b;",
      "        return a + (b - a) * r;",
      "    }",
      "",
      "    // minimum distance from point c to segment ab",
      "    ld dist_from_point_to_seg(PT a, PT b, PT c) {",
      "        return dist(c, project_from_point_to_seg(a, b, c));",
      "    }",
      "",
      "    // 0 if not parallel, 1 if parallel, 2 if collinear",
      "    int is_parallel(PT a, PT b, PT c, PT d) {",
      "        ld k = fabs(cross(b - a, d - c));",
      "        if (k < eps) {",
      "            if (fabs(cross(a - b, a - c)) < eps && fabs(cross(c - d, c - a)) < eps) return 2;",
      "            else return 1;",
      "        } else return 0;",
      "    }",
      "",
      "    // check if two lines are same",
      "    bool are_lines_same(PT a, PT b, PT c, PT d) {",
      "        if (fabs(cross(a - c, c - d)) < eps && fabs(cross(b - c, c - d)) < eps) return true;",
      "        return false;",
      "    }",
      "",
      "    // bisector vector of <abc",
      "    PT angle_bisector(PT &a, PT &b, PT &c) {",
      "        PT p = a - b, q = c - b;",
      "        return p + q * sqrt(dot(p, p) / dot(q, q));",
      "    }",
      "",
      "    // 1 if point is ccw to the line, 2 if point is cw to the line, 3 if point is on the line",
      "    int point_line_relation(PT a, PT b, PT p) {",
      "        int c = sign(cross(p - a, b - a));",
      "        if (c < 0) return 1;",
      "        if (c > 0) return 2;",
      "        return 3;",
      "    }",
      "",
      "    // -1 if outside to point a, 0 if between a and b (inclusive), 1 if outside to point b",
      "    int point_seg_relation(PT a, PT b, PT p){",
      "        assert(point_line_relation(a, b, p) == 3 && \"point should be on line\");",
      "        int flag = 1;",
      "        if(a > b) swap(a, b), flag = -1;",
      "        if(a <= p and p <= b) return 0;",
      "        if(p < a) return flag * -1;",
      "        else return flag;",
      "    }",
      "",
      "    // intersection point between ab and cd assuming unique intersection exists",
      "    bool line_line_intersection(PT a, PT b, PT c, PT d, PT &ans) {",
      "        ld a1 = a.y - b.y, b1 = b.x - a.x, c1 = cross(a, b);",
      "        ld a2 = c.y - d.y, b2 = d.x - c.x, c2 = cross(c, d);",
      "        ld det = a1 * b2 - a2 * b1;",
      "        if (det == 0) return 0;",
      "        ans = PT((b1 * c2 - b2 * c1) / det, (c1 * a2 - a1 * c2) / det);",
      "        return 1;",
      "    }",
      "",
      "    // intersection point between segment ab and segment cd assuming unique intersection exists",
      "    bool seg_seg_intersection(PT a, PT b, PT c, PT d, PT &ans) {",
      "        ld oa = cross2(c, d, a), ob = cross2(c, d, b);",
      "        ld oc = cross2(a, b, c), od = cross2(a, b, d);",
      "        if (oa * ob < 0 && oc * od < 0) {",
      "            ans = (a * ob - b * oa) / (ob - oa);",
      "            return 1;",
      "        } else return 0;",
      "    }",
      "",
      "// intersection point between segment ab and segment cd assuming unique intersection may not exists",
      "// se.size()==0 means no intersection",
      "// se.size()==1 means one intersection",
      "// se.size()==2 means range intersection",
      "    set<PT> seg_seg_intersection_inside(PT a, PT b, PT c, PT d) {",
      "        PT ans;",
      "        if (seg_seg_intersection(a, b, c, d, ans)) return {ans};",
      "        set<PT> se;",
      "        if (is_point_on_seg(c, d, a)) se.insert(a);",
      "        if (is_point_on_seg(c, d, b)) se.insert(b);",
      "        if (is_point_on_seg(a, b, c)) se.insert(c);",
      "        if (is_point_on_seg(a, b, d)) se.insert(d);",
      "        return se;",
      "    }",
      "",
      "// intersection  between segment ab and line cd",
      "// 0 if do not intersect, 1 if proper intersect, 2 if segment intersect",
      "    int seg_line_relation(PT a, PT b, PT c, PT d) {",
      "        ld p = cross2(c, d, a);",
      "        ld q = cross2(c, d, b);",
      "        if (sign(p) == 0 && sign(q) == 0) return 2;",
      "        else if (p * q < 0) return 1;",
      "        else return 0;",
      "    }",
      "",
      "// intersection between segament ab and line cd assuming unique intersection exists",
      "    bool seg_line_intersection(PT a, PT b, PT c, PT d, PT &ans) {",
      "        bool k = seg_line_relation(a, b, c, d);",
      "        assert(k != 2);",
      "        if (k) line_line_intersection(a, b, c, d, ans);",
      "        return k;",
      "    }",
      "",
      "// minimum distance from segment ab to segment cd",
      "    ld dist_from_seg_to_seg(PT a, PT b, PT c, PT d) {",
      "        PT dummy;",
      "        if (seg_seg_intersection(a, b, c, d, dummy)) return 0.0;",
      "        else",
      "            return min({dist_from_point_to_seg(a, b, c), dist_from_point_to_seg(a, b, d),",
      "                        dist_from_point_to_seg(c, d, a), dist_from_point_to_seg(c, d, b)});",
      "    }",
      "",
      "// minimum distance from point c to ray (starting point a and direction vector b)",
      "    ld dist_from_point_to_ray(PT a, PT b, PT c) {",
      "        b = a + b;",
      "        ld r = dot(c - a, b - a);",
      "        if (r < 0.0) return dist(c, a);",
      "        return dist_from_point_to_line(a, b, c);",
      "    }",
      "",
      "// starting point as and direction vector ad",
      "    bool ray_ray_intersection(PT as, PT ad, PT bs, PT bd) {",
      "        ld dx = bs.x - as.x, dy = bs.y - as.y;",
      "        ld det = bd.x * ad.y - bd.y * ad.x;",
      "        if (fabs(det) < eps) return 0;",
      "        ld u = (dy * bd.x - dx * bd.y) / det;",
      "        ld v = (dy * ad.x - dx * ad.y) / det;",
      "        if (sign(u) >= 0 && sign(v) >= 0) return 1;",
      "        else return 0;",
      "    }",
      "    ld ray_ray_distance(PT as, PT ad, PT bs, PT bd) {",
      "        if (ray_ray_intersection(as, ad, bs, bd)) return 0.0;",
      "        ld ans = dist_from_point_to_ray(as, ad, bs);",
      "        ans = min(ans, dist_from_point_to_ray(bs, bd, as));",
      "        return ans;",
      "    }",
      "",
      "    // # CIRCLE START",
      "    struct circle {",
      "        PT p;",
      "        ld r;",
      "",
      "        circle() {}",
      "",
      "        circle(PT _p, ld _r) : p(_p), r(_r) {};",
      "",
      "        // center (x, y) and radius r",
      "        circle(ld x, ld y, ld _r) : p(PT(x, y)), r(_r) {};",
      "",
      "        // circumcircle of a triangle",
      "        // the three points must be unique",
      "        circle(PT a, PT b, PT c) {",
      "            b = (a + b) * 0.5;",
      "            c = (a + c) * 0.5;",
      "            line_line_intersection(b, b + rotatecw90(a - b), c, c + rotatecw90(a - c), p);",
      "            r = dist(a, p);",
      "        }",
      "",
      "        // inscribed circle of a triangle",
      "        // pass a bool just to differentiate from circumcircle",
      "        circle(PT a, PT b, PT c, bool t) {",
      "            line u, v;",
      "            ld m = atan2(b.y - a.y, b.x - a.x), n = atan2(c.y - a.y, c.x - a.x);",
      "            u.a = a;",
      "            u.b = u.a + (PT(cos((n + m) / 2.0), sin((n + m) / 2.0)));",
      "            v.a = b;",
      "            m = atan2(a.y - b.y, a.x - b.x), n = atan2(c.y - b.y, c.x - b.x);",
      "            v.b = v.a + (PT(cos((n + m) / 2.0), sin((n + m) / 2.0)));",
      "            line_line_intersection(u.a, u.b, v.a, v.b, p);",
      "            r = dist_from_point_to_seg(a, b, p);",
      "        }",
      "",
      "        bool operator==(circle v) { return p == v.p && sign(r - v.r) == 0; }",
      "",
      "        ld area() { return PI * r * r; }",
      "",
      "        ld circumference() { return 2.0 * PI * r; }",
      "    };",
      "",
      "    //0 if outside, 1 if on circumference, 2 if inside circle",
      "    int circle_point_relation(PT p, ld r, PT b) {",
      "        ld d = dist(p, b);",
      "        if (sign(d - r) < 0) return 2;",
      "        if (sign(d - r) == 0) return 1;",
      "        return 0;",
      "    }",
      "",
      "    // 0 if outside, 1 if on circumference, 2 if inside circle",
      "    int circle_line_relation(PT p, ld r, PT a, PT b) {",
      "        ld d = dist_from_point_to_line(a, b, p);",
      "        if (sign(d - r) < 0) return 2;",
      "        if (sign(d - r) == 0) return 1;",
      "        return 0;",
      "    }",
      "",
      "    //compute intersection of line through points a and b with",
      "    //circle centered at c with radius r > 0",
      "    vector<PT> circle_line_intersection(PT c, ld r, PT a, PT b) {",
      "        vector<PT> ret;",
      "        b = b - a;",
      "        a = a - c;",
      "        ld A = dot(b, b), B = dot(a, b);",
      "        ld C = dot(a, a) - r * r, D = B * B - A * C;",
      "        if (D < -eps) return ret;",
      "        ret.push_back(c + a + b * (-B + sqrt(D + eps)) / A);",
      "        if (D > eps) ret.push_back(c + a + b * (-B - sqrt(D)) / A);",
      "        return ret;",
      "    }",
      "",
      "    //5 - outside and do not intersect",
      "    //4 - intersect outside in one point",
      "    //3 - intersect in 2 points",
      "    //2 - intersect inside in one point",
      "    //1 - inside and do not intersect",
      "    int circle_circle_relation(PT a, ld r, PT b, ld R) {",
      "        ld d = dist(a, b);",
      "        if (sign(d - r - R) > 0) return 5;",
      "        if (sign(d - r - R) == 0) return 4;",
      "        ld l = fabs(r - R);",
      "        if (sign(d - r - R) < 0 && sign(d - l) > 0) return 3;",
      "        if (sign(d - l) == 0) return 2;",
      "        if (sign(d - l) < 0) return 1;",
      "        assert(0);",
      "        return -1;",
      "    }",
      "",
      "    vector<PT> circle_circle_intersection(PT a, ld r, PT b, ld R) {",
      "        if (a == b && sign(r - R) == 0) return {PT(1e18, 1e18)};",
      "        vector<PT> ret;",
      "        ld d = sqrt(dist2(a, b));",
      "        if (d > r + R || d + min(r, R) < max(r, R)) return ret;",
      "        ld x = (d * d - R * R + r * r) / (2 * d);",
      "        ld y = sqrt(r * r - x * x);",
      "        PT v = (b - a) / d;",
      "        ret.push_back(a + v * x + rotateccw90(v) * y);",
      "        if (y > 0) ret.push_back(a + v * x - rotateccw90(v) * y);",
      "        return ret;",
      "    }",
      "",
      "    // returns two circle c1, c2 through points a, b and of radius r",
      "    // 0 if there is no such circle, 1 if one circle, 2 if two circle",
      "    int get_circle(PT a, PT b, ld r, circle &c1, circle &c2) {",
      "        vector<PT> v = circle_circle_intersection(a, r, b, r);",
      "        int t = v.size();",
      "        if (!t) return 0;",
      "        c1.p = v[0], c1.r = r;",
      "        if (t == 2) c2.p = v[1], c2.r = r;",
      "        return t;",
      "    }",
      "",
      "    // returns two circle c1, c2 which is tangent to line u,  goes through",
      "    // point q and has radius r1; 0 for no circle, 1 if c1 = c2 , 2 if c1 != c2",
      "    int get_circle(line u, PT q, ld r1, circle &c1, circle &c2) {",
      "        ld d = dist_from_point_to_line(u.a, u.b, q);",
      "        if (sign(d - r1 * 2.0) > 0) return 0;",
      "        if (sign(d) == 0) {",
      "            cout << u.v.x << ' ' << u.v.y << '\\n';",
      "            c1.p = q + rotateccw90(u.v).truncate(r1);",
      "            c2.p = q + rotatecw90(u.v).truncate(r1);",
      "            c1.r = c2.r = r1;",
      "            return 2;",
      "        }",
      "        line u1 = line(u.a + rotateccw90(u.v).truncate(r1), u.b + rotateccw90(u.v).truncate(r1));",
      "        line u2 = line(u.a + rotatecw90(u.v).truncate(r1), u.b + rotatecw90(u.v).truncate(r1));",
      "        circle cc = circle(q, r1);",
      "        PT p1, p2;",
      "        vector<PT> v;",
      "        v = circle_line_intersection(q, r1, u1.a, u1.b);",
      "        if (!v.size()) v = circle_line_intersection(q, r1, u2.a, u2.b);",
      "        v.push_back(v[0]);",
      "        p1 = v[0], p2 = v[1];",
      "        c1 = circle(p1, r1);",
      "        if (p1 == p2) {",
      "            c2 = c1;",
      "            return 1;",
      "        }",
      "        c2 = circle(p2, r1);",
      "        return 2;",
      "    }",
      "",
      "    // returns the circle such that for all points w on the circumference of the circle",
      "    // dist(w, a) : dist(w, b) = rp : rq",
      "    // rp != rq",
      "    // https://en.wikipedia.org/wiki/Circles_of_Apollonius",
      "    circle get_apollonius_circle(PT p, PT q, ld rp, ld rq) {",
      "        rq *= rq;",
      "        rp *= rp;",
      "        ld a = rq - rp;",
      "        assert(sign(a));",
      "        ld g = rq * p.x - rp * q.x;",
      "        g /= a;",
      "        ld h = rq * p.y - rp * q.y;",
      "        h /= a;",
      "        ld c = rq * p.x * p.x - rp * q.x * q.x + rq * p.y * p.y - rp * q.y * q.y;",
      "        c /= a;",
      "        PT o(g, h);",
      "        ld r = g * g + h * h - c;",
      "        r = sqrt(r);",
      "        return circle(o, r);",
      "    }",
      "",
      "    // returns area of intersection between two circles",
      "    ld circle_circle_area(PT a, ld r1, PT b, ld r2) {",
      "        ld d = (a - b).norm();",
      "        if (r1 + r2 < d + eps) return 0;",
      "        if (r1 + d < r2 + eps) return PI * r1 * r1;",
      "        if (r2 + d < r1 + eps) return PI * r2 * r2;",
      "        ld theta_1 = acos((r1 * r1 + d * d - r2 * r2) / (2 * r1 * d)),",
      "                theta_2 = acos((r2 * r2 + d * d - r1 * r1) / (2 * r2 * d));",
      "        return r1 * r1 * (theta_1 - sin(2 * theta_1) / 2.) + r2 * r2 * (theta_2 - sin(2 * theta_2) / 2.);",
      "    }",
      "",
      "    // tangent lines from point q to the circle",
      "    int tangent_lines_from_point(PT p, ld r, PT q, line &u, line &v) {",
      "        int x = sign(dist2(p, q) - r * r);",
      "        if (x < 0) return 0; // point in cricle",
      "        if (x == 0) { // point on circle",
      "            u = line(q, q + rotateccw90(q - p));",
      "            v = u;",
      "            return 1;",
      "        }",
      "        ld d = dist(p, q);",
      "        ld l = r * r / d;",
      "        ld h = sqrt(r * r - l * l);",
      "        u = line(q, p + ((q - p).truncate(l) + (rotateccw90(q - p).truncate(h))));",
      "        v = line(q, p + ((q - p).truncate(l) + (rotatecw90(q - p).truncate(h))));",
      "        return 2;",
      "    }",
      "",
      "    // returns outer tangents line of two circles",
      "    // if inner == 1 it returns inner tangent lines",
      "    int tangents_lines_from_circle(PT c1, ld r1, PT c2, ld r2, bool inner, line &u, line &v) {",
      "        if (inner) r2 = -r2;",
      "        PT d = c2 - c1;",
      "        ld dr = r1 - r2, d2 = d.norm2(), h2 = d2 - dr * dr;",
      "        if (d2 == 0 || h2 < 0) {",
      "            assert(h2 != 0);",
      "            return 0;",
      "        }",
      "        vector<pair<PT, PT>> out;",
      "        for (int tmp: {-1, 1}) {",
      "            PT v = (d * dr + rotateccw90(d) * sqrt(h2) * tmp) / d2;",
      "            out.push_back({c1 + v * r1, c2 + v * r2});",
      "        }",
      "        u = line(out[0].first, out[0].second);",
      "        if (out.size() == 2) v = line(out[1].first, out[1].second);",
      "        return 1 + (h2 > 0);",
      "    }",
      "",
      "    // O(n^2 log n)",
      "    // https://vjudge.net/problem/UVA-12056",
      "    constexpr int MX_UNION = 2020;",
      "    struct CircleUnion {",
      "        int n;",
      "        ld x[MX_UNION], y[MX_UNION], r[MX_UNION];",
      "        int covered[MX_UNION];",
      "        vector<pair<ld, ld> > seg, cover;",
      "        ld arc, pol;",
      "        inline int sign(ld x) { return x < -eps ? -1 : x > eps; }",
      "        inline int sign(ld x, ld y) { return sign(x - y); }",
      "        inline ld SQ(const ld x) { return x * x; }",
      "        inline ld dist(ld x1, ld y1, ld x2, ld y2) { return sqrt(SQ(x1 - x2) + SQ(y1 - y2)); }",
      "        inline ld angle(ld A, ld B, ld C) {",
      "            ld val = (SQ(A) + SQ(B) - SQ(C)) / (2 * A * B);",
      "            if (val < -1) val = -1;",
      "            if (val > +1) val = +1;",
      "            return acos(val);",
      "        }",
      "        CircleUnion() {",
      "            n = 0;",
      "            seg.clear(), cover.clear();",
      "            arc = pol = 0;",
      "        }",
      "        void init() {",
      "            n = 0;",
      "            seg.clear(), cover.clear();",
      "            arc = pol = 0;",
      "        }",
      "        void add(ld xx, ld yy, ld rr) {",
      "            x[n] = xx, y[n] = yy, r[n] = rr, covered[n] = 0, n++;",
      "        }",
      "        void getarea(int i, ld lef, ld rig) {",
      "            arc += 0.5 * r[i] * r[i] * (rig - lef - sin(rig - lef));",
      "            ld x1 = x[i] + r[i] * cos(lef), y1 = y[i] + r[i] * sin(lef);",
      "            ld x2 = x[i] + r[i] * cos(rig), y2 = y[i] + r[i] * sin(rig);",
      "            pol += x1 * y2 - x2 * y1;",
      "        }",
      "        ld solve() {",
      "            for (int i = 0; i < n; i++) {",
      "                for (int j = 0; j < i; j++) {",
      "                    if (!sign(x[i] - x[j]) && !sign(y[i] - y[j]) && !sign(r[i] - r[j])) {",
      "                        r[i] = 0.0;",
      "                        break;",
      "                    }",
      "                }",
      "            }",
      "            for (int i = 0; i < n; i++) {",
      "                for (int j = 0; j < n; j++) {",
      "                    if (i != j && sign(r[j] - r[i]) >= 0 && sign(dist(x[i], y[i], x[j], y[j]) - (r[j] - r[i])) <= 0) {",
      "                        covered[i] = 1;",
      "                        break;",
      "                    }",
      "                }",
      "            }",
      "            for (int i = 0; i < n; i++) {",
      "                if (sign(r[i]) && !covered[i]) {",
      "                    seg.clear();",
      "                    for (int j = 0; j < n; j++) {",
      "                        if (i != j) {",
      "                            ld d = dist(x[i], y[i], x[j], y[j]);",
      "                            if (sign(d - (r[j] + r[i])) >= 0 || sign(d - abs(r[j] - r[i])) <= 0) {",
      "                                continue;",
      "                            }",
      "                            ld alpha = atan2(y[j] - y[i], x[j] - x[i]);",
      "                            ld beta = angle(r[i], d, r[j]);",
      "                            pair<ld, ld> tmp(alpha - beta, alpha + beta);",
      "                            if (sign(tmp.first) <= 0 && sign(tmp.second) <= 0) {",
      "                                seg.push_back(pair<ld, ld>(2 * PI + tmp.first, 2 * PI + tmp.second));",
      "                            } else if (sign(tmp.first) < 0) {",
      "                                seg.push_back(pair<ld, ld>(2 * PI + tmp.first, 2 * PI));",
      "                                seg.push_back(pair<ld, ld>(0, tmp.second));",
      "                            } else {",
      "                                seg.push_back(tmp);",
      "                            }",
      "                        }",
      "                    }",
      "                    sort(seg.begin(), seg.end());",
      "                    ld rig = 0;",
      "                    for (vector<pair<ld, ld> >::iterator iter = seg.begin(); iter != seg.end(); iter++) {",
      "                        if (sign(rig - iter->first) >= 0) {",
      "                            rig = max(rig, iter->second);",
      "                        } else {",
      "                            getarea(i, rig, iter->first);",
      "                            rig = iter->second;",
      "                        }",
      "                    }",
      "                    if (!sign(rig)) {",
      "                        arc += r[i] * r[i] * PI;",
      "                    } else {",
      "                        getarea(i, rig, 2 * PI);",
      "                    }",
      "                }",
      "            }",
      "            return pol / 2.0 + arc;",
      "        }",
      "    } CU;",
      "",
      "    // # POLYGON START",
      "",
      "    ld area_of_triangle(PT a, PT b, PT c) {",
      "        return fabs(cross(b - a, c - a) * 0.5);",
      "    }",
      "",
      "    // -1 if strictly inside, 0 if on the polygon, 1 if strictly outside",
      "    int is_point_in_triangle(PT a, PT b, PT c, PT p) {",
      "        if (sign(cross(b - a, c - a)) < 0) swap(b, c);",
      "        int c1 = sign(cross(b - a, p - a));",
      "        int c2 = sign(cross(c - b, p - b));",
      "        int c3 = sign(cross(a - c, p - c));",
      "        if (c1 < 0 || c2 < 0 || c3 < 0) return 1;",
      "        if (c1 + c2 + c3 != 3) return 0;",
      "        return -1;",
      "    }",
      "",
      "    ld perimeter(vector<PT> &p) {",
      "        ld ans = 0;",
      "        int n = p.size();",
      "        for (int i = 0; i < n; i++) ans += dist(p[i], p[(i + 1) % n]);",
      "        return ans;",
      "    }",
      "",
      "    ld area(vector<PT> &p) {",
      "        ld ans = 0;",
      "        int n = p.size();",
      "        for (int i = 0; i < n; i++) ans += cross(p[i], p[(i + 1) % n]);",
      "        return fabs(ans) * 0.5;",
      "    }",
      "",
      "    // centroid of a (possibly non-convex) polygon,",
      "    // assuming that the coordinates are listed in a clockwise or",
      "    // counterclockwise fashion.  Note that the centroid is often known as",
      "    // the \"center of gravity\" or \"center of mass\".",
      "    PT centroid(vector<PT> &p) {",
      "        int n = p.size();",
      "        PT c(0, 0);",
      "        ld sum = 0;",
      "        for (int i = 0; i < n; i++) sum += cross(p[i], p[(i + 1) % n]);",
      "        ld scale = 3.0 * sum;",
      "        for (int i = 0; i < n; i++) {",
      "            int j = (i + 1) % n;",
      "            c = c + (p[i] + p[j]) * cross(p[i], p[j]);",
      "        }",
      "        return c / scale;",
      "    }",
      "",
      "    // 0 if cw, 1 if ccw",
      "    bool get_direction(vector<PT> &p) {",
      "        ld ans = 0;",
      "        int n = p.size();",
      "        for (int i = 0; i < n; i++) ans += cross(p[i], p[(i + 1) % n]);",
      "        if (sign(ans) > 0) return 1;",
      "        return 0;",
      "    }",
      "",
      "    // it returns a point such that the sum of distances",
      "    // from that point to all points in p  is minimum",
      "    // O(n log^2 MX)",
      "    PT geometric_median(vector<PT> p) {",
      "        auto tot_dist = [&](PT z) {",
      "            ld res = 0;",
      "            for (int i = 0; i < p.size(); i++) res += dist(p[i], z);",
      "            return res;",
      "        };",
      "        auto findY = [&](ld x) {",
      "            ld yl = -1e5, yr = 1e5;",
      "            for (int i = 0; i < 60; i++) {",
      "                ld ym1 = yl + (yr - yl) / 3;",
      "                ld ym2 = yr - (yr - yl) / 3;",
      "                ld d1 = tot_dist(PT(x, ym1));",
      "                ld d2 = tot_dist(PT(x, ym2));",
      "                if (d1 < d2) yr = ym2;",
      "                else yl = ym1;",
      "            }",
      "            return pair<ld, ld>(yl, tot_dist(PT(x, yl)));",
      "        };",
      "        ld xl = -1e5, xr = 1e5;",
      "        for (int i = 0; i < 60; i++) {",
      "            ld xm1 = xl + (xr - xl) / 3;",
      "            ld xm2 = xr - (xr - xl) / 3;",
      "            ld y1, d1, y2, d2;",
      "            auto z = findY(xm1);",
      "            y1 = z.first;",
      "            d1 = z.second;",
      "            z = findY(xm2);",
      "            y2 = z.first;",
      "            d2 = z.second;",
      "            if (d1 < d2) xr = xm2;",
      "            else xl = xm1;",
      "        }",
      "        return {xl, findY(xl).first};",
      "    }",
      "",
      "    vector<PT> convex_hull(vector<PT> &p) {",
      "        if (p.size() <= 1) return p;",
      "        vector<PT> v = p;",
      "        sort(v.begin(), v.end());",
      "        vector<PT> up, dn;",
      "        for (auto &p: v) {",
      "            while (up.size() > 1 && orientation(up[up.size() - 2], up.back(), p) >= 0) {",
      "                up.pop_back();",
      "            }",
      "            while (dn.size() > 1 && orientation(dn[dn.size() - 2], dn.back(), p) <= 0) {",
      "                dn.pop_back();",
      "            }",
      "            up.push_back(p);",
      "            dn.push_back(p);",
      "        }",
      "        v = dn;",
      "        if (v.size() > 1) v.pop_back();",
      "        reverse(up.begin(), up.end());",
      "        up.pop_back();",
      "        for (auto &p: up) {",
      "            v.push_back(p);",
      "        }",
      "        if (v.size() == 2 && v[0] == v[1]) v.pop_back();",
      "        return v;",
      "    }",
      "",
      "    //checks if convex or not",
      "    bool is_convex(vector<PT> &p) {",
      "        bool s[3];",
      "        s[0] = s[1] = s[2] = 0;",
      "        int n = p.size();",
      "        for (int i = 0; i < n; i++) {",
      "            int j = (i + 1) % n;",
      "            int k = (j + 1) % n;",
      "            s[sign(cross(p[j] - p[i], p[k] - p[i])) + 1] = 1;",
      "            if (s[0] && s[2]) return 0;",
      "        }",
      "        return 1;",
      "    }",
      "",
      "    // -1 if strictly inside, 0 if on the polygon, 1 if strictly outside",
      "    // it must be strictly convex, otherwise make it strictly convex first",
      "    int is_point_in_convex(vector<PT> &p, const PT &x) { // O(log n)",
      "        int n = p.size();",
      "        assert(n >= 3);",
      "        int a = orientation(p[0], p[1], x), b = orientation(p[0], p[n - 1], x);",
      "        if (a < 0 || b > 0) return 1;",
      "        int l = 1, r = n - 1;",
      "        while (l + 1 < r) {",
      "            int mid = l + r >> 1;",
      "            if (orientation(p[0], p[mid], x) >= 0) l = mid;",
      "            else r = mid;",
      "        }",
      "        int k = orientation(p[l], p[r], x);",
      "        if (k <= 0) return -k;",
      "        if (l == 1 && a == 0) return 0;",
      "        if (r == n - 1 && b == 0) return 0;",
      "        return -1;",
      "    }",
      "",
      "    bool is_point_on_polygon(vector<PT> &p, const PT &z) {",
      "        int n = p.size();",
      "        for (int i = 0; i < n; i++) {",
      "            if (is_point_on_seg(p[i], p[(i + 1) % n], z)) return 1;",
      "        }",
      "        return 0;",
      "    }",
      "",
      "    // returns 1e9 if the point is on the polygon",
      "    int winding_number(vector<PT> &p, const PT &z) { // O(n)",
      "        if (is_point_on_polygon(p, z)) return 1e9;",
      "        int n = p.size(), ans = 0;",
      "        for (int i = 0; i < n; ++i) {",
      "            int j = (i + 1) % n;",
      "            bool below = p[i].y < z.y;",
      "            if (below != (p[j].y < z.y)) {",
      "                auto orient = orientation(z, p[j], p[i]);",
      "                if (orient == 0) return 0;",
      "                if (below == (orient > 0)) ans += below ? 1 : -1;",
      "            }",
      "        }",
      "        return ans;",
      "    }",
      "",
      "    // -1 if strictly inside, 0 if on the polygon, 1 if strictly outside",
      "    int is_point_in_polygon(vector<PT> &p, const PT &z) { // O(n)",
      "        int k = winding_number(p, z);",
      "        return k == 1e9 ? 0 : k == 0 ? 1 : -1;",
      "    }",
      "",
      "    // id of the vertex having maximum dot product with z",
      "    // polygon must need to be convex",
      "    // top - upper right vertex",
      "    // for minimum dot product negate z and return -dot(z, p[id])",
      "    int extreme_vertex(vector<PT> &p, const PT &z, const int top) { // O(log n)",
      "        int n = p.size();",
      "        if (n == 1) return 0;",
      "        ld ans = dot(p[0], z);",
      "        int id = 0;",
      "        if (dot(p[top], z) > ans) ans = dot(p[top], z), id = top;",
      "        int l = 1, r = top - 1;",
      "        while (l < r) {",
      "            int mid = l + r >> 1;",
      "            if (dot(p[mid + 1], z) >= dot(p[mid], z)) l = mid + 1;",
      "            else r = mid;",
      "        }",
      "        if (dot(p[l], z) > ans) ans = dot(p[l], z), id = l;",
      "        l = top + 1, r = n - 1;",
      "        while (l < r) {",
      "            int mid = l + r >> 1;",
      "            if (dot(p[(mid + 1) % n], z) >= dot(p[mid], z)) l = mid + 1;",
      "            else r = mid;",
      "        }",
      "        l %= n;",
      "        if (dot(p[l], z) > ans) ans = dot(p[l], z), id = l;",
      "        return id;",
      "    }",
      "",
      "    // maximum distance from any point on the perimeter to another point on the perimeter",
      "    ld diameter(vector<PT> &p) {",
      "        int n = (int) p.size();",
      "        if (n == 1) return 0;",
      "        if (n == 2) return dist(p[0], p[1]);",
      "        ld ans = 0;",
      "        int i = 0, j = 1;",
      "        while (i < n) {",
      "            while (cross(p[(i + 1) % n] - p[i], p[(j + 1) % n] - p[j]) >= 0) {",
      "                ans = max(ans, dist2(p[i], p[j]));",
      "                j = (j + 1) % n;",
      "            }",
      "            ans = max(ans, dist2(p[i], p[j]));",
      "            i++;",
      "        }",
      "        return sqrt(ans);",
      "    }",
      "",
      "    // minimum distance between two parallel lines (non necessarily axis parallel)",
      "    // such that the polygon can be put between the lines",
      "    ld width(vector<PT> &p) {",
      "        int n = (int) p.size();",
      "        if (n <= 2) return 0;",
      "        ld ans = inf;",
      "        int i = 0, j = 1;",
      "        while (i < n) {",
      "            while (cross(p[(i + 1) % n] - p[i], p[(j + 1) % n] - p[j]) >= 0) j = (j + 1) % n;",
      "            ans = min(ans, dist_from_point_to_line(p[i], p[(i + 1) % n], p[j]));",
      "            i++;",
      "        }",
      "        return ans;",
      "    }",
      "",
      "    // minimum perimeter",
      "    ld minimum_enclosing_rectangle(vector<PT> &p) {",
      "        int n = p.size();",
      "        if (n <= 2) return perimeter(p);",
      "        int mndot = 0;",
      "        ld tmp = dot(p[1] - p[0], p[0]);",
      "        for (int i = 1; i < n; i++) {",
      "            if (dot(p[1] - p[0], p[i]) <= tmp) {",
      "                tmp = dot(p[1] - p[0], p[i]);",
      "                mndot = i;",
      "            }",
      "        }",
      "        ld ans = inf;",
      "        int i = 0, j = 1, mxdot = 1;",
      "        while (i < n) {",
      "            PT cur = p[(i + 1) % n] - p[i];",
      "            while (cross(cur, p[(j + 1) % n] - p[j]) >= 0) j = (j + 1) % n;",
      "            while (dot(p[(mxdot + 1) % n], cur) >= dot(p[mxdot], cur)) mxdot = (mxdot + 1) % n;",
      "            while (dot(p[(mndot + 1) % n], cur) <= dot(p[mndot], cur)) mndot = (mndot + 1) % n;",
      "            ans = min(ans,(ld) (2.0 * ((dot(p[mxdot], cur) / cur.norm() - dot(p[mndot], cur) / cur.norm()) +",
      "                                dist_from_point_to_line(p[i], p[(i + 1) % n], p[j])) ));",
      "            i++;",
      "        }",
      "        return ans;",
      "    }",
      "",
      "    // given n points, find the minimum enclosing circle of the points",
      "    // call convex_hull() before this for faster solution",
      "    // expected O(n)",
      "    circle minimum_enclosing_circle(vector<PT> &p) {",
      "        srand(time(NULL));",
      "        random_shuffle(p.begin(), p.end());",
      "        int n = p.size();",
      "        circle c(p[0], 0);",
      "        for (int i = 1; i < n; i++) {",
      "            if (sign(dist(c.p, p[i]) - c.r) > 0) {",
      "                c = circle(p[i], 0);",
      "                for (int j = 0; j < i; j++) {",
      "                    if (sign(dist(c.p, p[j]) - c.r) > 0) {",
      "                        c = circle((p[i] + p[j]) / 2, dist(p[i], p[j]) / 2);",
      "                        for (int k = 0; k < j; k++) {",
      "                            if (sign(dist(c.p, p[k]) - c.r) > 0) {",
      "                                c = circle(p[i], p[j], p[k]);",
      "                            }",
      "                        }",
      "                    }",
      "                }",
      "            }",
      "        }",
      "        return c;",
      "    }",
      "",
      "    // returns a vector with the vertices of a polygon with everything",
      "    // to the left of the line going from a to b cut away.",
      "    vector<PT> cut(vector<PT> &p, PT a, PT b) {",
      "        vector<PT> ans;",
      "        int n = (int) p.size();",
      "        for (int i = 0; i < n; i++) {",
      "            ld c1 = cross(b - a, p[i] - a);",
      "            ld c2 = cross(b - a, p[(i + 1) % n] - a);",
      "            if (sign(c1) >= 0) ans.push_back(p[i]);",
      "            if (sign(c1 * c2) < 0) {",
      "                if (!is_parallel(p[i], p[(i + 1) % n], a, b)) {",
      "                    PT tmp;",
      "                    line_line_intersection(p[i], p[(i + 1) % n], a, b, tmp);",
      "                    ans.push_back(tmp);",
      "                }",
      "            }",
      "        }",
      "        return ans;",
      "    }",
      "",
      "    // not necessarily convex, boundary is included in the intersection",
      "    // returns total intersected length",
      "    // it returns the sum of the lengths of the portions of the line that are inside the polygon",
      "    ld polygon_line_intersection(vector<PT> p, PT a, PT b) {",
      "        int n = p.size();",
      "        p.push_back(p[0]);",
      "        line l = line(a, b);",
      "        ld ans = 0.0;",
      "        vector<pair<ld, int> > vec;",
      "        for (int i = 0; i < n; i++) {",
      "            int s1 = orientation(a, b, p[i]);",
      "            int s2 = orientation(a, b, p[i + 1]);",
      "            if (s1 == s2) continue;",
      "            line t = line(p[i], p[i + 1]);",
      "            PT inter = (t.v * l.c - l.v * t.c) / cross(l.v, t.v);",
      "            ld tmp = dot(inter, l.v);",
      "            int f;",
      "            if (s1 > s2) f = s1 && s2 ? 2 : 1;",
      "            else f = s1 && s2 ? -2 : -1;",
      "            vec.push_back(make_pair((f > 0 ? tmp - eps : tmp + eps), f)); // keep eps very small like 1e-12",
      "        }",
      "        sort(vec.begin(), vec.end());",
      "        for (int i = 0, j = 0; i + 1 < (int) vec.size(); i++) {",
      "            j += vec[i].second;",
      "            if (j) ans += vec[i + 1].first - vec[i].first; // if this portion is inside the polygon",
      "            // else ans = 0; // if we want the maximum intersected length which is totally inside the polygon, uncomment this and take the maximum of ans",
      "        }",
      "        ans = ans / sqrt(dot(l.v, l.v));",
      "        p.pop_back();",
      "        return ans;",
      "    }",
      "",
      "    // given a convex polygon p, and a line ab and the top vertex of the polygon",
      "    // returns the intersection of the line with the polygon",
      "    // it returns the indices of the edges of the polygon that are intersected by the line",
      "    // so if it returns i, then the line intersects the edge (p[i], p[(i + 1) % n])",
      "    array<int, 2> convex_line_intersection(vector<PT> &p, PT a, PT b, int top) {",
      "        int end_a = extreme_vertex(p, (a - b).perp(), top);",
      "        int end_b = extreme_vertex(p, (b - a).perp(), top);",
      "        auto cmp_l = [&](int i) { return orientation(a, p[i], b); };",
      "        if (cmp_l(end_a) < 0 || cmp_l(end_b) > 0)",
      "            return {-1, -1}; // no intersection",
      "        array<int, 2> res;",
      "        for (int i = 0; i < 2; i++) {",
      "            int lo = end_b, hi = end_a, n = p.size();",
      "            while ((lo + 1) % n != hi) {",
      "                int m = ((lo + hi + (lo < hi ? 0 : n)) / 2) % n;",
      "                (cmp_l(m) == cmp_l(end_b) ? lo : hi) = m;",
      "            }",
      "            res[i] = (lo + !cmp_l(hi)) % n;",
      "            swap(end_a, end_b);",
      "        }",
      "        if (res[0] == res[1]) return {res[0], -1}; // touches the vertex res[0]",
      "        if (!cmp_l(res[0]) && !cmp_l(res[1]))",
      "            switch ((res[0] - res[1] + (int) p.size() + 1) % p.size()) {",
      "                case 0:",
      "                    return {res[0], res[0]}; // touches the edge (res[0], res[0] + 1)",
      "                case 2:",
      "                    return {res[1], res[1]}; // touches the edge (res[1], res[1] + 1)",
      "            }",
      "        return res; // intersects the edges (res[0], res[0] + 1) and (res[1], res[1] + 1)",
      "    }",
      "",
      "    pair<PT, int> point_poly_tangent(vector<PT> &p, PT Q, int dir, int l, int r) {",
      "        while (r - l > 1) {",
      "            int mid = (l + r) >> 1;",
      "            bool pvs = orientation(Q, p[mid], p[mid - 1]) != -dir;",
      "            bool nxt = orientation(Q, p[mid], p[mid + 1]) != -dir;",
      "            if (pvs && nxt) return {p[mid], mid};",
      "            if (!(pvs || nxt)) {",
      "                auto p1 = point_poly_tangent(p, Q, dir, mid + 1, r);",
      "                auto p2 = point_poly_tangent(p, Q, dir, l, mid - 1);",
      "                return orientation(Q, p1.first, p2.first) == dir ? p1 : p2;",
      "            }",
      "            if (!pvs) {",
      "                if (orientation(Q, p[mid], p[l]) == dir) r = mid - 1;",
      "                else if (orientation(Q, p[l], p[r]) == dir) r = mid - 1;",
      "                else l = mid + 1;",
      "            }",
      "            if (!nxt) {",
      "                if (orientation(Q, p[mid], p[l]) == dir) l = mid + 1;",
      "                else if (orientation(Q, p[l], p[r]) == dir) r = mid - 1;",
      "                else l = mid + 1;",
      "            }",
      "        }",
      "        pair<PT, int> ret = {p[l], l};",
      "        for (int i = l + 1; i <= r; i++) ret = orientation(Q, ret.first, p[i]) != dir ? make_pair(p[i], i) : ret;",
      "        return ret;",
      "    }",
      "",
      "    // (ccw, cw) tangents from a point that is outside this convex polygon",
      "    // returns indexes of the points",
      "    // ccw means the tangent from Q to that point is in the same direction as the polygon ccw direction",
      "    pair<int, int> tangents_from_point_to_polygon(vector<PT> &p, PT Q) {",
      "        int ccw = point_poly_tangent(p, Q, 1, 0, (int) p.size() - 1).second;",
      "        int cw = point_poly_tangent(p, Q, -1, 0, (int) p.size() - 1).second;",
      "        return make_pair(ccw, cw);",
      "    }",
      "",
      "    // minimum distance from a point to a convex polygon",
      "    // it assumes point lie strictly outside the polygon",
      "    ld dist_from_point_to_polygon(vector<PT> &p, PT z) {",
      "        ld ans = inf;",
      "        int n = p.size();",
      "        if (n <= 3) {",
      "            for (int i = 0; i < n; i++) ans = min(ans, dist_from_point_to_seg(p[i], p[(i + 1) % n], z));",
      "            return ans;",
      "        }",
      "        auto [r, l] = tangents_from_point_to_polygon(p, z);",
      "        if (l > r) r += n;",
      "        while (l < r) {",
      "            int mid = (l + r) >> 1;",
      "            ld left = dist2(p[mid % n], z), right = dist2(p[(mid + 1) % n], z);",
      "            ans = min({ans, left, right});",
      "            if (left < right) r = mid;",
      "            else l = mid + 1;",
      "        }",
      "        ans = sqrt(ans);",
      "        ans = min(ans, dist_from_point_to_seg(p[l % n], p[(l + 1) % n], z));",
      "        ans = min(ans, dist_from_point_to_seg(p[l % n], p[(l - 1 + n) % n], z));",
      "        return ans;",
      "    }",
      "",
      "    // minimum distance from convex polygon p to line ab",
      "    // returns 0 is it intersects with the polygon",
      "    // top - upper right vertex",
      "    ld dist_from_polygon_to_line(vector<PT> &p, PT a, PT b, int top) { //O(log n)",
      "        PT orth = (b - a).perp();",
      "        if (orientation(a, b, p[0]) > 0) orth = (a - b).perp();",
      "        int id = extreme_vertex(p, orth, top);",
      "        if (dot(p[id] - a, orth) > 0)",
      "            return 0.0; //if orth and a are in the same half of the line, then poly and line intersects",
      "        return dist_from_point_to_line(a, b, p[id]); //does not intersect",
      "    }",
      "",
      "    // minimum distance from a convex polygon to another convex polygon",
      "    // the polygon doesnot overlap or touch",
      "    // tested in https://toph.co/p/the-wall",
      "    ld dist_from_polygon_to_polygon(vector<PT> &p1, vector<PT> &p2) { // O(n log n)",
      "        ld ans = inf;",
      "        for (int i = 0; i < p1.size(); i++) {",
      "            ans = min(ans, dist_from_point_to_polygon(p2, p1[i]));",
      "        }",
      "        for (int i = 0; i < p2.size(); i++) {",
      "            ans = min(ans, dist_from_point_to_polygon(p1, p2[i]));",
      "        }",
      "        return ans;",
      "    }",
      "",
      "    // maximum distance from a convex polygon to another convex polygon",
      "    ld maximum_dist_from_polygon_to_polygon(vector<PT> &u, vector<PT> &v) { //O(n)",
      "        int n = (int) u.size(), m = (int) v.size();",
      "        ld ans = 0;",
      "        if (n < 3 || m < 3) {",
      "            for (int i = 0; i < n; i++) {",
      "                for (int j = 0; j < m; j++) ans = max(ans, dist2(u[i], v[j]));",
      "            }",
      "            return sqrt(ans);",
      "        }",
      "        if (u[0].x > v[0].x) swap(n, m), swap(u, v);",
      "        int i = 0, j = 0, step = n + m + 10;",
      "        while (j + 1 < m && v[j].x < v[j + 1].x) j++;",
      "        while (step--) {",
      "            if (cross(u[(i + 1) % n] - u[i], v[(j + 1) % m] - v[j]) >= 0) j = (j + 1) % m;",
      "            else i = (i + 1) % n;",
      "            ans = max(ans, dist2(u[i], v[j]));",
      "        }",
      "        return sqrt(ans);",
      "    }",
      "",
      "    // calculates the area of the union of n polygons (not necessarily convex).",
      "    // the points within each polygon must be given in CCW order.",
      "    // complexity: O(N^2), where N is the total number of points",
      "    ld rat(PT a, PT b, PT p) {",
      "        return !sign(a.x - b.x) ? (p.y - a.y) / (b.y - a.y) : (p.x - a.x) / (b.x - a.x);",
      "    };",
      "",
      "    ld polygon_union(vector<vector<PT>> &p) {",
      "        int n = p.size();",
      "        ld ans = 0;",
      "        for (int i = 0; i < n; ++i) {",
      "            for (int v = 0; v < (int) p[i].size(); ++v) {",
      "                PT a = p[i][v], b = p[i][(v + 1) % p[i].size()];",
      "                vector<pair<ld, int>> segs;",
      "                segs.emplace_back(0, 0), segs.emplace_back(1, 0);",
      "                for (int j = 0; j < n; ++j) {",
      "                    if (i != j) {",
      "                        for (size_t u = 0; u < p[j].size(); ++u) {",
      "                            PT c = p[j][u], d = p[j][(u + 1) % p[j].size()];",
      "                            int sc = sign(cross(b - a, c - a)), sd = sign(cross(b - a, d - a));",
      "                            if (!sc && !sd) {",
      "                                if (sign(dot(b - a, d - c)) > 0 && i > j) {",
      "                                    segs.emplace_back(rat(a, b, c), 1), segs.emplace_back(rat(a, b, d), -1);",
      "                                }",
      "                            } else {",
      "                                ld sa = cross(d - c, a - c), sb = cross(d - c, b - c);",
      "                                if (sc >= 0 && sd < 0) segs.emplace_back(sa / (sa - sb), 1);",
      "                                else if (sc < 0 && sd >= 0) segs.emplace_back(sa / (sa - sb), -1);",
      "                            }",
      "                        }",
      "                    }",
      "                }",
      "                sort(segs.begin(), segs.end());",
      "                ld pre = min(max(segs[0].first, (ld)0.0), (ld)1.0), now, sum = 0;",
      "                int cnt = segs[0].second;",
      "                for (int j = 1; j < segs.size(); ++j) {",
      "                    now = min(max(segs[j].first, (ld)0.0), (ld)1.0);",
      "                    if (!cnt) sum += now - pre;",
      "                    cnt += segs[j].second;",
      "                    pre = now;",
      "                }",
      "                ans += cross(a, b) * sum;",
      "            }",
      "        }",
      "        return ans * 0.5;",
      "    }",
      "",
      "    // # HALF PLANE START",
      "    // contains all points p such that: cross(b - a, p - a) >= 0",
      "    struct HP {",
      "        PT a, b;",
      "",
      "        HP() {}",
      "",
      "        HP(PT a, PT b) : a(a), b(b) {}",
      "",
      "        HP(const HP &rhs) : a(rhs.a), b(rhs.b) {}",
      "",
      "        int operator<(const HP &rhs) const {",
      "            PT p = b - a;",
      "            PT q = rhs.b - rhs.a;",
      "            int fp = (p.y < 0 || (p.y == 0 && p.x < 0));",
      "            int fq = (q.y < 0 || (q.y == 0 && q.x < 0));",
      "            if (fp != fq) return fp == 0;",
      "            if (cross(p, q)) return cross(p, q) > 0;",
      "            return cross(p, rhs.b - a) < 0;",
      "        }",
      "",
      "        PT line_line_intersection(PT a, PT b, PT c, PT d) {",
      "            b = b - a;",
      "            d = c - d;",
      "            c = c - a;",
      "            return a + b * cross(c, d) / cross(b, d);",
      "        }",
      "",
      "        PT intersection(const HP &v) {",
      "            return line_line_intersection(a, b, v.a, v.b);",
      "        }",
      "    };",
      "",
      "    int check(HP a, HP b, HP c) {",
      "        return cross(a.b - a.a, b.intersection(c) - a.a) >",
      "            -eps; //-eps to include polygons of zero area (straight lines, points)",
      "    }",
      "",
      "    // consider half-plane of counter-clockwise side of each line",
      "    // if lines are not bounded add infinity rectangle",
      "    // returns a convex polygon, a point can occur multiple times though",
      "    // complexity: O(n log(n))",
      "    vector<PT> half_plane_intersection(vector<HP> h) {",
      "        sort(h.begin(), h.end());",
      "        vector<HP> tmp;",
      "        for (int i = 0; i < h.size(); i++) {",
      "            if (!i || cross(h[i].b - h[i].a, h[i - 1].b - h[i - 1].a)) {",
      "                tmp.push_back(h[i]);",
      "            }",
      "        }",
      "        h = tmp;",
      "        vector<HP> q(h.size() + 10);",
      "        int qh = 0, qe = 0;",
      "        for (int i = 0; i < h.size(); i++) {",
      "            while (qe - qh > 1 && !check(h[i], q[qe - 2], q[qe - 1])) qe--;",
      "            while (qe - qh > 1 && !check(h[i], q[qh], q[qh + 1])) qh++;",
      "            q[qe++] = h[i];",
      "        }",
      "        while (qe - qh > 2 && !check(q[qh], q[qe - 2], q[qe - 1])) qe--;",
      "        while (qe - qh > 2 && !check(q[qe - 1], q[qh], q[qh + 1])) qh++;",
      "        vector<HP> res;",
      "        for (int i = qh; i < qe; i++) res.push_back(q[i]);",
      "        vector<PT> hull;",
      "        if (res.size() > 2) {",
      "            for (int i = 0; i < res.size(); i++) {",
      "                hull.push_back(res[i].intersection(res[(i + 1) % ((int) res.size())]));",
      "            }",
      "        }",
      "        return hull;",
      "    }",
      "",
      "    // rotate the polygon such that the (bottom, left)-most point is at the first position",
      "    void reorder_polygon(vector<PT> &p) {",
      "        int pos = 0;",
      "        for (int i = 1; i < p.size(); i++) {",
      "            if (p[i].y < p[pos].y || (sign(p[i].y - p[pos].y) == 0 && p[i].x < p[pos].x)) pos = i;",
      "        }",
      "        rotate(p.begin(), p.begin() + pos, p.end());",
      "    }",
      "",
      "    // a and b are convex polygons",
      "    // returns a convex hull of their minkowski sum",
      "    // min(a.size(), b.size()) >= 2",
      "    // https://cp-algorithms.com/geometry/minkowski.html",
      "    vector<PT> minkowski_sum(vector<PT> a, vector<PT> b) {",
      "        reorder_polygon(a);",
      "        reorder_polygon(b);",
      "        int n = a.size(), m = b.size();",
      "        int i = 0, j = 0;",
      "        a.push_back(a[0]);",
      "        a.push_back(a[1]);",
      "        b.push_back(b[0]);",
      "        b.push_back(b[1]);",
      "        vector<PT> c;",
      "        while (i < n || j < m) {",
      "            c.push_back(a[i] + b[j]);",
      "            ld p = cross(a[i + 1] - a[i], b[j + 1] - b[j]);",
      "            if (sign(p) >= 0) ++i;",
      "            if (sign(p) <= 0) ++j;",
      "        }",
      "        return c;",
      "    }",
      "",
      "    // returns the area of the intersection of the circle with center c and radius r",
      "    // and the triangle formed by the points c, a, b",
      "    ld _triangle_circle_intersection(PT c, ld r, PT a, PT b) {",
      "        ld sd1 = dist2(c, a), sd2 = dist2(c, b);",
      "        if (sd1 > sd2) swap(a, b), swap(sd1, sd2);",
      "        ld sd = dist2(a, b);",
      "        ld d1 = sqrtl(sd1), d2 = sqrtl(sd2), d = sqrt(sd);",
      "        ld x = abs(sd2 - sd - sd1) / (2 * d);",
      "        ld h = sqrtl(sd1 - x * x);",
      "        if (r >= d2) return h * d / 2;",
      "        ld area = 0;",
      "        if (sd + sd1 < sd2) {",
      "            if (r < d1) area = r * r * (acos(h / d2) - acos(h / d1)) / 2;",
      "            else {",
      "                area = r * r * (acos(h / d2) - acos(h / r)) / 2;",
      "                ld y = sqrtl(r * r - h * h);",
      "                area += h * (y - x) / 2;",
      "            }",
      "        } else {",
      "            if (r < h) area = r * r * (acos(h / d2) + acos(h / d1)) / 2;",
      "            else {",
      "                area += r * r * (acos(h / d2) - acos(h / r)) / 2;",
      "                ld y = sqrtl(r * r - h * h);",
      "                area += h * y / 2;",
      "                if (r < d1) {",
      "                    area += r * r * (acos(h / d1) - acos(h / r)) / 2;",
      "                    area += h * y / 2;",
      "                } else area += h * x / 2;",
      "            }",
      "        }",
      "        return area;",
      "    }",
      "",
      "    // intersection between a simple polygon and a circle",
      "    ld polygon_circle_intersection(vector<PT> &v, PT p, ld r) {",
      "        int n = v.size();",
      "        ld ans = 0.00;",
      "        PT org = {0, 0};",
      "        for (int i = 0; i < n; i++) {",
      "            int x = orientation(p, v[i], v[(i + 1) % n]);",
      "            if (x == 0) continue;",
      "            ld area = _triangle_circle_intersection(org, r, v[i] - p, v[(i + 1) % n] - p);",
      "            if (x < 0) ans -= area;",
      "            else ans += area;",
      "        }",
      "        return abs(ans);",
      "    }",
      "",
      "    // find a circle of radius r that contains as many points as possible",
      "    // O(n^2 log n);",
      "    ld maximum_circle_cover(vector<PT> p, ld r, circle &c) {",
      "        int n = p.size();",
      "        int ans = 0;",
      "        int id = 0;",
      "        ld th = 0;",
      "        for (int i = 0; i < n; ++i) {",
      "            // maximum circle cover when the circle goes through this point",
      "            vector<pair<ld, int>> events = {{-PI, +1},",
      "                                                {PI,  -1}};",
      "            for (int j = 0; j < n; ++j) {",
      "                if (j == i) continue;",
      "                ld d = dist(p[i], p[j]);",
      "                if (d > r * 2) continue;",
      "                ld dir = (p[j] - p[i]).arg();",
      "                ld ang = acos(d / 2 / r);",
      "                ld st = dir - ang, ed = dir + ang;",
      "                if (st > PI) st -= PI * 2;",
      "                if (st <= -PI) st += PI * 2;",
      "                if (ed > PI) ed -= PI * 2;",
      "                if (ed <= -PI) ed += PI * 2;",
      "                events.push_back({st - eps, +1}); // take care of precisions!",
      "                events.push_back({ed, -1});",
      "                if (st > ed) {",
      "                    events.push_back({-PI, +1});",
      "                    events.push_back({+PI, -1});",
      "                }",
      "            }",
      "            sort(events.begin(), events.end());",
      "            int cnt = 0;",
      "            for (auto &&e: events) {",
      "                cnt += e.second;",
      "                if (cnt > ans) {",
      "                    ans = cnt;",
      "                    id = i;",
      "                    th = e.first;",
      "                }",
      "            }",
      "        }",
      "        PT w = PT(p[id].x + r * cos(th), p[id].y + r * sin(th));",
      "        c = circle(w, r); //best_circle",
      "        return ans;",
      "    }",
      "",
      "    // radius of the maximum inscribed circle in a convex polygon",
      "    ld maximum_inscribed_circle(vector<PT> p) {",
      "        int n = p.size();",
      "        if (n <= 2) return 0;",
      "        ld l = 0, r = 20000;",
      "        while (r - l > eps) {",
      "            ld mid = (l + r) * 0.5;",
      "            vector<HP> h;",
      "            const int L = 1e9;",
      "            h.push_back(HP(PT(-L, -L), PT(L, -L)));",
      "            h.push_back(HP(PT(L, -L), PT(L, L)));",
      "            h.push_back(HP(PT(L, L), PT(-L, L)));",
      "            h.push_back(HP(PT(-L, L), PT(-L, -L)));",
      "            for (int i = 0; i < n; i++) {",
      "                PT z = (p[(i + 1) % n] - p[i]).perp();",
      "                z = z.truncate(mid);",
      "                PT y = p[i] + z, q = p[(i + 1) % n] + z;",
      "                h.push_back(HP(p[i] + z, p[(i + 1) % n] + z));",
      "            }",
      "            vector<PT> nw = half_plane_intersection(h);",
      "            if (!nw.empty()) l = mid;",
      "            else r = mid;",
      "        }",
      "        return l;",
      "    }",
      "",
      "    // ear decomposition, O(n^3) but faster",
      "    vector<vector<PT>> triangulate(vector<PT> p) {",
      "        vector<vector<PT>> v;",
      "        while (p.size() >= 3) {",
      "            for (int i = 0, n = p.size(); i < n; i++) {",
      "                int pre = i == 0 ? n - 1 : i - 1;;",
      "                int nxt = i == n - 1 ? 0 : i + 1;;",
      "                int ori = orientation(p[i], p[pre], p[nxt]);",
      "                if (ori < 0) {",
      "                    int ok = 1;",
      "                    for (int j = 0; j < n; j++) {",
      "                        if (j == i || j == pre || j == nxt)continue;",
      "                        if (is_point_in_triangle(p[i], p[pre], p[nxt], p[j]) < 1) {",
      "                            ok = 0;",
      "                            break;",
      "                        }",
      "                    }",
      "                    if (ok) {",
      "                        v.push_back({p[pre], p[i], p[nxt]});",
      "                        p.erase(p.begin() + i);",
      "                        break;",
      "                    }",
      "                }",
      "            }",
      "        }",
      "        return v;",
      "    }",
      "",
      "    // # STAR START",
      "    struct star {",
      "        int n;    // number of sides of the star",
      "        ld r; // radius of the circumcircle",
      "        star(int _n, ld _r) {",
      "            n = _n;",
      "            r = _r;",
      "        }",
      "",
      "        ld area() {",
      "            ld theta = PI / n;",
      "            ld s = 2 * r * sin(theta);",
      "            ld R = 0.5 * s / tan(theta);",
      "            ld a = 0.5 * n * s * R;",
      "            ld a2 = 0.25 * s * s / tan(1.5 * theta);",
      "            return a - n * a2;",
      "        }",
      "    };",
      "",
      "    // given a list of lengths of the sides of a polygon in counterclockwise order",
      "    // returns the maximum area of a non-degenerate polygon that can be formed using those lengths",
      "    ld get_maximum_polygon_area_for_given_lengths(vector<ld> v) {",
      "        if (v.size() < 3) {",
      "            return 0;",
      "        }",
      "        int m = 0;",
      "        ld sum = 0;",
      "        for (int i = 0; i < v.size(); i++) {",
      "            if (v[i] > v[m]) {",
      "                m = i;",
      "            }",
      "            sum += v[i];",
      "        }",
      "        if (sign(v[m] - (sum - v[m])) >= 0) {",
      "            return 0; // no non-degenerate polygon is possible",
      "        }",
      "        // the polygon should be a circular polygon",
      "        // that is all points are on the circumference of a circle",
      "        ld l = v[m] / 2, r = 1e6; // fix it correctly",
      "        int it = 60;",
      "        auto ang = [](ld x, ld r) { // x = length of the chord, r = radius of the circle",
      "            return 2 * asin((x / 2) / r);",
      "        };",
      "        auto calc = [=](ld r) {",
      "            ld sum = 0;",
      "            for (auto x: v) {",
      "                sum += ang(x, r);",
      "            }",
      "            return sum;",
      "        };",
      "        // compute the radius of the circle",
      "        while (it--) {",
      "            ld mid = (l + r) / 2;",
      "            if (calc(mid) <= 2 * PI) {",
      "                r = mid;",
      "            } else {",
      "                l = mid;",
      "            }",
      "        }",
      "",
      "        if (calc(r) <= 2 * PI - eps) { // the center of the circle is outside the polygon",
      "            auto calc2 = [&](ld r) {",
      "                ld sum = 0;",
      "                for (int i = 0; i < v.size(); i++) {",
      "                    ld x = v[i];",
      "                    ld th = ang(x, r);",
      "                    if (i != m) {",
      "                        sum += th;",
      "                    } else {",
      "                        sum += 2 * PI - th;",
      "                    }",
      "                }",
      "                return sum;",
      "            };",
      "            l = v[m] / 2;",
      "            r = 1e6;",
      "            it = 60;",
      "            while (it--) {",
      "                ld mid = (l + r) / 2;",
      "                if (calc2(mid) > 2 * PI) {",
      "                    r = mid;",
      "                } else {",
      "                    l = mid;",
      "                }",
      "            }",
      "            auto get_area = [=](ld r) {",
      "                ld ans = 0;",
      "                for (int i = 0; i < v.size(); i++) {",
      "                    ld x = v[i];",
      "                    ld area = r * r * sin(ang(x, r)) / 2;",
      "                    if (i != m) {",
      "                        ans += area;",
      "                    } else {",
      "                        ans -= area;",
      "                    }",
      "                }",
      "                return ans;",
      "            };",
      "            return get_area(r);",
      "        } else { // the center of the circle is inside the polygon",
      "            auto get_area = [=](ld r) {",
      "                ld ans = 0;",
      "                for (auto x: v) {",
      "                    ans += r * r * sin(ang(x, r)) / 2;",
      "                }",
      "                return ans;",
      "            };",
      "            return get_area(r);",
      "        }",
      "    }",
      "}",
      "",
      "using geo::PT;",
      "using geo::ld;"
    ],
    "description": "cp-geo"
  },
  "Geometry_All.cpp": {
    "prefix": "Geometry_All",
    "scope": "cpp",
    "body": [
      "/*",
      "Geometry Namespace",
      "reference: https://codeforces.com/contest/1936/submission/249350779 (which referenced https://victorlecomte.com/cp-geo.pdf)",
      "*/",
      "namespace Geometry{",
      "    // double or ll",
      "    using C = double;",
      "    const C INF = 1e100;",
      "    const C EPS = 1e-9;",
      "    const C PI = acos((C)-1);",
      "    int sign(C x){return (x>EPS) - (x<-EPS);}",
      "",
      "    // Point",
      "    struct Point{",
      "        C x, y;",
      "        Point(C x=0,C y=0):x(x),y(y){}",
      "        Point operator-(Point p) const {return Point(x - p.x, y - p.y);}",
      "        Point operator-=(Point p){return *this = (*this - p);}",
      "        Point operator+(Point p) const {return Point(x + p.x, y + p.y);}",
      "        Point operator+=(Point p){return *this = (*this + p);}",
      "        Point operator*(C c) const {return Point(x * c, y * c);}",
      "        Point operator*=(C c){return *this = ((*this) * c);}",
      "        friend Point operator*(const C& c, Point p){return p*c;}",
      "        Point operator/(C c) const {return Point(x / c, y / c);}",
      "        Point operator/=(C c) {return *this = (*this / c);}",
      "        bool operator==(Point p) const {return !sign(p.x-x) && !sign(p.y-y);}",
      "        bool operator!=(Point p) const {return !(*this == p);}",
      "        bool operator<(Point p) const {return !sign(p.x-x) ? y < p.y : x < p.x;}",
      "        bool operator<=(Point p) const {return *this == p || *this < p;}",
      "        bool operator>(Point p) const {return !sign(p.x-x) ? y > p.y : x > p.x;}",
      "        bool operator>=(Point p) const {return *this == p || *this > p;}",
      "        double norm() const {return std::hypot(x, y);}",
      "        C norm2() const{return x*x + y*y;}",
      "        double arg() const{ return atan2(y, x);}",
      "        Point perpendicular() const{ return Point(-y, x);}",
      "        // returns a vector with norm r and having same direction",
      "        Point unit() const{",
      "            double k = norm();",
      "            if(!sign(k)) return *this;",
      "            return (*this) / k;",
      "        }",
      "    };",
      "    const Point O = Point(0,0), FAIL = Point(INF, INF);",
      "    istream &operator>>(istream &in, Point &p) { return in >> p.x >> p.y; }",
      "    ostream &operator<<(ostream &out, Point &p) { return out << \"(\" << p.x << \",\" << p.y << \")\"; }",
      "    C dot(Point a, Point b){return a.x*b.x + a.y*b.y;}",
      "    double dist(Point a, Point b){return (b-a).norm();}",
      "    C dist2(Point a, Point b){return (b-a).norm2();}",
      "    C cross(Point a, Point b){return a.x*b.y - a.y*b.x;}",
      "    C cross(Point a, Point b, Point c){return cross(b-a, c-a);}",
      "    int ccw(Point a, Point b, Point c){return sign(cross(a,b,c));}",
      "    // y\ucd95 \uc74c\uc758 \ubc29\ud5a5\uc73c\ub85c\ubd80\ud130 \uc2dc\uacc4 \ubc18\ub300\ubc29\ud5a5\uc73c\ub85c \uc815\ub82c\ud558\ub294 \ube44\uad50\ud568\uc218.",
      "    inline bool cmp_angle(Point a, Point b){",
      "        if((a>O)^(b>O)) return a > b;",
      "        if(sign(cross(a,b))) return sign(cross(a,b))>0;",
      "        return a.norm2() < b.norm2();",
      "    }",
      "    double area_signed(Point a, Point b, Point c){",
      "        if(dist(b,c)<EPS) return 0;",
      "        return cross(a,b,c) / 2;",
      "    }",
      "    double area(Point a, Point b, Point c){return abs(area_signed(a,b,c));}",
      "",
      "    struct Line{",
      "        Point s,e;",
      "        Line(Point s=O,Point e=O):s(s),e(e){}",
      "        friend istream& operator>> (istream& is, Line& l){Point a, b; cin>>a>>b; l = Line(a,b); return is;}",
      "        double length() const{return dist(s,e);}",
      "        C length2() const{return dist2(s,e);}",
      "        bool is_on_line(Point x) const{return !ccw(s,e,x) && min(s,e)<=x && x<=max(s,e);}",
      "        friend bool chk_inter(Line p, Line q){",
      "            auto[a,b] = p; auto[c,d] = q;",
      "            int t1 = ccw(a,c,d); int t2 =  ccw(b,c,d);",
      "            int t3 = ccw(c,a,b); int t4 =  ccw(d,a,b);",
      "            if(!t1 && !t2){",
      "                if(a>b) swap(a,b);",
      "                if(c>d) swap(c,d);",
      "                return a <= d && c <= b;",
      "            }",
      "            return t1*t2 <= 0 && t3*t4 <= 0;",
      "        }",
      "        friend Point parrallel_inter(Line a,Line b){",
      "            if(a.s > a.e) swap(a.s, a.e);",
      "            if(b.s > b.e) swap(b.s, b.e);",
      "            if(a.e==b.s) return a.e;",
      "            if(a.s==b.e) return a.s;",
      "            return FAIL;",
      "        }",
      "        // only works when T = C",
      "        friend Point inter(Line p,Line q){",
      "            Point a=p.s, b=p.e, c=q.s, d=q.e;",
      "            int t1 = ccw(a,c,d) , t2 = ccw(b,c,d);",
      "            if(t1 == 0 && t2 == 0)",
      "                return parrallel_inter(p,q);",
      "            b-=a; d-=c;",
      "            double t = cross(c-a,d) / cross(b,d);",
      "            return a + b*t;",
      "        }",
      "        friend inline double dist_signed(Line a,Point x){ return cross(a.s, a.e, x)/a.length();}",
      "        friend inline double dist(Line a,Point x){ return abs(dist_signed(a,x));}",
      "    };",
      "    //compute intersection of line through points a and b with",
      "    //circle centered at c with radius r > 0",
      "    vector<Point> circle_line_intersection(Point c, C r, Line l) {",
      "        vector<Point> ret;",
      "        auto [a,b] = l;",
      "        b -= a; a -= c; // b is vector of a, a is relative to c",
      "        // |(u+kv - O)| = r",
      "        // ||u+kv-O|^2 = r^2",
      "        // solve quadratic equation regard of k.",
      "        C A = dot(b, b), B = dot(a, b);",
      "        C C = dot(a, a) - r * r, D = B * B - A * C;",
      "        if (D < -EPS) return ret;",
      "        ret.push_back(c + a + b * (-B + sqrt(D + EPS)) / A);",
      "        // D != 0",
      "        if (D > EPS) ret.push_back(c + a + b * (-B - sqrt(D)) / A);",
      "        return ret;",
      "    }",
      "",
      "    double sector_signed(Point c, C r, Point a, Point b){",
      "        if(ccw(c, a, b) == 0) return 0;",
      "        a -= c; b -= c;",
      "        return r * r * atan2(cross(a,b), dot(a,b)) / 2;",
      "    }",
      "    double sector(Point c, C r, Point a, Point b){",
      "        return abs(sector_signed(c, r, a, b));",
      "    }",
      "",
      "    using Polygon = vector<Point>;",
      "    Polygon getCH(Polygon pg){ //Monotone Chain of polygon",
      "        if(size(pg)<=3) return pg;",
      "        sort(all(pg));",
      "        Polygon up(size(pg)),dn(size(pg));",
      "        int u=0,d=0;",
      "        for(auto&p:pg){",
      "            // change the inequity for colinear cases",
      "            while(u>1 && ccw(up[u-2],up[u-1],p)>=0) --u;",
      "            while(d>1 && ccw(dn[d-2],dn[d-1],p)<=0) --d;",
      "            up[u++] = dn[d++] = p;",
      "        }",
      "        up.resize(u); dn.resize(d);",
      "        dn.insert(dn.end(),++up.rbegin(),--up.rend());",
      "        return dn;",
      "    }",
      "",
      "    pair<Point,Point> find_farthest(const Polygon&v){",
      "        vector<Point> ch = getCH(v);",
      "        int n = ch.size();",
      "        C ans = 0; Point ans1,ans2;",
      "        int id = 1;",
      "        auto upd = [&](int a,int b){",
      "            auto val = dist(ch[a], ch[b]);",
      "            if(ans< val){",
      "                ans1 = ch[a];",
      "                ans2 = ch[b];",
      "                ans = val;",
      "            }",
      "        };",
      "        for(int i=0;i<n;i++){",
      "            while(ccw(O,ch[i+1]-ch[i],ch[(id+1)%n]-ch[id])>0){",
      "                upd(i,id);",
      "                id++; if(id==n) id = 0;",
      "            }",
      "            upd(i,id);",
      "        }",
      "        return {ans1, ans2};",
      "    }",
      "",
      "    bool point_in_polygon_naive(const Polygon& h,const Point& p){",
      "        // strictly inner",
      "        int s = ccw(h[0],h[1],p);",
      "        for(int i=1;i<size(h);i++){",
      "            if(s * ccw(h[i], h[(i+1) % size(h)], p) <= 0) return false;",
      "        }",
      "        return true;",
      "    }",
      "    // -1 if strictly inside, 0 if on the polygon, 1 if strictly outside",
      "    // polygon is counter clock wised sorted",
      "    // it must be strictly convex, otherwise make it strictly convex first",
      "    int is_point_in_convex(Polygon &p, const Point &x) { // O(log n)",
      "        int n = p.size();",
      "        assert(n >= 3);",
      "        int a = ccw(p[0], p[1], x), b = ccw(p[0], p[n - 1], x);",
      "        if (a < 0 || b > 0) return 1;",
      "        int l = 1, r = n - 1;",
      "        while (l + 1 < r) {",
      "            int mid = l + r >> 1;",
      "            if (ccw(p[0], p[mid], x) >= 0) l = mid;",
      "            else r = mid;",
      "        }",
      "        int k = ccw(p[l], p[r], x);",
      "        if (k <= 0) return -k;",
      "        if (l == 1 && a == 0) return 0;",
      "        if (r == n - 1 && b == 0) return 0;",
      "        return -1;",
      "    }",
      "",
      "    bool is_point_on_polygon(const Polygon& p, const Point &z) {",
      "        int n = p.size();",
      "        for (int i = 0; i < n; i++)",
      "            if (Line(p[i], p[(i + 1) % n]).is_on_line(z))",
      "                return 1;",
      "        return 0;",
      "    }",
      "",
      "    // returns 1e9 if the point is on the polygon",
      "    int winding_number(Polygon &p, const Point &z) { // O(n)",
      "        if (is_point_on_polygon(p, z)) return 1e9;",
      "        int n = p.size(), ans = 0;",
      "        for (int i = 0; i < n; ++i) {",
      "            int j = (i + 1) % n;",
      "            bool below = p[i].y < z.y;",
      "            if (below != (p[j].y < z.y)) {",
      "                auto orient = ccw(z, p[j], p[i]);",
      "                if (orient == 0) return 0;",
      "                if (below == (orient > 0)) ans += below ? 1 : -1;",
      "            }",
      "        }",
      "        return ans;",
      "    }",
      "",
      "    // -1 if strictly inside, 0 if on the polygon, 1 if strictly outside",
      "    int is_point_in_polygon(Polygon &p, const Point &z) { // O(n)",
      "        int k = winding_number(p, z);",
      "        return k == 1e9 ? 0 : (k == 0 ? 1 : -1);",
      "    }",
      "}",
      "using namespace Geometry;"
    ],
    "description": "Geometry_All"
  },
  "BCC_Edge_Disjoint.cpp": {
    "prefix": "BCC_Edge_Disjoint",
    "scope": "cpp",
    "body": [
      "/*",
      "Edge Disjoint BCC",
      "We are dividing BCC into set of edges.",
      "Each BCC doesn't have any articulation point.",
      "Use init(n) at the very first, if needed",
      "test: https://www.acmicpc.net/problem/11266, https://www.acmicpc.net/problem/4222",
      "*/",
      "namespace EdgeDisjointBCC{",
      "    vector<int> g[N];",
      "    void add_edge(int a,int b){",
      "        g[a].push_back(b);",
      "        g[b].push_back(a);",
      "    }",
      "    int dfn[N], low[N], pv;",
      "    void dfs(int x,int p = 0){",
      "        dfn[x] = low[x] = ++pv;",
      "        for(auto nx: g[x]) if(nx != p){",
      "            if(dfn[nx]) low[x] = min(low[x], dfn[nx]);",
      "            else{",
      "                dfs(nx, x);",
      "                low[x] = min(low[x], low[nx]);",
      "            }",
      "        }",
      "    }",
      "    bool vis[N];",
      "    int bcnt;",
      "    vector<int> bcc[N];",
      "    void color(int x,int col = 0){",
      "        vis[x] = true;",
      "        if(col) bcc[x].push_back(col); // when col = 0, this is root",
      "        for(int nx:g[x]) if(!vis[nx]){",
      "            if(low[nx] < dfn[x]) color(nx, col);",
      "            else{",
      "                bcc[x].push_back(++bcnt);",
      "                color(nx, bcnt);",
      "            }",
      "        }",
      "    }",
      "    vector<int> cutVertices;",
      "    void init(int n){",
      "        pv = bcnt = 0;",
      "        for(int i=1;i<=n;i++){",
      "            g[i].clear();",
      "            dfn[i] = low[i] = vis[i] = 0;",
      "            bcc[i].clear();",
      "        }",
      "        cutVertices.clear();",
      "    }",
      "    void get_bcc(int n){",
      "        for(int i=1;i<=n;i++) if(!dfn[i]) dfs(i, 0);",
      "        for(int i=1;i<=n;i++) if(!vis[i]) color(i, 0);",
      "        for(int i=1;i<=n;i++) if(size(bcc[i])>1) cutVertices.push_back(i);",
      "    }",
      "} using namespace EdgeDisjointBCC;"
    ],
    "description": "BCC_Edge_Disjoint"
  },
  "BCC_Vertex_Disjoint.cpp": {
    "prefix": "BCC_Vertex_Disjoint",
    "scope": "cpp",
    "body": [
      "/*",
      "Vertex Disjoint BCC",
      "We are dividing BCC into set of vertices.",
      "Each BCC doesn't have any articulation edge(bridge).",
      "Use init(n) at the very first, if needed",
      "test: https://www.acmicpc.net/problem/11400",
      "*/",
      "namespace VertexDisjointBCC{",
      "    vector<int> g[N];",
      "    void add_edge(int a,int b){",
      "        g[a].push_back(b);",
      "        g[b].push_back(a);",
      "    }",
      "    int dfn[N], low[N], pv;",
      "    void dfs(int x,int p=0){",
      "        dfn[x] = low[x] = ++pv;",
      "        for(auto nx: g[x]) if(nx != p){",
      "            if(dfn[nx]) low[x] = min(low[x], dfn[nx]);",
      "            else{",
      "                dfs(nx, x);",
      "                low[x] = min(low[x], low[nx]);",
      "            }",
      "        }",
      "    }",
      "    int bcnt, bcc[N];",
      "    vector<pii> bridges;",
      "    void color(int x,int col){",
      "        bcc[x] = col;",
      "        for(int nx:g[x]) if(!bcc[nx]){",
      "            if(low[nx] <= dfn[x]) color(nx, col);",
      "            else{",
      "                bridges.emplace_back(min(x, nx), max(x, nx));",
      "                color(nx, ++bcnt);",
      "            }",
      "        }",
      "    }",
      "    void init(int n){",
      "        pv = bcnt = 0;",
      "        for(int i=1;i<=n;i++){",
      "            g[i].clear();",
      "            dfn[i] = low[i] = bcc[i] = 0;",
      "        }",
      "        bridges.clear();",
      "    }",
      "    void get_bcc(int n){",
      "        for(int i=1;i<=n;i++) if(!dfn[i]) dfs(i, 0);",
      "        for(int i=1;i<=n;i++) if(!bcc[i]) color(i, ++bcnt);",
      "    }",
      "} using namespace VertexDisjointBCC;"
    ],
    "description": "BCC_Vertex_Disjoint"
  },
  "KPATH_INDEX_VERSION.cpp": {
    "prefix": "KPATH_INDEX_VERSION",
    "scope": "cpp",
    "body": [
      "// Index Version",
      "/**",
      " * Leftist Heap Memory Optimized when max_size is determined.",
      " * alloc should be initialized as expected max size. (at least 1)",
      " * pivot should be initialized 0.",
      " */",
      "template <typename Key, typename Value>",
      "struct LeftistHeap {",
      "    // using self_t = LeftistHeap<Key, Value>;",
      "    int node_rank;",
      "    Key key;",
      "    Value value;",
      "    int left, right;",
      "    LeftistHeap(){}",
      "    LeftistHeap(int rank_, Key key_, Value value_, int left_, int right_)",
      "            : node_rank{rank_}, key{key_}, value{value_}, left{left_}, right{right_} {}",
      "    friend inline int emplace(int rank_, Key key_, Value value_, int left_, int right_,",
      "                              std::vector<LeftistHeap>& alloc, int &pivot){",
      "        if(pivot == (int) alloc.size()) alloc.resize((int) alloc.size() * 2 + 1);",
      "        assert(pivot < (int) alloc.size());",
      "        alloc[pivot] = LeftistHeap(rank_, key_, value_, left_, right_);",
      "        return pivot++;",
      "    }",
      "    friend int heap_insert(int a, const Key k, const Value v,",
      "                           std::vector<LeftistHeap>& alloc, int &pivot) {",
      "        assert(a < (int) alloc.size());",
      "        if (a == -1 or k <= alloc[a].key)",
      "            return emplace(1, k, v, a, -1, alloc, pivot);",
      "        int l = alloc[a].left, r = heap_insert(alloc[a].right, k, v, alloc, pivot);",
      "        assert(r != -1);",
      "        // adjust to l.rank >= r.rank",
      "        if (l == -1 or alloc[l].node_rank < alloc[r].node_rank) std::swap(l, r);",
      "        return emplace(r != -1 ? alloc[r].node_rank + 1 : 0, alloc[a].key, alloc[a].value, l, r, alloc, pivot);",
      "    }",
      "};",
      "",
      "",
      "",
      "// Link: https://github.com/Pentagon03/Algorithms/blob/master/Graphs/KPATH.cpp",
      "// Test: https://judge.yosupo.jp/submission/225582",
      "// Reference: https://judge.yosupo.jp/submission/87297",
      "// MAX_DISTANCE: Infinity for path length",
      "",
      "template <typename Distance, typename WeightedGraph>",
      "struct K_Shortest_Paths_Solver{",
      "private:",
      "    const Distance MAX_DISTANCE, BASE_DISTANCE;",
      "    const WeightedGraph& g;",
      "    int n;",
      "    bool is_dag;",
      "    /*",
      "    Information for Recovering path",
      "    First we need previous values for each std::pair<Distance, heap_t*>",
      "    1. heap_t values",
      "    2. After we get the sequence of sidetracks, we need the best vertices",
      "    */",
      "    template <typename T> using min_heap = std::priority_queue<T, std::vector<T>, std::greater<T>>;",
      "    using heap_t = LeftistHeap<Distance, std::pair<int, int>>;",
      "    std::vector<Distance> d;",
      "    std::vector<int> best;",
      "    // for edge (u, v, w),  sidetrack weight will be key, next vertex v will be value",
      "    std::vector<heap_t> alloc;",
      "    int pivot;",
      "    std::vector<int> h; // alloc indices",
      "    std::vector<Distance> distances;",
      "    std::vector<int> path_nodes;",
      "    std::vector<std::pair<Distance, int>> nodes;",
      "    std::vector<int> prev_node;",
      "public:",
      "    explicit K_Shortest_Paths_Solver(const WeightedGraph& g_, bool is_dag_, Distance MAX_DISTANCE_, Distance BASE_DISTANCE_)",
      "            : g(g_), n(g_.size()), is_dag(is_dag_), MAX_DISTANCE(MAX_DISTANCE_), BASE_DISTANCE(BASE_DISTANCE_), pivot(0){}",
      "    // O(m log n)",
      "    auto dijkstra(const WeightedGraph& g_, int s) {",
      "        std::vector<Distance> d_(g_.size(), MAX_DISTANCE);",
      "        std::vector<int> prv(g_.size(), -1);",
      "        min_heap<std::pair<Distance, int>> heap;",
      "        heap.emplace(d_[s] = BASE_DISTANCE, s);",
      "        while (!heap.empty()) {",
      "            auto [dv, v] = heap.top();",
      "            heap.pop();",
      "            if (dv != d_[v]) continue;",
      "            for (auto &[to, w] : g_[v]) {",
      "                if (d_[to] > dv + w) {",
      "                    d_[to] = dv + w;",
      "                    heap.emplace(d_[to], to);",
      "                    prv[to] = v;",
      "                }",
      "            }",
      "        }",
      "        return std::make_pair(d_, prv);",
      "    }",
      "    auto topology_sort(const WeightedGraph& g_){",
      "        const int n_ = g_.size();",
      "        std::vector<int> in_deg(n_, 0);",
      "        for(int u = 0; u < n_; u++)",
      "            for(auto &[v, w]: g_[u])",
      "                in_deg[v]++;",
      "        std::vector<int> order(n_);",
      "        std::queue<int> q;",
      "        for(int u = 0; u < n_; u++)",
      "            if(not in_deg[u])",
      "                q.push(u);",
      "        for(auto &u : order){",
      "            if(q.empty()) {",
      "                assert(0 && \"Cycle occured in DAG\");",
      "                return order;",
      "            }",
      "            u = q.front();",
      "            q.pop();",
      "            for(auto &[v, w]: g_[u])",
      "                if(--in_deg[v] == 0)",
      "                    q.push(v);",
      "        }",
      "        return order;",
      "    }",
      "    // O(n + m)",
      "    auto shortest_path_dag(const WeightedGraph& g_, int s){",
      "        std::vector<Distance> d_(g_.size(), MAX_DISTANCE);",
      "        std::vector<int> prv(g_.size(), -1);",
      "        d_[s] = BASE_DISTANCE;",
      "        auto order = topology_sort(g_);",
      "        for(auto v: order){",
      "            if(d_[v] == MAX_DISTANCE) continue;",
      "            for(auto &[to, w] : g_[v]){",
      "                if(d_[to] > d_[v] + w){",
      "                    d_[to] = d_[v] + w;",
      "                    prv[to] = v;",
      "                }",
      "            }",
      "        }",
      "        return std::make_pair(d_, prv);",
      "    }",
      "    auto k_shortest_paths(int source, int sink, int k) {",
      "        WeightedGraph g_rev(n);",
      "        for (int u = 0; u < n; ++u)",
      "            for (auto &[v, w] : g[u])",
      "                g_rev[v].push_back({u, w});",
      "        std::pair<std::vector<Distance>, std::vector<int>> info;",
      "        if(is_dag) info = shortest_path_dag(g_rev, sink);",
      "        else info = dijkstra(g_rev, sink);",
      "        std::tie(d, best) = info;",
      "        if (d[source] == MAX_DISTANCE)",
      "            return std::vector<Distance>{};",
      "        std::vector<std::basic_string<int>> tree(n);",
      "        for (int u = 0; u < n; ++u)",
      "            if (best[u] != -1)",
      "                tree[best[u]].push_back(u); // u will adopt best[u]'s heap",
      "        alloc = std::vector<heap_t>{};",
      "        alloc.resize(n);",
      "        pivot = 0;",
      "        h = std::vector<int>(n, -1);",
      "        {",
      "            std::queue<int> q({sink});",
      "            while (!q.empty()) {",
      "                auto u = q.front();",
      "                q.pop();",
      "                bool seen_p = false;",
      "                for (auto [v, w] : g[u]) {",
      "                    if (d[v] == MAX_DISTANCE) continue;",
      "                    auto c = w + d[v] - d[u];",
      "                    if (not seen_p and v == best[u] and c == BASE_DISTANCE) {",
      "                        seen_p = true; // we can only skip once! It's the exact same path.",
      "                        continue;",
      "                    }",
      "                    h[u] = heap_insert(h[u], c, std::make_pair(u, v), alloc, pivot);",
      "                }",
      "                for (auto p : tree[u]) h[p] = h[u], q.push(p); // This works fast since we use index",
      "            }",
      "        }",
      "        // min distance",
      "        distances = std::vector<Distance>{d[source]};",
      "        // distances.reserve(k);",
      "",
      "        // last sidetrack index of min_path.",
      "        path_nodes = std::vector<int>{-1};",
      "        // path_nodes.reserve(k);",
      "",
      "        // {Distance, sidetrack ptr}",
      "        nodes = std::vector<std::pair<Distance, int>>{};",
      "        // nodes.reserve(3 * k);",
      "",
      "        // previous node for each node",
      "        prev_node = std::vector<int>{};",
      "        // prev_node.reserve(3 * k);",
      "",
      "        if (h[source] == -1) return distances;",
      "",
      "        {",
      "            min_heap<std::tuple<Distance, int, int>> q;",
      "            auto emplace = [&](const Distance& d_, int h_, int pre = -1){",
      "                int cur = nodes.size();",
      "                q.emplace(d_, h_, cur);",
      "                nodes.emplace_back(d_, h_);",
      "                // prev_node.push_back(pre);",
      "            };",
      "            emplace(d[source] + alloc[h[source]].key, h[source]);",
      "            while (!q.empty() and (int) distances.size() < k) {",
      "                auto [cd, ch, cur] = q.top();",
      "                q.pop();",
      "                distances.push_back(cd);",
      "                path_nodes.push_back(cur);",
      "                if (h[alloc[ch].value.second] != -1) emplace(cd + alloc[h[alloc[ch].value.second]].key, h[alloc[ch].value.second], cur); // add value",
      "                if (alloc[ch].left != -1) emplace(cd + alloc[alloc[ch].left].key - alloc[ch].key, alloc[ch].left, prev_node[cur]); // same heap, add difference",
      "                if (alloc[ch].right != -1) emplace(cd + alloc[alloc[ch].right].key - alloc[ch].key, alloc[ch].right, prev_node[cur]); // same heap, add difference",
      "            }",
      "        }",
      "        return distances;",
      "    }",
      "    auto kth_shortest_full_path(int source, int sink, int k, bool call_k_paths = false) {",
      "        if (call_k_paths) k_shortest_paths(source, sink, k + 1);",
      "        std::vector<std::tuple<int, int, Distance>> path{};",
      "        if (k < 0 or k >= (int) path_nodes.size())",
      "            return path;",
      "        std::vector<std::tuple<int, int, Distance>> sidetracks{};",
      "        {",
      "            int cur = path_nodes[k];",
      "            while (cur != -1) {",
      "                auto nd = nodes[cur];",
      "                auto [u, v] = alloc[nd.second].value;",
      "                // sidetrack = d[v] + w - d[u]",
      "                // w = sidetrack + d[u] - d[v];",
      "                auto w = alloc[nd.second].key + d[u] - d[v];",
      "                sidetracks.emplace_back(u, v, w);",
      "                cur = prev_node[cur];",
      "            }",
      "            std::reverse(sidetracks.begin(), sidetracks.end());",
      "        }",
      "        {",
      "            int idx = 0;",
      "            int cur = source;",
      "            using std::get;",
      "            while (cur != sink or idx < (int) sidetracks.size()){",
      "                if(idx < (int) sidetracks.size() and cur == get<0>(sidetracks[idx])){",
      "                    path.push_back(sidetracks[idx]);",
      "                    cur = get<1>(sidetracks[idx]);",
      "                    idx++;",
      "                }else{",
      "                    int nxt = best[cur];",
      "                    path.emplace_back(cur, nxt, d[cur] - d[nxt]);",
      "                    cur = nxt;",
      "                }",
      "            }",
      "        }",
      "        return path;",
      "    }",
      "};"
    ],
    "description": "KPATH_INDEX_VERSION"
  },
  "k_shortest_walks.cpp": {
    "prefix": "k_shortest_walks",
    "scope": "cpp",
    "body": [
      "/**",
      " * Title: \"Min\" Persistent Leftist Heap",
      " * Repository: https://github.com/Pentagon03/Algorithms/blob/master/Data%20Structures/leftist_heap.cpp",
      " * Reference: nor( https://judge.yosupo.jp/submission/87297 )",
      " */",
      "template <typename Key, typename Value>",
      "struct LeftistHeap {",
      "    using self_t = LeftistHeap<Key, Value>;",
      "    int node_rank;",
      "    Key key;",
      "    Value value;",
      "    self_t *left, *right;",
      "    LeftistHeap(int rank_, Key key_, Value value_, self_t* left_,",
      "                self_t* right_)",
      "            : node_rank{rank_}, key{key_}, value{value_}, left{left_}, right{right_} {}",
      "    // contains Leftistheap itself for each node. We use deque for non-reallocation such as vector. pointers don't get invalidated.",
      "    inline static thread_local std::deque<LeftistHeap> alloc;",
      "    friend self_t* heap_insert(LeftistHeap* a, const Key &k, const Value &v) {",
      "        if (not a or not (a->key < k)) { // Important: k == a.key case should be considerd. if not, k will be repeatively inserted through the whole heap.",
      "            alloc.emplace_back(1, k, v, a, nullptr);",
      "            return &alloc.back();",
      "        }",
      "        auto l = a->left, r = heap_insert(a->right, k, v);",
      "        // Gurantee => l valid and l->rank >= r->rank",
      "        if (not l or l->node_rank < r->node_rank)",
      "            std::swap(l, r);",
      "        alloc.emplace_back(r ? r->node_rank + 1 : 0, a->key, a->value, l, r);",
      "        return &alloc.back();",
      "    }",
      "};",
      "",
      "/**",
      " * Title: K Shortest Walks using Eppstein98(https://ics.uci.edu/~eppstein/pubs/Epp-SJC-98.pdf)",
      " * You can get distances, and recover full path.",
      " * Prerequisite: Leftist Heap(https://github.com/Pentagon03/Algorithms/blob/master/Data%20Structures/leftist_heap.cpp)",
      " * Repository: https://github.com/Pentagon03/Algorithms/blob/master/Graphs/k_shortest_walks.cpp",
      " * Test: https://judge.yosupo.jp/submission/244972",
      " * Test: https://www.acmicpc.net/source/share/ff1b64260b894885b6ed1503fc11c8a7",
      " * Reference: nor( https://judge.yosupo.jp/submission/87297 )",
      " */",
      "",
      "template <class Distance, class WeightedGraph>",
      "struct kShortestWalksSolver{",
      "private:",
      "    const Distance MAX_DISTANCE, IDENTITY_DISTANCE;",
      "    const WeightedGraph& g;",
      "    int n;",
      "    bool is_dag; // contains whether this graph is DAG or not.",
      "    bool negative_edge; // contains whether this graph contains neagative edge weight",
      "",
      "    template <typename T> using min_heap = std::priority_queue<T, std::vector<T>, std::greater<T>>;",
      "    std::vector<Distance> d; // d(x): shortest path from x to sink",
      "    std::vector<int> best; // best(x): next node in the shortest path from x to sink",
      "",
      "    // LeftistHeap: for edge (u, v, w),  sidetrack(u,v,w) weight will be key, edge (u, v) will be value",
      "    using heap_t = LeftistHeap<Distance, std::pair<int, int>>;",
      "    std::vector<heap_t*> h; // contains heap pointer for each node",
      "",
      "    std::vector<Distance> distances; // distance of K-shortest path",
      "",
      "    // We will treat each sidetrack as 'nodes'",
      "    std::vector<heap_t*> nodes; // sidetrack ptrs (change to pair<Distance, heap_t*> if you want to be clear...)",
      "    std::vector<int> prev_node; // previous sidetrack for each sidetrack",
      "",
      "    std::vector<int> path_last_node; // last sidetrack index of \"nodes\" in K-shortest path",
      "public:",
      "    /**",
      "     * Graph g: vector<vector<pair<int,Distance>> or other similar structure.",
      "     * g shoule be given as Reference, should be valid until we use K_Shortest_Paths_Solver.",
      "     * is_dag: whether g is DAG or not.",
      "     * MAX_DISTANCE: maximum value of Distance",
      "     * IDENTITY_DISTANCE: Identity value of Distance",
      "     */",
      "    explicit kShortestWalksSolver(const WeightedGraph& g_, Distance MAX_DISTANCE_, Distance IDENTITY_DISTANCE_, bool is_dag_ = false, bool negative_edge_ = false)",
      "            : g(g_), n(g_.size()), MAX_DISTANCE(MAX_DISTANCE_), IDENTITY_DISTANCE(IDENTITY_DISTANCE_), is_dag(is_dag_), negative_edge(negative_edge_) {}",
      "",
      "    // returns {distance vector, prev vertex vector}",
      "    std::pair<std::vector<Distance>, std::vector<int>> dijkstra(const WeightedGraph& g_, int src) {",
      "        std::vector<Distance> d_(g_.size(), MAX_DISTANCE);",
      "        std::vector<int> prv(g_.size(), -1);",
      "        min_heap<std::pair<Distance, int>> heap;",
      "        heap.emplace(d_[src] = IDENTITY_DISTANCE, src);",
      "        while (!heap.empty()) {",
      "            auto [dv, v] = heap.top();",
      "            heap.pop();",
      "            if (dv != d_[v]) continue;",
      "            for (auto &[to, w] : g_[v]) {",
      "                if (d_[to] > dv + w) {",
      "                    d_[to] = dv + w;",
      "                    heap.emplace(d_[to], to);",
      "                    prv[to] = v;",
      "                }",
      "            }",
      "        }",
      "        return std::make_pair(std::move(d_), std::move(prv));",
      "    }",
      "",
      "    // returns {empty vector, cycle} if there is a negative cycle",
      "    // returns {distance vector, prev vertex vector}",
      "    std::pair<std::vector<Distance>, std::vector<int>> bellman_ford(const WeightedGraph& g_, int src){",
      "        std::vector<Distance> dis(n, MAX_DISTANCE);",
      "        std::vector<int> prv(n, -1);",
      "        auto detect_cycle = [&](int x)->vector<int>{",
      "            vector<bool> vis(n);",
      "            vector<int> t;",
      "            while(true){",
      "                t.push_back(x);",
      "                if(vis[x]) break;",
      "                vis[x] = true;",
      "                x = prv[x];",
      "            }",
      "            int last = t.back();",
      "            reverse(t.begin(), t.end());",
      "            while(t.back() != last) t.pop_back();",
      "            return move(t);",
      "        };",
      "",
      "        std::queue<std::pair<Distance, int>> q({{dis[src] = IDENTITY_DISTANCE, src}}); // SPFA",
      "        for(int i = 1; i <= n and not q.empty(); i++){",
      "            int sz = q.size();",
      "            for(int j = 0; j < sz; j++){",
      "                auto [cur_dis, x] = q.front(); q.pop();",
      "                if(cur_dis > dis[x]) continue;",
      "                for(auto[nx, w]: g_[x]){",
      "                    if(dis[nx] > dis[x] + w){",
      "                        dis[nx] = dis[x] + w;",
      "                        prv[nx] = x;",
      "                        if(i == n){",
      "                            assert(0 and \"Negative Cycle Occured\");",
      "                            return std::make_pair(std::vector<Distance>(), detect_cycle(nx));",
      "                        }",
      "                        q.emplace(dis[nx], nx);",
      "                    }",
      "                }",
      "            }",
      "        }",
      "        return std::make_pair(std::move(dis), std::move(prv));",
      "    }",
      "",
      "    // O(|E| + |V|)",
      "    std::vector<int> topology_sort(const WeightedGraph& g_){",
      "        const int n_ = g_.size();",
      "        std::vector<int> in_deg(n_, 0);",
      "        for(int u = 0; u < n_; u++)",
      "            for(auto &[v, w]: g_[u])",
      "                in_deg[v]++;",
      "        std::queue<int> q;",
      "        for(int u = 0; u < n_; u++)",
      "            if(not in_deg[u])",
      "                q.push(u);",
      "        std::vector<int> order(n_);",
      "        for(auto &u : order){",
      "            if(q.empty()) {",
      "                assert(0 && \"Cycle occured in DAG\");",
      "                return order;",
      "            }",
      "            u = q.front();",
      "            q.pop();",
      "            for(auto &[v, w]: g_[u])",
      "                if(--in_deg[v] == 0)",
      "                    q.push(v);",
      "        }",
      "        return move(order);",
      "    }",
      "",
      "    // O(|E| + |V|)",
      "    // returns",
      "    std::pair<vector<Distance>, vector<int>> shortest_path_dag(const WeightedGraph& g_, int s){",
      "        std::vector<Distance> d_(g_.size(), MAX_DISTANCE);",
      "        std::vector<int> prv(g_.size(), -1);",
      "        d_[s] = IDENTITY_DISTANCE;",
      "        auto order = topology_sort(g_);",
      "        for(auto v: order){",
      "            if(d_[v] == MAX_DISTANCE) continue;",
      "            for(auto &[to, w] : g_[v]){",
      "                if(d_[to] > d_[v] + w){",
      "                    d_[to] = d_[v] + w;",
      "                    prv[to] = v;",
      "                }",
      "            }",
      "        }",
      "        return std::make_pair(move(d_), move(prv));",
      "    }",
      "",
      "    // O(|E| log |V| + |K|)",
      "    // returns vector of distances",
      "    std::vector<Distance> k_shortest_paths(int source, int sink, int k) {",
      "        WeightedGraph g_rev(n);",
      "        for (int u = 0; u < n; ++u)",
      "            for (auto &[v, w] : g[u])",
      "                g_rev[v].push_back({u, w});",
      "        if(is_dag) std::tie(d, best) = shortest_path_dag(g_rev, sink);",
      "        else if(not negative_edge) std::tie(d, best) = dijkstra(g_rev, sink);",
      "        else std::tie(d, best) = bellman_ford(g_rev, sink);",
      "",
      "        if (d[source] == MAX_DISTANCE)",
      "            return move(std::vector<Distance>{});",
      "",
      "        std::vector<std::basic_string<int>> tree(n);",
      "        for (int u = 0; u < n; ++u)",
      "            if (best[u] != -1)",
      "                tree[best[u]].push_back(u); // u will adopt best[u]'s heap",
      "",
      "        h = std::vector<heap_t*>(n, nullptr);",
      "        {",
      "            std::queue<int> q({sink});",
      "            while (!q.empty()) {",
      "                auto u = q.front();",
      "                q.pop();",
      "                bool seen_p = false;",
      "                for (auto [v, w] : g[u]) {",
      "                    if (d[v] == MAX_DISTANCE)",
      "                        continue;",
      "                    auto c = w + d[v] - d[u];",
      "                    if (not seen_p and v == best[u] and c == IDENTITY_DISTANCE) {",
      "                        seen_p = true; // we can only skip once.",
      "                        continue;",
      "                    }",
      "                    h[u] = heap_insert(h[u], c, {u, v});",
      "                }",
      "                for (auto p : tree[u]) h[p] = h[u], q.push(p); // This works fast since this is basically a pointer",
      "            }",
      "        }",
      "",
      "        distances = std::vector<Distance>{d[source]};",
      "        distances.reserve(k);",
      "        path_last_node = std::vector<int>{-1};",
      "        path_last_node.reserve(k);",
      "",
      "        nodes = std::vector<heap_t*>{};",
      "        nodes.reserve(3 * k);",
      "        prev_node = std::vector<int>{};",
      "        prev_node.reserve(3 * k);",
      "",
      "        if (not h[source])",
      "            return move(distances);",
      "",
      "        {",
      "            min_heap<std::tuple<Distance, heap_t*, int>> q;",
      "            auto emplace = [&](const Distance& d_, heap_t* h_, int pre = -1){",
      "                int cur = nodes.size();",
      "                q.emplace(d_, h_, cur);",
      "                nodes.push_back(h_);",
      "                prev_node.push_back(pre);",
      "            };",
      "",
      "            emplace(d[source] + h[source]->key, h[source], -1);",
      "            while (!q.empty() and (int) distances.size() < k) {",
      "                auto [cd, ch, cur] = q.top();",
      "                q.pop();",
      "                distances.push_back(cd);",
      "                path_last_node.push_back(cur);",
      "                if (h[ch->value.second]) emplace(cd + h[ch->value.second]->key, h[ch->value.second], cur); // add value",
      "                if (ch->left) emplace(cd + ch->left->key - ch->key, ch->left, prev_node[cur]); // same heap, add difference",
      "                if (ch->right) emplace(cd + ch->right->key - ch->key, ch->right, prev_node[cur]); // same heap, add difference",
      "            }",
      "        }",
      "        return move(distances);",
      "    }",
      "",
      "    // returns list of edges",
      "    std::vector<std::tuple<int, int, Distance>> kth_shortest_full_path(int source, int sink, int k, bool call_k_paths = false) {",
      "        if (call_k_paths)",
      "            k_shortest_paths(source, sink, k + 1);",
      "        std::vector<std::tuple<int, int, Distance>> path{};",
      "        if (k < 0 or k >= path_last_node.size())",
      "            return path;",
      "        std::vector<std::tuple<int, int, Distance>> sidetracks{};",
      "        {",
      "            int cur = path_last_node[k];",
      "            while (cur != -1) {",
      "                auto nd = nodes[cur];",
      "                auto [u, v] = nd->value;",
      "                // sidetrack = d[v] + w - d[u] => w = sidetrack + d[u] - d[v];",
      "                auto w = nd->key + d[u] - d[v];",
      "                sidetracks.emplace_back(u, v, w);",
      "                cur = prev_node[cur];",
      "            }",
      "            std::reverse(sidetracks.begin(), sidetracks.end());",
      "        }",
      "        {",
      "            int idx = 0;",
      "            int cur = source;",
      "            using std::get;",
      "            while (cur != sink or idx < (int) sidetracks.size()){",
      "                if(idx < (int) sidetracks.size() and cur == get<0>(sidetracks[idx])){",
      "                    path.push_back(sidetracks[idx]);",
      "                    cur = get<1>(sidetracks[idx]);",
      "                    idx++;",
      "                }else{",
      "                    int nxt = best[cur];",
      "                    path.emplace_back(cur, nxt, d[cur] - d[nxt]);",
      "                    cur = nxt;",
      "                }",
      "            }",
      "        }",
      "        return move(path);",
      "    }",
      "};"
    ],
    "description": "k_shortest_walks"
  },
  "SCC_Kosaraju.cpp": {
    "prefix": "SCC_Kosaraju",
    "scope": "cpp",
    "body": [
      "/*",
      "Find Stronly Connected Components",
      "Kosaraju's algorithm",
      "O(V+E)",
      "test: https://atcoder.jp/contests/practice2/submissions/53194190",
      "*/",
      "struct scc_graph{",
      "    using vi = vector<int>;",
      "    int n, scnt;",
      "    bool called;",
      "    vector<vi> g, gR, groups;",
      "    vector<bool> vis;",
      "    vi S, scc_id;",
      "    scc_graph(int _n=0):n(_n), scnt(0), called(false), g(_n), gR(_n), scc_id(_n), vis(_n){}",
      "    void add_edge(int a,int b){",
      "        g[a].push_back(b);",
      "        gR[b].push_back(a);",
      "    }",
      "    void dfs(int v, bool rev = false){",
      "        vis[v] = true;",
      "        auto&G = !rev ? g: gR;",
      "        if(rev) scc_id[v] = scnt;",
      "        for(auto nxt:G[v])",
      "            if(!vis[nxt])",
      "                dfs(nxt, rev);",
      "        if(!rev) S.push_back(v);",
      "    }",
      "    vector<vi> scc(){",
      "        assert(!called && \"This should be called once\");",
      "        called = true;",
      "        for(int i=0;i<n;i++) if(!vis[i]) dfs(i, false);",
      "        vis.assign(n, false);",
      "        reverse(S.begin(), S.end());",
      "        // S in topological order",
      "        for(int x: S) if(!vis[x]) dfs(x, true), scnt++;",
      "        vi counts(scnt);",
      "        for(int i=0;i<n;i++) counts[scc_id[i]]++;",
      "        groups.resize(scnt);",
      "        for(int i=0;i<scnt;i++) groups[i].reserve(counts[i]);",
      "        for(int i=0;i<n;i++) groups[scc_id[i]].push_back(i);",
      "        return groups;",
      "    }",
      "};"
    ],
    "description": "SCC_Kosaraju"
  },
  "SCC_Tarjan.cpp": {
    "prefix": "SCC_Tarjan",
    "scope": "cpp",
    "body": [
      "/*",
      "Find Stronly Connected Components",
      "Tarjan's algorithm",
      "O(V+E)",
      "test: https://atcoder.jp/contests/practice2/submissions/53219246",
      "latest version: https://github.com/Pentagon03/Algorithms/blob/master/Graphs/SCC_Tarjan.cpp",
      "*/",
      "struct scc_graph{",
      "    using vi = vector<int>;",
      "    int n, pv, scnt;",
      "    bool called;",
      "    vector<vi> g;",
      "    vi dfsn, low, id, stk;",
      "    vector<bool> in_stk;",
      "    scc_graph(int _n=0):n(_n), called(false), g(n){}",
      "    void add_edge(int a,int b){ g[a].push_back(b);}",
      "    void dfs(int x){",
      "        dfsn[x] = low[x] = ++pv;",
      "        stk.push_back(x); in_stk[x] = true;",
      "        for(int nx:g[x]){",
      "            if(!dfsn[nx]){",
      "                dfs(nx);",
      "                low[x] = min(low[x], low[nx]);",
      "            }else if(in_stk[nx]){",
      "                // dfs(nx) didnt end, so dfn[nx] == low[nx]",
      "                low[x] = min(low[x], dfsn[nx]);",
      "            }",
      "        }",
      "        if(low[x] == dfsn[x]){",
      "            int y; do{",
      "                y = stk.back(); stk.pop_back();",
      "                in_stk[y] = false;",
      "                id[y] = scnt;",
      "            }while(y != x);",
      "            scnt++;",
      "        }",
      "    }",
      "    void reset(){called = false;}",
      "    void _get_scc(){",
      "        called = true;",
      "        dfsn = low = id = vector<int>(n); stk = vector<int>();",
      "        in_stk = vector<bool>(n);",
      "        pv = scnt = 0;",
      "        for(int i=0;i<n;i++) if(!dfsn[i]) dfs(i);",
      "        for(int&k: id) k = (scnt-1) - k;",
      "    }",
      "    vi scc_id(){",
      "        if(!called) _get_scc();",
      "        return id;",
      "    }",
      "    vector<vi> scc(){",
      "        if(!called) _get_scc();",
      "        vector<vi> groups(scnt);",
      "        vi counts(scnt);",
      "        for(int k: id) ++counts[k];",
      "        for(int i=0;i<scnt;i++) groups[i].reserve(counts[i]);",
      "        for(int i=0;i<n;i++) groups[id[i]].push_back(i);",
      "        return groups;",
      "    }",
      "};"
    ],
    "description": "SCC_Tarjan"
  },
  "two_sat.cpp": {
    "prefix": "two_sat",
    "scope": "cpp",
    "body": [
      "// Include => SCC latest version: https://github.com/Pentagon03/Algorithms/blob/master/Graphs/SCC_Tarjan.cpp",
      "",
      "/*",
      "two_sat",
      "there should be scc_graph struct on top: https://github.com/Pentagon03/Algorithms/blob/master/Graphs/SCC_Tarjan.cpp",
      "reference1: https://github.com/kth-competitive-programming/kactl/blob/main/content/graph/2sat.h",
      "reference2: https://atcoder.github.io/ac-library/production/document_en/twosat.html",
      "test: https://atcoder.jp/contests/practice2/submissions/53219502",
      "*/",
      "struct two_sat{",
      "    using vi = vector<int>;",
      "    int n;",
      "    vector<bool> ans;",
      "    scc_graph scc;",
      "    two_sat(int _n=0):n(_n), scc(2*n){}",
      "    // 2x + 0: false, 2x + 1: true",
      "    inline int idx(int i, bool a){return 2*i+a;}",
      "    vector<pii> stk; // optional",
      "    void pop_clause(){ // optional",
      "        assert(stk.size() > 0 && \"stk not empty\");",
      "        auto[x,y] = stk.back(); stk.pop_back();",
      "        scc.g[x^1].pop_back(); scc.g[y^1].pop_back();",
      "    }",
      "    // (x OR y) <=> (~x -> y AND ~y -> x)",
      "    void add_clause(int x,int y){",
      "        // stk.emplace_back(x, y); // optional",
      "        scc.add_edge(x^1, y); scc.add_edge(y^1, x);",
      "    }",
      "    // (i = a OR j = b) <=> if one is false, the other is true",
      "    void add_clause(int i, bool a, int j, bool b){",
      "        assert(0 <= i && i < n && \"i in range\");",
      "        assert(0 <= j && j < n && \"j in range\");",
      "        add_clause(idx(i, a), idx(j, b));",
      "    }",
      "    // ((i == a) == (j == b))   <-> not ( (i == a and j == !b) or (i==!a and j==b) ) <=> (i==!a or j ==b) and (i==a or j==!b)",
      "    void is_equal(int i, bool a, int j, bool b){",
      "        add_clause(i, a, j, !b);",
      "        add_clause(i, !a, j, b);",
      "    }",
      "    void atMostOneNaive(const vector<pair<int,bool>>& v){",
      "        if(v.size() <= 1) return;",
      "        for(int i=0;i<v.size();i++)",
      "            for(int j=i+1;j<v.size();j++)",
      "                add_clause(v[i].first, !v[i].second, v[j].first, !v[j].second);",
      "    }",
      "    int addVar(){",
      "        scc.n += 2; scc.g.resize(scc.n);",
      "        return n++;",
      "    }",
      "    void atMostOne(const vector<pair<int,bool>>& v){",
      "        if(v.size() <= 1) return;",
      "        if(v.size() <= 4){",
      "            atMostOneNaive(v);",
      "            return;",
      "        }",
      "        auto [cur, a] = v[0]; cur = idx(cur, !a);",
      "        for(int i=2;i<v.size();i++){",
      "            int next = addVar();  next = idx(next, true);",
      "            auto [x, b] = v[i]; x = idx(x, b);",
      "            add_clause(cur, x^1);",
      "            add_clause(cur, next);",
      "            add_clause(x^1, next);",
      "            cur = next^1;",
      "        }",
      "        auto [nxt, b] = v[1]; nxt = idx(nxt, b);",
      "        add_clause(cur, nxt ^ 1);",
      "    }",
      "    bool satisfiable() {",
      "        scc.reset();",
      "        auto&&id = scc.scc_id();",
      "        ans = vector<bool>(n);",
      "        for(int i = 0; i < n; i++){",
      "            if(id[2*i] == id[2*i+1]) return false; // (i, false) and (i, true) in same SCC",
      "            ans[i] = id[2*i+1] > id[2*i];",
      "        }",
      "        return true;",
      "    }",
      "    vector<bool> answer(){",
      "        if(ans.size() == 0) satisfiable();",
      "        return ans;",
      "    }",
      "};"
    ],
    "description": "two_sat"
  },
  "WeightedGraph.cpp": {
    "prefix": "WeightedGraph",
    "scope": "cpp",
    "body": [
      "/**",
      " * Graph with Weighted Edges",
      " * Bellman Ford Validation: https://www.acmicpc.net/source/share/066ba979355348c5aefde66f11aa2dae",
      " */",
      "template<typename W = int>",
      "struct WeightedGraph{",
      "    static constexpr W INF_ = numeric_limits<W>::max() / 2; // INF + INF doesn't overflow",
      "    using Edge = tuple<int, int, W>;",
      "    int n; // vertex from 0 to n-1",
      "    vector<vector<pair<int, W>>> g;",
      "    WeightedGraph(int n_):n(n_), g(n){}",
      "    void add_edge(int a, int b, W w = 1, bool directed = true){",
      "        assert(a < n and b < n);",
      "        g[a].emplace_back(b, w);",
      "        if(not directed) g[b].emplace_back(a, w);",
      "    }",
      "    void add_edges(const vector<Edge>&edge_list, bool directed = true){",
      "        for(auto&[a, b, w]: edge_list)",
      "            add_edge(a, b, w, directed);",
      "    }",
      "    void add_edges(const vector<pair<int,int>>&edge_list, bool directed = true){",
      "        for(auto&[a, b]: edge_list)",
      "            add_edge(a, b);",
      "    }",
      "    void shuffle(){",
      "        static mt19937 rng(std::chrono::steady_clock::now().time_since_epoch().count());",
      "        for(int i=0;i<n;i++){",
      "            if(g[i].size()){",
      "                std::shuffle(g[i].begin(), g[i].end(), rng);",
      "            }",
      "        }",
      "    }",
      "    vector<vector<int>> connected_components_undirected(){",
      "        vector<vector<int>> ans;",
      "        vector<bool> vis(n);",
      "        vector<int> t;",
      "        auto dfs = [&](auto&self, int x)->void{",
      "            vis[x] = true; t.push_back(x);",
      "            for(auto[nx, w]: g[x]) if(not vis[nx]) self(self, nx);",
      "        };",
      "        for(int i=0;i<n;i++){",
      "            if(not vis[i]){",
      "                t.clear();",
      "                dfs(dfs, i);",
      "                ans.push_back(move(t));",
      "            }",
      "        }",
      "        return move(ans);",
      "    }",
      "    template<typename T>",
      "    using min_heap = priority_queue<T, vector<T>, greater<T>>;",
      "    // INF + INF shouldn't overflow",
      "    pair<vector<W>, vector<int>> dijkstra(int src, int max_step = -1, W INF = INF_){",
      "        vector<W> dis(n, INF);",
      "        vector<int> d(n, -1);",
      "        min_heap<pair<W,int>> pq;",
      "        pq.emplace(dis[src] = 0, src);",
      "        if(max_step == -1) max_step = n;",
      "        for(int i = 0; i < max_step and not pq.empty();){",
      "            auto [cur_dis, x] = pq.top(); pq.pop();",
      "            if(cur_dis > dis[x]) continue;",
      "            i++; // ith permanent node",
      "            for(auto[nx, w]: g[x]){",
      "                int val = cur_dis + w;",
      "                if(dis[nx] > val){",
      "                    dis[nx] = val;",
      "                    d[nx] = x;",
      "                    pq.emplace(val, nx);",
      "                }",
      "            }",
      "        }",
      "        return {move(dis), move(d)};",
      "    }",
      "    // returns {empty vector, cycle} if there is a negative cycle",
      "    pair<vector<W>, vector<int>> bellman_ford(int src, bool &neg_cycle, int max_step = -1, W INF = INF_){",
      "        vector<W> dis(n, INF);",
      "        vector<int> d(n, -1);",
      "        queue<pair<W, int>> q({{dis[src] = 0, src}}); // SPFA",
      "        vector<bool> inq(n, false);",
      "        inq[src] = true;",
      "        auto detect_cycle = [&](int x)->vector<int>{",
      "            vector<bool> vis(n);",
      "            vector<int> t;",
      "            while(true){",
      "                t.push_back(x);",
      "                if(vis[x]) break;",
      "                vis[x] = true;",
      "                x = d[x];",
      "            }",
      "            int last = t.back();",
      "            reverse(t.begin(), t.end());",
      "            while(t.back() != last) t.pop_back();",
      "            return move(t);",
      "        };",
      "        if(max_step == -1) max_step = n;",
      "        for(int i = 1; i <= max_step and not q.empty(); i++){",
      "            int sz = q.size();",
      "            for(int j = 0; j < sz; j++){",
      "                auto [cur_dis, x] = q.front(); q.pop();",
      "                inq[x] = false;",
      "                // if(cur_dis > dis[x]) continue;",
      "                for(auto[nx, w]: g[x]){",
      "                    if(dis[nx] > dis[x] + w){",
      "                        dis[nx] = dis[x] + w;",
      "                        d[nx] = x;",
      "                        if(i == n){",
      "                            neg_cycle = true;",
      "                            return {{}, detect_cycle(nx)};",
      "                        }",
      "                        if(not inq[nx]){",
      "                            q.emplace(dis[nx], nx);",
      "                            inq[nx] = true;",
      "                        }",
      "                    }",
      "                }",
      "            }",
      "        }",
      "        neg_cycle = false;",
      "        return {move(dis), move(d)};",
      "    }",
      "    vector<int> topological_sort(){",
      "        vector<bool> vis(n);",
      "        vector<int> ans;",
      "        auto dfs = [&](auto&self, int x)->void{",
      "            vis[x] = true;",
      "            for(auto[nx, w]: g[x]) if(not vis[nx]) self(self, nx);",
      "            ans.push_back(x);",
      "        };",
      "        for(int i=0;i<n;i++) if(not vis[i]) dfs(dfs, i);",
      "        reverse(ans.begin(), ans.end());",
      "        return move(ans);",
      "    }",
      "    pair<vector<W>, vector<int>> dag_shortest_path(int src, W INF = INF_){",
      "        vector<W> dis(n, INF);",
      "        vector<int> d(n, -1);",
      "        vector<int> vtx = topological_sort();",
      "        dis[src] = 0;",
      "        for(int x: vtx){",
      "            if(dis[x] == INF) continue;",
      "            for(auto[nx, w]: g[x]){",
      "                int val = dis[x] + w;",
      "                if(dis[nx] > val){",
      "                    dis[nx] = val;",
      "                    d[nx] = x;",
      "                }",
      "            }",
      "        }",
      "        return {move(dis), move(d)};",
      "    }",
      "    // we assume there is path. returns series of edges",
      "    vector<Edge> find_path(int src, int dest, const vector<int>& dis, const vector<int>& d){",
      "        vector<Edge> ans;",
      "        int cur = dest;",
      "        while(cur != src){",
      "            int prv = d[cur];",
      "            ans.emplace_back(prv, cur, dis[cur] - dis[prv]);",
      "            cur = prv;",
      "        }",
      "        assert(cur == src);",
      "        reverse(ans.begin(), ans.end());",
      "        return move(ans);",
      "    }",
      "    pair<vector<vector<W>>, vector<vector<int>>> floyd_warshall(bool &neg_cycle, int max_node = -1, W INF = INF_){",
      "        vector dis(n, vector<W>(n, INF));",
      "        vector d(n, vector<int>(n, -1));",
      "        for(int x=0;x<n;x++)",
      "            for(auto[nx, w]: g[x])",
      "                if(dis[x][nx] > w){",
      "                    dis[x][nx] = w;",
      "                    d[x][nx] = x;",
      "                    if(x == nx and w < 0){",
      "                        neg_cycle =  true;",
      "                        return {{}, {{x, x}}};",
      "                    }",
      "                }",
      "        for(int i=0;i<n;i++) dis[i][i] = 0, d[i][i] = -1;",
      "        auto detect_cycle = [&](int x)->vector<int>{",
      "            vector<int> t;",
      "            int from = x, to = x, cur = x;",
      "            t.push_back(cur);",
      "            cur = d[from][cur];",
      "            while(true){",
      "                t.push_back(cur);",
      "                if(cur == from) break;",
      "                cur = d[from][cur];",
      "            }",
      "            reverse(t.begin(), t.end());",
      "            return move(t);",
      "        };",
      "        if(max_node == -1) max_node = n - 1;",
      "        for(int m=0; m<=max_node; m++)",
      "            for(int s=0; s<n; s++)",
      "                for(int e=0; e<n; e++){",
      "                    if(dis[s][m] == INF or dis[m][e] == INF) continue;",
      "                    auto val = dis[s][m] + dis[m][e];",
      "                    if(dis[s][e] > val){",
      "                        dis[s][e] = val;",
      "                        d[s][e] = d[m][e];",
      "                        if(s == e and val < 0){",
      "                            neg_cycle = true;",
      "                            return {{}, {detect_cycle(s)}};",
      "                        }",
      "                    }",
      "                }",
      "        neg_cycle = false;",
      "        return {move(dis), move(d)};",
      "    }",
      "    // we assume there is path. returns series of edges",
      "    vector<int> find_path_floyd_warshall(int from, int to, const vector<vector<int>>& d){",
      "        vector<int> t;",
      "        int cur = to;",
      "        while(true){",
      "            t.push_back(cur);",
      "            if(cur == from) break;",
      "            cur = d[from][cur];",
      "        }",
      "        reverse(t.begin(), t.end());",
      "        return move(t);",
      "    }",
      "};"
    ],
    "description": "WeightedGraph"
  },
  "WeightedTree.cpp": {
    "prefix": "WeightedTree",
    "scope": "cpp",
    "body": [
      "/**",
      " * Tree with Weighted Edges",
      " */",
      "using W = int;",
      "constexpr W INF_ = numeric_limits<W>::max() / 2; // INF + INF doesn't overflow",
      "// call init before doing smth",
      "struct WeightedTree{",
      "    using Edge = tuple<int, int, W>;",
      "    int n; // vertex from 0 to n-1",
      "    vector<vector<pair<int, W>>> g;",
      "    int pv;",
      "    vector<int> in, out;",
      "    vector<W> dep;",
      "    const int lg;",
      "    vector<vector<int>> up; // up[i][x] -> ith parent of x",
      "    WeightedTree(int n_):n(n_), g(n), pv(0), in(n), out(n), dep(n), lg(__lg(n)), up(lg+1, vector<int>(n, -1)){}",
      "    void add_edge(int a, int b, W w = 1){",
      "        assert(a < n and b < n);",
      "        g[a].emplace_back(b, w);",
      "        g[b].emplace_back(a, w);",
      "    }",
      "    void add_edges(const vector<Edge>&edge_list){",
      "        for(auto&[a, b, w]: edge_list)",
      "            add_edge(a, b, w);",
      "    }",
      "    void add_edges(const vector<pair<int,int>>&edge_list){",
      "        for(auto&[a, b]: edge_list)",
      "            add_edge(a, b);",
      "    }",
      "    void init(int root){",
      "        dfs(root, -1);",
      "    }",
      "    void dfs(int x,int p){",
      "        in[x] = pv++;",
      "        up[0][x] = p;",
      "        for(int i=1;up[i-1][x] != -1;i++)",
      "            up[i][x] = up[i-1][up[i-1][x]];",
      "        for(auto[nx, w]: g[x])",
      "            if(nx != p){",
      "                dep[nx] = dep[x] + w;",
      "                dfs(nx, x);",
      "            }",
      "        out[x] = pv;",
      "    }",
      "    int go_up(int x,int cnt){",
      "        assert(cnt >= 0);",
      "        if(cnt==0) return x;",
      "        for(int i=lg;i>=0;i--)",
      "            if((cnt>>i) & 1)",
      "                x = up[i][x];",
      "        return x;",
      "    }",
      "    bool is_ancestor(int u, int v){",
      "        if(u == -1) return true;",
      "        if(v == -1) return false;",
      "        return in[u] <= in[v] and out[v] <= out[u];",
      "    }",
      "    int lca(int u,int v){",
      "        if(is_ancestor(u, v)) return u;",
      "        if(is_ancestor(v, u)) return v;",
      "        for(int i=lg;i>=0;i--)",
      "            if(not is_ancestor(up[i][u], v))",
      "                u = up[i][u];",
      "        return up[0][u];",
      "    }",
      "    int tree_dist(int u,int v){",
      "        int l = lca(u, v);",
      "        return dep[u] + dep[v] - 2 * dep[l];",
      "    }",
      "    // is x on (u->p);",
      "    bool on_ancestor_path(int u, int p, int x){",
      "        assert(is_ancestor(p, u));",
      "        return is_ancestor(x, u) and is_ancestor(p, x);",
      "    }",
      "    // is x on (u->v)",
      "    bool on_path(int u,int v,int x){",
      "        int l = lca(u, v);",
      "        return on_ancestor_path(u, l, x) || on_ancestor_path(v, l, x);",
      "    }",
      "    // only when all w = 1",
      "    int tree_mid(int u, int v){",
      "        int d = tree_dist(u, v);",
      "        if(d & 1) return -1;",
      "        if(dep[u]<dep[v]) swap(u,v);",
      "        return go_up(u, d/2);",
      "    }",
      "};"
    ],
    "description": "WeightedTree"
  },
  "crt.cpp": {
    "prefix": "crt",
    "scope": "cpp",
    "body": [
      "/*",
      "CRT that can handle every case",
      "reference: https://qoj.ac/submission/30536",
      "*/",
      "",
      "// PUT EXT_GCD HERE: https://github.com/Pentagon03/Algorithms/blob/master/Math/ext_gcd%26inv.cpp",
      "",
      "// using lll = __int128_t;",
      "struct cong{ll a, m;}; // a mod m",
      "cong crt_merge(const cong &c1, const cong &c2){",
      "    auto[xa, xm] = c1; auto[ya, ym] = c2;",
      "    auto [g,x,y] = ext_gcd(xm, ym);",
      "    // xm * x + ym * y = g;",
      "    if((ya-xa) % g != 0) return cong{-1,0};",
      "    auto ga = (ya-xa)/g;",
      "    // xm * (x * ga) + ym * (y * ga) = ya - xa",
      "    // xm * (x * ga) + xa = ym * (-y*gb) +  ya",
      "    auto yt = ym / g;",
      "    x = (x * ga % yt + yt) % yt;",
      "    return cong{xm * x + xa, xm * yt};",
      "}",
      "cong crt(const vector<cong> &cgv) {",
      "    auto ans = cong{0,1};",
      "    for(const auto&cg: cgv){",
      "        assert(cg.m != 0 && \"mod not 0\");",
      "        ans = crt_merge(ans, cg);",
      "        if(ans.m == 0) return ans;",
      "    }",
      "    return ans;",
      "}"
    ],
    "description": "crt"
  },
  "crt_coprime.cpp": {
    "prefix": "crt_coprime",
    "scope": "cpp",
    "body": [
      "/*",
      "put \"ext_gcd and inv\" here",
      "https://github.com/Pentagon03/Algorithms/blob/master/Math/ext_gcd%26inv.cpp",
      "*/",
      "",
      "/*",
      "Chinese Remainder Theorem when only it's pairwise coprime",
      "reference: https://cp-algorithms.com/algebra/chinese-remainder-theorem.html",
      "*/",
      "struct cong{ll a, m;};",
      "// (a, m) -> a mod m",
      "cong crt(const vector<cong> &cgv) {",
      "    // assume all mods are coprime each other",
      "    if(cgv.size() == 1) return cgv[0];",
      "    ll M = 1;",
      "    for (const auto& cg : cgv) M *= cg.m;",
      "    ll ans = 0;",
      "    for (auto [a_i, m_i]: cgv) {",
      "        ll M_i = M / m_i;",
      "        ll N_i = inv(M_i, m_i);",
      "        ans = (ans + a_i * M_i % M * N_i) % M;",
      "    }",
      "    return cong{ans, M};",
      "}"
    ],
    "description": "crt_coprime"
  },
  "DiscreteLogarithm_Prime.cpp": {
    "prefix": "DiscreteLogarithm_Prime",
    "scope": "cpp",
    "body": [
      "/*",
      "Fast Discrete Logarithm for Prime mods using Phollig-hellman",
      "use phollig_hellman(base, val, p) for prime p",
      "find dlog s.t pow(base, dlog) mod p == val",
      "Reference: https://rkm0959.tistory.com/187",
      "*/",
      "namespace DiscreteLog{",
      "    // using pii = pair<int,int>;",
      "    int get_random_int(int l,int r) {",
      "        static random_device rd;",
      "        return uniform_int_distribution<int>(l,r)(rd);",
      "    }",
      "",
      "    inline int powmod(int x,int n,int mod=inf){",
      "        int ans=1;",
      "        for(;n;n>>=1){",
      "            if(n&1) ans=1LL*ans*x%mod;",
      "            x=1LL*x*x%mod;",
      "        }",
      "        return ans;",
      "    }",
      "",
      "    vector<pii> get_divisor(int n){",
      "        vector<pii> div;",
      "        for(int i=2;i*i<=n;i++){",
      "            int cnt = 0;",
      "            while(n % i == 0){",
      "                n /= i;",
      "                ++cnt;",
      "            }",
      "            if(cnt>0) div.emplace_back(i,cnt);",
      "        }",
      "        if(n>1) div.emplace_back(n,1);",
      "        return div;",
      "    }",
      "",
      "    int get_order_prime(int g,int p){",
      "        assert(gcd(g, p) == 1);",
      "        if(g==1) return 1;",
      "        int pm = p-1;",
      "        vector<pii> div = get_divisor(pm);",
      "        int ans = pm;",
      "        for(auto[pi,cnt]: div){",
      "            for(int i=0;i<cnt && powmod(g, ans / pi, p) == 1; i++)",
      "                ans /= pi;",
      "        }",
      "        return ans;",
      "    }",
      "",
      "    bool is_primitive(int g, int p){",
      "        // return get_order_prime(g,p) == p-1;",
      "        int pm = p-1;",
      "        vector<pii> div = get_divisor(pm);",
      "        for(auto[pi,cnt]:div)",
      "            if(powmod(g, pm / pi, p) == 1)",
      "                return false;",
      "        return true;",
      "    }",
      "",
      "    int get_primitive(int p){",
      "        // p is a prime, so it has a primitive root of course",
      "        int pm = p-1;",
      "",
      "        if(p<300){",
      "            for(int g=2;g<=pm;g++)",
      "                if(is_primitive(g, p))",
      "                    return g;",
      "        }",
      "        else{",
      "            while(true){",
      "                int g = get_random_int(2,pm);",
      "                if(is_primitive(g,p))",
      "                    return g;",
      "            }",
      "        }",
      "",
      "        //never reaches here.",
      "        return -1;",
      "    }",
      "",
      "    int dlog(int base, int val, int p,int ord = -1){",
      "        base %= p; val %= p;",
      "        if(val == 1) return 0;",
      "        if(base == val) return 1;",
      "        if(base == 0) return -1;",
      "        // const int B = sqrt(get_order_prime(base,p)) + 1;",
      "        if(ord == -1) ord = get_order_prime(base, p);",
      "        const int B = sqrt(ord) + 2;",
      "        vector<pii> s;",
      "        int x = 1;",
      "        for(int v=0;v<B;v++){",
      "            if(x==val) return v;",
      "            s.emplace_back(x,v);",
      "            x = 1LL * x * base % p;",
      "        }",
      "        sort(begin(s), end(s));",
      "        x = val;",
      "        int t = powmod(base, p-1-B, p);",
      "        for(int u=0;u<B;u++){",
      "            auto it = lower_bound(all(s), pii(x,0));",
      "            if(it != s.end() && it->first == x)",
      "                return u * B + it->second;",
      "            x = 1LL * x * t % p;",
      "        }",
      "        return -1;",
      "    }",
      "",
      "    ll ext_gcd(ll a, ll b, ll& x, ll& y) {",
      "        assert(a>=0 && b>=0); // it actually works when a<0 or b<0",
      "        ll g = a;",
      "        x = 1; y = 0;",
      "        // note that x and y are swapped",
      "        if(b != 0) g = ext_gcd(b, a%b, y, x), y -= a/b*x;",
      "        return g;",
      "    }",
      "",
      "    ll inv(ll a, ll m){",
      "        // return x that a * x = 1 mod m",
      "        ll x, y;",
      "        ll g = ext_gcd(a, m, x, y);",
      "        if(g != 1) return -1;",
      "        return (x%m + m) % m;",
      "    }",
      "",
      "    int pohlig_hellman(int base,int val,int p){",
      "        if((base %= p) < 0) base += p;",
      "        if((val %= p) < 0) val += p;",
      "        if(val == 1) return 0;",
      "        if(base == val) return 1;",
      "        if(base == 0) return -1;",
      "        vector<pii> div;",
      "        int pm = get_order_prime(base, p);",
      "        div = get_divisor(pm);",
      "        int ans = 0, m = 1;",
      "        for(auto[pi, ei]: div){",
      "            int nbase = powmod(base, pm / pi, p);",
      "            int npm = pm;",
      "            int pipow = 1;",
      "            int r = 0;",
      "            for(int e=1;e<=ei;e++){",
      "                // find x mod pi^e such that (g^(pm/(pi^e)))^x = h^(pm/(pi^e))",
      "                // x = pi^e-1 * k + r",
      "                npm /= pi;",
      "                int k = dlog(nbase, 1LL * powmod(val, npm, p) * powmod(base, 1LL * npm * (p-1-r) % (p-1), p) % p, p, pi);",
      "                if(k==-1) return -1;",
      "                assert(k < pi);",
      "                r = pipow * k + r;",
      "                pipow *= pi;",
      "                r %= pipow;",
      "            }",
      "            // r mod pi^ei",
      "            if(m==1){",
      "                ans = r;",
      "                m = pipow;",
      "            }else{",
      "                ll x, y;",
      "                int nxtm = m * pipow;",
      "                ext_gcd(m, pipow, x, y); // mx + pipow y = 1;",
      "                x %= nxtm; y %= nxtm;",
      "                ans = (1LL*ans* pipow %nxtm *y %nxtm + 1LL* r * m %nxtm * x %nxtm)%nxtm;",
      "                if(ans<0) ans += nxtm;",
      "                m = nxtm;",
      "            }",
      "        }",
      "        return ans;",
      "    }",
      "}"
    ],
    "description": "DiscreteLogarithm_Prime"
  },
  "divmod.cpp": {
    "prefix": "divmod",
    "scope": "cpp",
    "body": [
      "// source: https://judge.yosupo.jp/submission/172003",
      "constexpr auto floor(auto&& x, auto&& y) { return x / y - (x % y && (x ^ y) < 0); }",
      "constexpr auto ceil(auto&& x, auto&& y) { return floor(x + y - 1, y); }",
      "constexpr auto divmod(auto x, auto y) {",
      "    auto&& q = floor(x, y);",
      "    return std::pair{q, x - q * y};",
      "}"
    ],
    "description": "divmod"
  },
  "ext_gcd_inv.cpp": {
    "prefix": "ext_gcd_inv",
    "scope": "cpp",
    "body": [
      "/*",
      "ext gcd",
      "returns {g, x, y} that a * x + b * y = g = gcd(a,b)",
      "*/",
      "// using lll = __int128_t;",
      "struct tll{ll g, x, y;};",
      "tll ext_gcd(ll a, ll b) {",
      "    // assert(a>=0 && b>=0); // it actually works when a<0 or b<0",
      "    if(!b) return tll{a, 1, 0};",
      "    auto[g,x,y] = ext_gcd(b, a%b);",
      "    return tll{g, y, x-a/b*y};",
      "}",
      "",
      "// ADDITIONAL //",
      "",
      "// return x that a * x = 1 mod m",
      "ll inv(ll a, ll m){",
      "    auto [g,x,y] = ext_gcd(a, m);",
      "    if(g != 1) return -1;",
      "    return (x%m + m) % m;",
      "}",
      "// inv(i) = inv(p % i) * (-p / i)",
      "",
      "// do_smth for x,y that ax + by = s, x >= 0 && y >= 0",
      "bool do_smth(ll a, ll b, ll s){",
      "    auto [g,x,y] = ext_gcd(a, b);",
      "    if(s % g != 0) return false;",
      "    a /= g; b /= g; s /= g;",
      "    x *= s; y *= s;",
      "    ll t1 = x / b, t2 = y / a;",
      "    x -= b * t1; y += a * t1;",
      "    for(ll i = -t1; i<=t2; x += b, y -= a, i++){",
      "        if(x>=0 && y>=0){",
      "            // do smth",
      "        }",
      "    }",
      "    return true;",
      "}"
    ],
    "description": "ext_gcd_inv"
  },
  "FFT.cpp": {
    "prefix": "FFT",
    "scope": "cpp",
    "body": [
      "/*",
      "FFT",
      "reference: https://blog.myungwoo.kr/54",
      "*/",
      "namespace FFT{",
      "    using ld = long double;",
      "    using _base = complex<ld>;",
      "    const ld PI = acos(-1.0L);",
      "    void fft(vector <_base> &a, bool invert){",
      "        int n = size(a);",
      "        for (int i=1,j=0;i<n;i++){",
      "            int bit = n >> 1;",
      "            for (;j>=bit;bit>>=1) j -= bit;",
      "            j += bit;",
      "            if (i < j) swap(a[i],a[j]);",
      "        }",
      "        // original version, faster",
      "        for (int len=2;len<=n;len<<=1){",
      "            ld ang = 2*PI/len*(invert?-1:1);",
      "            _base wlen(cos(ang),sin(ang));",
      "            for (int i=0;i<n;i+=len){",
      "                _base w(1);",
      "                for (int j=0;j<len/2;j++){",
      "                    _base u = a[i+j], v = a[i+j+len/2]*w;",
      "                    a[i+j] = u+v;",
      "                    a[i+j+len/2] = u-v;",
      "                    w *= wlen;",
      "                }",
      "            }",
      "        }",
      "",
      "        // accurate version, but slower",
      "        // we precompute w array with cos&sin, and use it",
      "        // the original version multiplies w reapeatively",
      "",
      "        // for (int len=2;len<=n;len<<=1){",
      "        //     vector<_base> w(len/2);",
      "        //     for(int i=0;i<len/2;i++){",
      "        //         ld ang = 2*PI*i/len*(invert?-1:1);",
      "        //         w[i] = _base(cos(ang),sin(ang));",
      "        //     }",
      "        //     for (int i=0;i<n;i+=len){",
      "        //         for (int j=0;j<len/2;j++){",
      "        //             _base u = a[i+j], v = a[i+j+len/2]*w[j];",
      "        //             a[i+j] = u+v;",
      "        //             a[i+j+len/2] = u-v;",
      "        //         }",
      "        //     }",
      "        // }",
      "",
      "        if (invert){",
      "            for (int i=0;i<n;i++) a[i] /= n;",
      "        }",
      "    }",
      "    template<typename T=ll>",
      "    vector<T> convolution(const vector<T>&a, const vector<T>&b){",
      "        vector<_base> fa(begin(a),end(a)), fb(begin(b),end(b));",
      "        // mxsize = sz(a)+sz(b)-1",
      "        int n = 1;",
      "        while(n<fa.size()+fb.size()-1) n<<=1;",
      "        fa.resize(n); fb.resize(n);",
      "        fft(fa,false); fft(fb,false);",
      "        for (int i=0;i<n;i++) fa[i] *= fb[i];",
      "        fft(fa,true);",
      "        vector<T> res(n);",
      "        int SZ = 0;",
      "        for (int i=0;i<n;i++) {",
      "            res[i] = round(fa[i].real());",
      "            if(res[i]!=0) SZ=i+1;",
      "        }",
      "        //res.resize(SZ); // Use this for size opt. min(SZ,N) can be an alternative",
      "        return res;",
      "    }",
      "}"
    ],
    "description": "FFT"
  },
  "modint_combination.cpp": {
    "prefix": "modint_combination",
    "scope": "cpp",
    "body": [
      "/*",
      "Modint Implementation and Combination",
      "Reference: https://codeforces.com/blog/entry/127439 Problem E",
      "*/",
      "template<class T>",
      "constexpr T power(T a, ll b) {",
      "    T res = 1;",
      "    for (; b; b /= 2, a *= a) {",
      "        if (b % 2) {",
      "            res *= a;",
      "        }",
      "    }",
      "    return res;",
      "}",
      "",
      "template<int P>",
      "struct modint {",
      "    int x;",
      "    constexpr modint() : x{} {}",
      "    constexpr modint(ll x) : x{norm(x % P)} {}",
      "",
      "    constexpr int norm(int x) const {",
      "        if (x < 0) x += P;",
      "        if (x >= P) x -= P;",
      "        return x;",
      "    }",
      "    constexpr int val() const {return x;}",
      "    explicit constexpr operator int() const {return x;}",
      "    constexpr modint operator-() const {",
      "        modint res;",
      "        res.x = norm(P - x);",
      "        return res;",
      "    }",
      "    constexpr modint pow(ll b){",
      "        return power(*this, b);",
      "    }",
      "    constexpr modint inv() const {",
      "        assert(x != 0);",
      "        return power(*this, P-2);",
      "    }",
      "    constexpr modint &operator*=(modint rhs) {",
      "        x = 1LL * x * rhs.x % P;",
      "        return *this;",
      "    }",
      "    constexpr modint &operator+=(modint rhs) {",
      "        x = norm(x + rhs.x);",
      "        return *this;",
      "    }",
      "    constexpr modint &operator-=(modint rhs) {",
      "        x = norm(x - rhs.x);",
      "        return *this;",
      "    }",
      "    constexpr modint &operator/=(modint rhs) {",
      "        return *this *= rhs.inv();",
      "    }",
      "    friend constexpr modint operator*(modint lhs, modint rhs) {",
      "        modint res = lhs;",
      "        res *= rhs;",
      "        return res;",
      "    }",
      "    friend constexpr modint operator+(modint lhs, modint rhs) {",
      "        modint res = lhs;",
      "        res += rhs;",
      "        return res;",
      "    }",
      "    friend constexpr modint operator-(modint lhs, modint rhs) {",
      "        modint res = lhs;",
      "        res -= rhs;",
      "        return res;",
      "    }",
      "    friend constexpr modint operator/(modint lhs, modint rhs) {",
      "        modint res = lhs;",
      "        res /= rhs;",
      "        return res;",
      "    }",
      "    friend constexpr std::istream &operator>>(std::istream &is, modint &a) {",
      "        ll v;",
      "        is >> v;",
      "        a = modint(v);",
      "        return is;",
      "    }",
      "    friend constexpr std::ostream &operator<<(std::ostream &os, const modint &a) {",
      "        return os << a.val();",
      "    }",
      "    friend constexpr bool operator==(modint lhs, modint rhs) {",
      "        return lhs.val() == rhs.val();",
      "    }",
      "    friend constexpr bool operator!=(modint lhs, modint rhs) {",
      "        return lhs.val() != rhs.val();",
      "    }",
      "};",
      "",
      "template<int P,unsigned long long UP = (1ULL<<63)-1>",
      "struct comb {",
      "    using Z = modint<P>;",
      "    int n = 0;",
      "    std::vector<Z> _fac = {1};",
      "    std::vector<Z> _invfac = {1};",
      "    std::vector<Z> _inv = {0};",
      "    void init(int m) {",
      "        if (m <= n) return;",
      "        if (m >= P) m = P - 1;",
      "        _fac.resize(m + 1);",
      "        _invfac.resize(m + 1);",
      "        _inv.resize(m + 1);",
      "        for (int i = n + 1; i <= m; i++) {",
      "            _fac[i] = _fac[i - 1] * i;",
      "        }",
      "        _invfac[m] = _fac[m].inv();",
      "        for (int i = m; i > n; i--) {",
      "            _invfac[i - 1] = _invfac[i] * i;",
      "            _inv[i] = _invfac[i] * _fac[i - 1];",
      "        }",
      "        n = m;",
      "    }",
      "    int fac(int m) {",
      "        if (m >= P) return 0;",
      "        if (m > n) init(2 * m);",
      "        return _fac[m].val();",
      "    }",
      "    int invfac(int m) {",
      "        assert(m < P);",
      "        if (m > n) init(2 * m);",
      "        return _invfac[m].val();",
      "    }",
      "    int inv(int m) {",
      "        assert(m < P);",
      "        if (m > n) init(2 * m);",
      "        return _inv[m].val();",
      "    }",
      "    int binom(int m, int k) {",
      "        if (m < 0 || m < k || k < 0) return 0;",
      "        return (Z(fac(m)) * invfac(k) * invfac(m - k)).val();",
      "    }",
      "    using ull = unsigned long long;",
      "    std::vector<vector<ull>> bm = {{1}}; // we don't care overflow",
      "    void init_ull(int m){",
      "        int n = bm.size() - 1;",
      "        if(m <= n) return;",
      "        bm.resize(m+1);",
      "        for(int i = n + 1; i <= m; i++){",
      "            bm[i].resize(i+1);",
      "            bm[i][0] = bm[i][i] = 1;",
      "            for(int j = 1; j < i; j++)",
      "                bm[i][j] = min(bm[i-1][j] + bm[i-1][j-1], UP);",
      "        }",
      "    }",
      "    ull binom_ull(int m,int k){",
      "        if (m < 0 || m < k || k < 0) return 0;",
      "        init_ull(m);",
      "        return bm[m][k];",
      "    }",
      "};",
      "constexpr int MOD = ${0};",
      "using Z = modint<MOD>;"
    ],
    "description": "modint_combination"
  },
  "prime_factorization.cpp": {
    "prefix": "prime_factorization",
    "scope": "cpp",
    "body": [
      "namespace PollardRho{",
      "  using ull = unsigned long long;",
      "  constexpr int SZ = 100000;",
      "  bitset<SZ> isp; vector<int> prlist;",
      "  bool Sieve(){",
      "      isp.set(); isp[0]=isp[1]=false;",
      "      for(int i=2;i<SZ;i++){",
      "          if(isp[i]){",
      "              prlist.push_back(i);",
      "              if(1LL*i*i>=SZ) continue;",
      "              for(int j=i*i;j<SZ;j+=i) isp[j] = false;",
      "          }",
      "      }",
      "      return true;",
      "  }",
      "  ull MulMod(ull a,ull b,ull c){return (__uint128_t)a*b%c;}",
      "  ull PowMod(ull a,ull b,ull c){",
      "      ull ans = 1;",
      "      while(b>0){",
      "          if(b&1) ans = MulMod(ans,a,c);",
      "          a = MulMod(a,a,c);",
      "          b >>= 1;",
      "      }",
      "      return ans;",
      "  }",
      "  const int p32[]={2, 7, 61}, p64[]={2, 325, 9375, 28178, 450775, 9780504, 1795265022};",
      "  bool MillerRabin(ull n, ull a){ // is n prime based on a",
      "      if(a % n == 0) return true; // can't check",
      "      int cnt = __builtin_ctzll(n-1);",
      "      ull p = PowMod(a, n-1>>cnt, n);",
      "      if(p==1 || p==n-1) return true;",
      "      while(cnt--) if((p=MulMod(p,p,n))==n-1) return true;",
      "      return false;",
      "  }",
      "  bool IsPrime(ull n){",
      "      static bool start = Sieve();",
      "      if(n<SZ) return isp[n];",
      "      // check some base primes",
      "      for(int i=0;i<5;i++) if(n%prlist[i]==0) return false;",
      "      for(int p:p64) if(!MillerRabin(n,p)) return false;",
      "      return true;",
      "  }",
      "  template<typename T> T get_random(T l, T r){",
      "      static random_device rd;",
      "      return uniform_int_distribution<T>(l,r)(rd);",
      "  }",
      "  ull Rho(ull n){",
      "      while(true){",
      "          ull x_k = get_random<ull>(2,n-1), x_2k = x_k, c = get_random<ull>(1,n-1);",
      "          auto f = [&](ull x){",
      "              return (MulMod(x,x,n)+c)%n;",
      "          };",
      "          while(true){",
      "              x_k = f(x_k); x_2k = f(f(x_2k));",
      "              ull p = gcd(abs((ll)x_2k-(ll)x_k), n); if(p==1) continue;",
      "              if(IsPrime(p)) return p;",
      "              else{ n = p; break;}",
      "          }",
      "      }",
      "  }",
      "  vector<pair<ull,ull>> Factorize(ull n){",
      "      vector<pair<ull,ull>> v;",
      "      int two = __builtin_ctzll(n);",
      "      if(two>0) v.emplace_back(2, two), n >>= two;",
      "      if(n<=1) return v;",
      "      while(!IsPrime(n)){",
      "          ull p = Rho(n), cnt = 0; while(n%p==0) n/=p, cnt++;",
      "          v.emplace_back(p, cnt); if(n==1) break;",
      "      }",
      "      if(n>1) v.emplace_back(n,1);",
      "      sort(all(v)); // not required",
      "      return v;",
      "  }",
      "}"
    ],
    "description": "prime_factorization"
  },
  "Simplex.cpp": {
    "prefix": "Simplex",
    "scope": "cpp",
    "body": [
      "// NewTrend: https://github.com/jhwest1/newtrend-teamnote/blob/main/flow/simplex/final.cpp",
      "// Two-phase simplex algorithm for solving linear programs of the form",
      "//     maximize     c^T x",
      "//     subject to   Ax <= b",
      "//                   x >= 0",
      "// INPUT: A -- an m x n matrix",
      "//        b -- an m-dimensional vector",
      "//        c -- an n-dimensional vector",
      "//        x -- a vector where the optimal solution will be stored",
      "// OUTPUT: value of the optimal solution (infinity if unbounded",
      "//         above, nan if infeasible)",
      "// To use this code, create an LPSolver object with A, b, and c as",
      "// arguments.  Then, call Solve(x).",
      "// Time Complexity : exponential, but practically O(n^2m^2).",
      "typedef vector<double> VD;",
      "typedef vector<VD> VVD;",
      "typedef vector<int> VI;",
      "const double EPS = 1e-9;",
      "struct LPSolver {",
      "  int m, n;",
      "  VI B, N;",
      "  VVD D;",
      "  LPSolver(const VVD& A, const VD& b, const VD& c) :",
      "    m(b.size()), n(c.size()), N(n + 1), B(m), D(m + 2, VD(n + 2)) {",
      "        assert(A.size() == b.size() && A[0].size() == c.size());",
      "    for (int i = 0; i < m; i++) for (int j = 0; j < n; j++) D[i][j] = A[i][j];",
      "    for (int i = 0; i < m; i++) { B[i] = n + i; D[i][n] = -1; D[i][n + 1] = b[i]; }",
      "    for (int j = 0; j < n; j++) { N[j] = j; D[m][j] = -c[j]; }",
      "    N[n] = -1; D[m + 1][n] = 1;",
      "  }",
      "  void pivot(int r, int s) {",
      "    double inv = 1.0 / D[r][s];",
      "    for (int i = 0; i < m + 2; i++) if (i != r)",
      "      for (int j = 0; j < n + 2; j++) if (j != s)",
      "        D[i][j] -= D[r][j] * D[i][s] * inv;",
      "    for (int j = 0; j < n + 2; j++) if (j != s) D[r][j] *= inv;",
      "    for (int i = 0; i < m + 2; i++) if (i != r) D[i][s] *= -inv;",
      "    D[r][s] = inv;",
      "    swap(B[r], N[s]);",
      "  }",
      "  bool simplex(int phase) {",
      "    int x = phase == 1 ? m + 1 : m;",
      "    while (true) {",
      "      int s = -1;",
      "      for (int j = 0; j <= n; j++) {",
      "        if (phase == 2 && N[j] == -1) continue;",
      "        if (s == -1 || D[x][j] < D[x][s] || D[x][j] == D[x][s] && N[j] < N[s]) s = j;",
      "      }",
      "      if (D[x][s] > -EPS) return true;",
      "      int r = -1;",
      "      for (int i = 0; i < m; i++) {",
      "        if (D[i][s] < EPS) continue;",
      "        if (r == -1 || D[i][n + 1] / D[i][s] < D[r][n + 1] / D[r][s] ||",
      "          (D[i][n + 1] / D[i][s]) == (D[r][n + 1] / D[r][s]) && B[i] < B[r]) r = i;",
      "      }",
      "      if (r == -1) return false;",
      "      pivot(r, s);",
      "    }",
      "  }",
      "  double solve(VD& x) {",
      "    int r = 0;",
      "    for (int i = 1; i < m; i++) if (D[i][n + 1] < D[r][n + 1]) r = i;",
      "    if (D[r][n + 1] < -EPS) {",
      "      pivot(r, n);",
      "      if (!simplex(1) || D[m + 1][n + 1] < -EPS)",
      "        return -numeric_limits<double>::infinity();",
      "      for (int i = 0; i < m; i++) if (B[i] == -1) {",
      "        int s = -1;",
      "        for (int j = 0; j <= n; j++)",
      "          if (s == -1 || D[i][j] < D[i][s] || D[i][j] == D[i][s] && N[j] < N[s]) s = j;",
      "        pivot(i, s);",
      "      }",
      "    }",
      "    if (!simplex(2))",
      "      return numeric_limits<double>::infinity();",
      "    x = VD(n);",
      "    for (int i = 0; i < m; i++) if (B[i] < n) x[B[i]] = D[i][n + 1];",
      "    return D[m][n + 1];",
      "  }",
      "};"
    ],
    "description": "Simplex"
  },
  "[WIP] Matrix.cpp": {
    "prefix": "[WIP] Matrix",
    "scope": "cpp",
    "body": [
      "using matrix = vector<vector<int>>;",
      "matrix fail = {{-1}};",
      "void init(matrix&A,int r,int c){",
      "\tA.resize(r);",
      "\tfor(int i=0;i<r;i++) A[i].resize(c);",
      "}",
      "const int MOD = 1e9+7;",
      "matrix operator*(const matrix&A,const matrix&B){",
      "\tint r1=A.size(),c1=A[0].size(),r2=B.size(),c2=B[0].size();",
      "\tif(c1!=r2) return fail;",
      "\tT C; init(C,r1,c2);",
      "\tfor(int i=0;i<r1;i++)",
      "\t\tfor(int k=0;k<c1;k++){",
      "\t\t\tconst ll tmp = A[i][k];",
      "\t\t\tfor(int j=0;j<c2;j++){",
      "\t\t\t\tC[i][j] += tmp*B[k][j]%MOD;",
      "\t\t\t\tC[i][j] %= MOD;",
      "\t\t\t}",
      "\t\t}",
      "\treturn C;",
      "}",
      "matrix operator^(const matrix&A,ll x){",
      "\tif(x<=0) return fail;",
      "\tT1 ans = A; --x;",
      "\twhile(x>0){",
      "\t\tif(x&1) ans = ans * A;",
      "\t\tx>>=1; A = A*A;",
      "\t}",
      "\treturn ans;",
      "}"
    ],
    "description": "[WIP] Matrix"
  },
  "[WIP] Sieve.cpp": {
    "prefix": "[WIP] Sieve",
    "scope": "cpp",
    "body": [
      "//Number Theory",
      "namespace Sieve{",
      "    template<typename T=int>",
      "    T fpow(T a,T b,int mod=0){",
      "        T ans = 1;",
      "        while(b){",
      "            if(b&1) mod?(ans=ans*a%mod):(ans*=a);",
      "            mod?(a=a*a%mod):(a*=a);",
      "            b>>=1;",
      "        }",
      "        return ans;",
      "    }",
      "    bool isprime_naive(int n){",
      "        if(n<2) return false;",
      "        for(int i=2;i*i<=n;i++) if(n%i==0) return false;",
      "        return true;",
      "    }",
      "    struct Sieve{",
      "        int SZ;",
      "        vector<int> p, spf, e, phi, mu, tau, sigma;",
      "        vector<bool> isp;",
      "        //mode 1: linear, mode 2: get other factors",
      "        Sieve(int n=1e6,int mode = 1){",
      "            SZ = n+1;",
      "            spf = vector<int>(SZ);",
      "            if(mode==2){",
      "                //e: n\uc758 spf\uc758 \uc9c0\uc218",
      "                e=phi=mu=tau=sigma=spf;",
      "                phi[1]=mu[1]=tau[1]=sigma[1]=1;",
      "            }",
      "            for(int i=2;i<SZ;i++){",
      "                if(!spf[i]){",
      "                    p.push_back(i);",
      "                    spf[i] = i;",
      "                    if(mode==2){",
      "                        e[i]=1;",
      "                        phi[i]=i-1;",
      "                        mu[i]=-1;",
      "                        tau[i]=2;",
      "                        sigma[i]=i+1;",
      "                    }",
      "                }",
      "                //j is a prime",
      "                for(auto j:p){",
      "                    int nxt = i*j;",
      "                    if(nxt>=SZ) break;",
      "                    spf[nxt] = j;",
      "                    // j | i",
      "                    if(i%j==0){",
      "                        if(mode==2){",
      "                            e[nxt] = e[i] + 1;",
      "                            phi[nxt] = phi[i] * j;",
      "                            mu[nxt] = 0;",
      "                            tau[nxt] = tau[i] / (e[i]+1) * (e[nxt]+1);",
      "                            sigma[nxt] = sigma[i]*(j-1)/(fpow(j, e[nxt])-1)*(fpow(j, e[nxt]+1)-1)/(j-1);",
      "                        }",
      "                        break;",
      "                    }",
      "                    if(mode==2){",
      "                        // j \\| = i, \uacf1\uc148\ud568\uc218\uc758 \uc131\uc9c8 \uc774\uc6a9 \uac00\ub2a5",
      "                        e[nxt] = 1;",
      "                        phi[nxt] = phi[i] * phi[j];",
      "                        mu[nxt] = mu[i] *  mu[j];",
      "                        tau[nxt] = tau[i] * tau[j];",
      "                        sigma[nxt] = sigma[i] * sigma[j];",
      "                    }",
      "                }",
      "            }",
      "        }",
      "        inline bool isprime(int n){",
      "            return n>1 && spf[n]==n;",
      "        }",
      "        vector<pii> factor(int n){",
      "            vector<pii> v;",
      "            while(n>1){",
      "                if(!v.empty() && v.back().first == spf[n]) v.back().second++;",
      "                else v.emplace_back(spf[n],1);",
      "                n /= spf[n];",
      "            }",
      "            return v;",
      "        }",
      "        // [A, B)",
      "        template<typename T>",
      "        vector<T> primelist(T A,T B){",
      "            assert((T)SZ*SZ >= B);",
      "            isp.assign(B-A,true);",
      "            for(T i:p){",
      "                for(T j = max(2*i, (A+i-1)/i*i);j<B;j+=i){",
      "                    isp[j-A] = false;",
      "                }",
      "            }",
      "            vector<T> v;",
      "            for(T i=A;i<B;i++){",
      "                if(i<2) continue;",
      "                if(isp[i-A]) v.push_back(i);",
      "            }",
      "            return v;",
      "        }",
      "    };",
      "}"
    ],
    "description": "[WIP] Sieve"
  },
  "Aho-Corasick.cpp": {
    "prefix": "Aho-Corasick",
    "scope": "cpp",
    "body": [
      "/*",
      "Aho Corasick Algorithm",
      "Manage multiple pattern strings at once",
      "O(sum(|s|) + p) instead of O(n * p)",
      "use map instead of arrays if u need O(m log K) transition and memory",
      "add_string() to add patterns",
      "(note that we do not have to manage all patterns at once in some situations like chk_included)",
      "- Find all strings from a given set in a text",
      "- Finding the lexicographically smallest string of a given length that doesn't match any given strings",
      "- Finding the shortest string containing all given strings",
      "- Finding the lexicographically smallest string of length $L$ containing $k$ strings",
      "reference: https://cp-algorithms.com/string/aho_corasick.html",
      "tests:",
      "https://www.acmicpc.net/source/share/8fa21bc44dc747f6822e77791c39838f",
      "https://www.acmicpc.net/source/share/62e0f44ed32d4ee2a64230380f91b0e0",
      "*/",
      "const int K = 26;",
      "struct Aho_Corasick{",
      "    inline int to_int(char const&c){",
      "        int res = c - 'a';",
      "        assert(0 <= res && res < K);",
      "        return res;",
      "    }",
      "    struct Vertex {",
      "        int next[K];",
      "        bool output = false;",
      "        int output_len = 0;",
      "        int p = -1;",
      "        char pch;",
      "        int link = -1;",
      "        int go[K];",
      "        int out_cnt = -1;",
      "        int pre_out = 0;",
      "        int max_out_len = 0;",
      "        Vertex(int p=-1, char ch='$') : p(p), pch(ch) {",
      "            fill(begin(next), end(next), -1);",
      "            fill(begin(go), end(go), -1);",
      "        }",
      "    };",
      "    vector<Vertex> t;",
      "    Aho_Corasick(){",
      "        t = vector<Vertex>(1);",
      "    }",
      "    void add_string(string const& s) {",
      "        int v = 0;",
      "        for (char ch : s) {",
      "            int c = to_int(ch);",
      "            if (t[v].next[c] == -1) {",
      "                t[v].next[c] = t.size();",
      "                t.emplace_back(v, ch);",
      "            }",
      "            v = t[v].next[c];",
      "        }",
      "        t[v].output = true;",
      "        t[v].output_len = s.length();",
      "    }",
      "    int get_link(int v) {",
      "        int &link = t[v].link;",
      "        if (link == -1) {",
      "            if (v == 0 || t[v].p == 0) link = 0;",
      "            else link = go(get_link(t[v].p), t[v].pch);",
      "        }",
      "        return link;",
      "    }",
      "    int go(int v, char ch) {",
      "        int c = to_int(ch);",
      "        if (t[v].go[c] == -1) {",
      "            if (t[v].next[c] != -1)",
      "                t[v].go[c] = t[v].next[c];",
      "            else",
      "                t[v].go[c] = v == 0 ? 0 : go(get_link(v), ch);",
      "        }",
      "        return t[v].go[c];",
      "    }",
      "",
      "    int get_all_out(int v){",
      "        int &out_cnt = t[v].out_cnt;",
      "        if(out_cnt == -1){",
      "            out_cnt = (int)t[v].output; // do this first",
      "            int link = get_link(v);",
      "            out_cnt += get_all_out(link);",
      "            if(t[link].output) t[v].pre_out = link;",
      "            else t[v].pre_out = t[link].pre_out;",
      "            t[v].max_out_len = max(t[v].output_len, t[link].max_out_len);",
      "        }",
      "        return out_cnt;",
      "    }",
      "    // O(|s|)",
      "    ll count_occurence(string const&s){",
      "        int v = 0;",
      "        ll ans = 0;",
      "        for(char c: s){",
      "            v = go(v, c);",
      "            ans += get_all_out(v);",
      "        }",
      "        return ans;",
      "    }",
      "    // O(|s|)",
      "    void chk_included(string const&s, vector<int>&chkv){",
      "        assert(chkv.size() == s.length() + 1);",
      "        int v = 0;",
      "        for(int i=0;i<s.length();i++){",
      "            v = go(v, s[i]);",
      "            if(get_all_out(v) > 0){",
      "                const int mxlen = t[v].max_out_len;",
      "                assert(mxlen > 0);",
      "                // i - mxlen + 1 ~ i\uae4c\uc9c0 \uc0ac\uc6a9\ub428",
      "                chkv[i-mxlen+1] ++;",
      "                chkv[i+1] --;",
      "            }",
      "        }",
      "    }",
      "};"
    ],
    "description": "Aho-Corasick"
  },
  "Fast_LCS.cpp": {
    "prefix": "Fast_LCS",
    "scope": "cpp",
    "body": [
      "/*",
      "Get LCS(Longest Common Subsequence) of string A, B in O(|A|(|B|/|W|)), where |W| is word size, 64",
      "We use bitset opt and Hirschberg's Algorithm for recovering",
      "used unsigned long long arrays for bitset implementation",
      "IMPORTANT:  set base variables below before using",
      "MXN: max size of string B",
      "MX_ALP: number of possible alphabets",
      "BASE_ALP: the minimum ascii value among all alphabets",
      "reference: https://github.com/infossm/infossm.github.io/blob/master/_posts/2019-09-13-lcs-with-bitset.md",
      "test: https://www.acmicpc.net/problem/18440",
      "*/",
      "namespace FAST_LCS{",
      "    const int MXN = 5e4 + 10;",
      "    const int MX_ALP = 26;",
      "    const char BASE_ALP = 'A';",
      "",
      "    using ull = unsigned long long;",
      "    ull dt[(MXN>>6)+1], S[MX_ALP][(MXN>>6)+1];",
      "    inline bool _test(ull arr[],int x){",
      "        return (bool)(arr[x>>6] & (1ULL << (x&63)));",
      "    }",
      "    inline void _set(ull arr[],int x){",
      "        arr[x>>6] |= 1ULL << (x&63);",
      "    }",
      "",
      "    #include<immintrin.h>",
      "    vector<int> getLCSdp(const string &A,const string &B){",
      "        int n=A.size(),m=B.size(),ans=0;",
      "        int siz = (m>>6)+1;",
      "",
      "        // Init",
      "        for(int i=0;i<siz;i++) dt[i] = 0;",
      "        for(int i=0;i<MX_ALP;i++) for(int j=0;j<siz;j++) S[i][j] = 0;",
      "",
      "        for(int i=0;i<m;i++) S[B[i]-BASE_ALP][i>>6]|=1ULL<<(i&63);",
      "        for(int i=0;i<n;i++){",
      "            for(int j=0, c=1, mc=0; j<siz;j++){",
      "                ull x = dt[j] | S[A[i]-BASE_ALP][j], y;",
      "                mc = _subborrow_u64(mc, x, (dt[j]<<1)|c, &y);",
      "                c = dt[j] >> 63;",
      "                dt[j] = x & (x^y);",
      "            }",
      "        }",
      "        vector<int> v(m+1);",
      "        for(int i=0;i<m;i++) v[i+1] = v[i] + !!(dt[i>>6] & (1ULL<<(i&63)));",
      "        return v;",
      "    }",
      "    std::string getLCS(const string &A,const string &B){ // recover actual LCS of A and B using Hirschberg's Algorithm",
      "        int n = A.size(), m = B.size();",
      "        string ans = \"\";",
      "        if(!m) return ans;",
      "        if(n==1){",
      "            for(int i=0;i<m;i++)",
      "                if(B[i]==A[0]){",
      "                    ans = string(1,A[0]);",
      "                    break;",
      "                }",
      "        }else if(m==1){",
      "            for(int i=0;i<n;i++)",
      "                if(A[i]==B[0]){",
      "                    ans = string(1,B[0]);",
      "                    break;",
      "                }",
      "        }else{ // n>1 && m>1",
      "            int mid = n/2;",
      "            string A1 = A.substr(0,mid);",
      "            string A2 = A.substr(mid,n-mid);",
      "            reverse(all(A2));",
      "            string B1, B2 = B;",
      "            reverse(all(B2));",
      "            vector<int>&&dp1 = getLCSdp(A1,B);",
      "            vector<int>&&dp2 = getLCSdp(A2,B2);",
      "            int best = 0;",
      "            for(int i=0;i<=m;i++)",
      "                if(dp1[i]+dp2[m-i] > dp1[best]+dp2[m-best])",
      "                    best = i;",
      "            B1 = B.substr(0,best);",
      "            B2 = B.substr(best,m-best);",
      "            reverse(all(A2));",
      "            ans = getLCS(A1,B1) + getLCS(A2,B2);",
      "        }",
      "        return ans;",
      "    }",
      "}"
    ],
    "description": "Fast_LCS"
  },
  "Hasher_Dot.cpp": {
    "prefix": "Hasher_Dot",
    "scope": "cpp",
    "body": [
      "/*Hasher that uses simple dot product and unsigned long long",
      "reference: Koosaga(https://github.com/koosaga/olympiad/blob/master/POI/poi08_poc.cpp)",
      "*/",
      "using hash_t = unsigned long long;",
      "struct Hasher_Dot{",
      "    int sz{};",
      "    vector<hash_t> magic{};",
      "    mt19937_64 gen;",
      "    Hasher_Dot(int n = 0):gen(chrono::steady_clock::now().time_since_epoch().count()){",
      "        extend(n);",
      "    }",
      "    void extend(int n){",
      "        magic.resize(n);",
      "        for(int i=sz;i<n;i++)",
      "            magic[i] = uniform_int_distribution<hash_t>(0ull,~0ull)(gen);",
      "        sz = n;",
      "    }",
      "    // vector, string, whatever",
      "    template<typename T>",
      "    hash_t hash(const T& s){",
      "        int n = s.size();",
      "        if(n > sz) extend(n);",
      "        hash_t h = 0;",
      "        for(int i=0;i<n;i++)",
      "            h += magic[i] * s[i];",
      "        return h;",
      "    }",
      "};"
    ],
    "description": "Hasher_Dot"
  },
  "Kmp.cpp": {
    "prefix": "Kmp",
    "scope": "cpp",
    "body": [
      "/*",
      "getPi: get Failure function(Pi) of pattern p",
      "kmp: get occurence of pattern p in string s",
      "*/",
      "template<typename T>",
      "vector<int> getPi(const T&p){",
      "    vector<int> pi(size(p));",
      "    for(int i=1,j=0;i<size(p);i++){",
      "        while(j > 0 && p[i] != p[j]) j = pi[j-1];",
      "        if(p[i] == p[j]) pi[i] = ++j;",
      "    }",
      "    return pi;",
      "}",
      "template<typename T>",
      "vector<int> kmp(const T&s,const T&p){",
      "    vector<int> pi = getPi(p);",
      "    vector<int> ansv;",
      "    for(int i=0,j=0;i<size(s);i++){",
      "        while(j>0 && s[i]!=p[j]) j = pi[j-1];",
      "        if(s[i] == p[j]) ++j;",
      "        if(j==size(p)){",
      "            ansv.push_back(i-size(p)+1);",
      "            j = pi[j-1];",
      "        }",
      "    }",
      "    return ansv;",
      "}"
    ],
    "description": "Kmp"
  },
  "Manacher.cpp": {
    "prefix": "Manacher",
    "scope": "cpp",
    "body": [
      "/*",
      "Mancher Algorithm: Finding all sub-palindrome-strings in O(n)",
      "returns vector d, length of 2*n-1",
      "extends the original string. \"abc\" -> \"a#b#c\"",
      "each d(i) represents the length of palindrome substring, which the center is $i$",
      "Longest palindrome of s: max(d)",
      "number of palindrome substrings: sum((d[i]+1)/2)",
      "reference: https://00ad-8e71-00ff-055d.tistory.com/91",
      "*/",
      "template<typename T>",
      "vector<int> manacher(T s){",
      "    int n = size(s);",
      "    if(n == 0) return vector<int>();",
      "    s.resize(2 * n - 1);",
      "    for(int i = n - 1; i; i--){",
      "        s[2 * i] = s[i];",
      "        s[2 * i - 1] = '#';",
      "    }",
      "    n = size(s);",
      "    vector<int> d(n);",
      "    int p = 0, v = 0;",
      "    for(int i = 1; i < n; i++){",
      "        if(i <= v)d[i] = min(d[2 * p - i], v - i);",
      "        while(i - d[i] - 1 >= 0 && i + d[i] + 1 < n && s[i - d[i] - 1] == s[i + d[i] + 1])",
      "            d[i]++;",
      "        if(i + d[i] > v){",
      "            p = i;",
      "            v = i + d[i];",
      "        }",
      "    }",
      "    for(int i=0; i<n; i++)",
      "        d[i] +=(i % 2 == d[i] % 2);",
      "    return d;",
      "}"
    ],
    "description": "Manacher"
  },
  "SuffixArray.cpp": {
    "prefix": "SuffixArray",
    "scope": "cpp",
    "body": [
      "/*",
      "Suffix array and LCP construction",
      "SA: suffix\ub4e4\uc744 \uc0ac\uc804 \uc21c\uc73c\ub85c \uc815\ub82c\ud574\ub193\uc740 \ubc30\uc5f4",
      "LCP: Longest Common Prefix\uc758 \uae38\uc774, \ub2e4\ub9cc \uc778\uc811\ud55c \uac83\ub4e4\ub9cc \ubd04",
      "\uc774\uc81c LCP(i) Suffix array\uc5d0\uc11c i\ubc88\uc9f8\uc640 i+1\ubc88\uc9f8 \ucd5c\ub300 \uae34 Prefix\uc758 \uae38\uc774.",
      "AWARE: string shouldn't character same as additional char for cyclic shift. -> char(1) in our case",
      "if you want to make longer ones to latter, make it char(255) rather than char(1) and erase prev(end()) rather than begin() (think of it..)",
      "string s; cin>>s;",
      "auto sfa = suffix_array_construction(s);",
      "auto lcp = lcp_construction(s, sfa);",
      "sfa[i]: ith lexicographically small suffix",
      "lcp[i]: longest common prefix between sfa[i-1] and sfa[i]",
      "(lcp[0] == 0)",
      "reference: https://cp-algorithms.com/string/suffix-array.html",
      "*/",
      "vector<int> sort_cyclic_shifts(string const& s) {",
      "    int n = s.size();",
      "    const int alphabet = 256;",
      "    vector<int> p(n), c(n), cnt(max(alphabet, n), 0);",
      "    for (int i = 0; i < n; i++)",
      "        cnt[s[i]]++;",
      "    for (int i = 1; i < alphabet; i++)",
      "        cnt[i] += cnt[i-1];",
      "    for (int i = 0; i < n; i++)",
      "        p[--cnt[s[i]]] = i;",
      "    c[p[0]] = 0;",
      "    int classes = 1;",
      "    for (int i = 1; i < n; i++) {",
      "        if (s[p[i]] != s[p[i-1]])",
      "            classes++;",
      "        c[p[i]] = classes - 1;",
      "    }",
      "    vector<int> pn(n), cn(n);",
      "    for (int h = 0; (1 << h) < n; ++h) {",
      "        for (int i = 0; i < n; i++) {",
      "            pn[i] = p[i] - (1 << h);",
      "            if (pn[i] < 0)",
      "                pn[i] += n;",
      "        }",
      "        fill(cnt.begin(), cnt.begin() + classes, 0);",
      "        for (int i = 0; i < n; i++)",
      "            cnt[c[pn[i]]]++;",
      "        for (int i = 1; i < classes; i++)",
      "            cnt[i] += cnt[i-1];",
      "        for (int i = n-1; i >= 0; i--)",
      "            p[--cnt[c[pn[i]]]] = pn[i];",
      "        cn[p[0]] = 0;",
      "        classes = 1;",
      "        for (int i = 1; i < n; i++) {",
      "            pair<int, int> cur = {c[p[i]], c[(p[i] + (1 << h)) % n]};",
      "            pair<int, int> prev = {c[p[i-1]], c[(p[i-1] + (1 << h)) % n]};",
      "            if (cur != prev)",
      "                ++classes;",
      "            cn[p[i]] = classes - 1;",
      "        }",
      "        if(cn[p[n-1]] == n-1) break; // we found every distinct suffixes",
      "        c.swap(cn);",
      "    }",
      "    return p;",
      "}",
      "",
      "vector<int> suffix_array_construction(string s) {",
      "    s += char(1);",
      "    vector<int> sorted_shifts = sort_cyclic_shifts(s);",
      "    sorted_shifts.erase(sorted_shifts.begin());",
      "    return sorted_shifts;",
      "}",
      "",
      "",
      "vector<int> lcp_construction(string const& s, vector<int> const& p) {",
      "    int n = s.size();",
      "    vector<int> rank(n, 0);",
      "    for (int i = 0; i < n; i++)",
      "        rank[p[i]] = i;",
      "",
      "    int k = 0;",
      "    vector<int> lcp(n, 0); // segfault issue",
      "    for (int i = 0; i < n; i++) {",
      "        if (rank[i] == n - 1) {",
      "            k = 0;",
      "            continue;",
      "        }",
      "        int j = p[rank[i] + 1];",
      "        while (i + k < n && j + k < n && s[i+k] == s[j+k])",
      "            k++;",
      "        lcp[rank[i] + 1] = k;",
      "        if (k) k--;",
      "    }",
      "    return lcp;",
      "}",
      "",
      "vector<int> lcp_construction(string const& s){",
      "    return lcp_construction(s, suffix_array_construction(s));",
      "}"
    ],
    "description": "SuffixArray"
  },
  "Suffix_Array_Benq.cpp": {
    "prefix": "Suffix_Array_Benq",
    "scope": "cpp",
    "body": [
      "https://github.com/bqi343/cp-notebook/blob/master/Implementations/content/strings%20(14)/Light/SuffixArray%20(14.4).h",
      "/**",
      " * Description: Sort suffixes. First element of \\texttt{sa} is \\texttt{sz(S)},",
      " \t* \\texttt{isa} is the inverse of \\texttt{sa}, and \\texttt{lcp} stores",
      " \t* the longest common prefix between every two consecutive elements of \\texttt{sa}.",
      " * Time: O(N\\log N)",
      " * Source: SuprDewd, KACTL, majk, ekzhang (http://ekzlib.herokuapp.com)",
      " * Verification:",
      "\t* https://open.kattis.com/problems/suffixsorting",
      "\t* https://judge.yosupo.jp/problem/suffixarray",
      " */",
      "",
      "// sa: index of ith lexicographical fastest suffix",
      "// isa: inverse sa",
      "// lcp[i]: longest common prefix of sa[i] and sa[i+1]",
      "struct SuffixArray {",
      "\tstr S; int N; vi sa, isa, lcp;",
      "\tvoid init(str _S) { N = sz(S = _S)+1; genSa(); genLcp(); }",
      "\tvoid genSa() { // sa has size sz(S)+1, starts with sz(S)",
      "\t\tsa = isa = vi(N); sa[0] = N-1; iota(1+all(sa),0);",
      "\t\tsort(1+all(sa),[&](int a, int b) { return S[a] < S[b]; });",
      "\t\tFOR(i,1,N) { int a = sa[i-1], b = sa[i];",
      "\t\t\tisa[b] = i > 1 && S[a] == S[b] ? isa[a] : i; }",
      "\t\tfor (int len = 1; len < N; len *= 2) { // currently sorted",
      "\t\t\t// by first len chars",
      "\t\t\tvi s(sa), is(isa), pos(N); iota(all(pos),0);",
      "\t\t\teach(t,s) {int T=t-len;if (T>=0) sa[pos[isa[T]]++] = T;}",
      "\t\t\tFOR(i,1,N) { int a = sa[i-1], b = sa[i]; /// verify that nothing goes out of bounds",
      "\t\t\t\tisa[b] = is[a]==is[b]&&is[a+len]==is[b+len]?isa[a]:i; }",
      "\t\t}",
      "\t}",
      "\tvoid genLcp() { // Kasai's Algo",
      "\t\tlcp = vi(N-1); int h = 0;",
      "\t\tF0R(b,N-1) { int a = sa[isa[b]-1];",
      "\t\t\twhile (a+h < sz(S) && S[a+h] == S[b+h]) ++h;",
      "\t\t\tlcp[isa[b]-1] = h; if (h) h--; }",
      "\t\t/// if we cut off first chars of two strings with lcp h",
      "\t\t/// then remaining portions still have lcp h-1",
      "\t\tR.init(lcp);",
      "\t}",
      "\tRMQ<int> R;",
      "\tint getLCP(int a, int b) { // lcp of suffixes starting at a,b",
      "\t\tif (a == b) return sz(S)-a;",
      "\t\tint l = isa[a], r = isa[b]; if (l > r) swap(l,r);",
      "\t\treturn R.query(l,r-1);",
      "\t}",
      "};",
      ""
    ],
    "description": "Suffix_Array_Benq"
  }
}